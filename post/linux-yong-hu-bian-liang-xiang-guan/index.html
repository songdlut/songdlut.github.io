<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Gridea静态个人博客">
<meta name="description" content="学习博客">
<meta name="theme-color" content="#000">
<title>Linux用户变量相关 | 宋宇航的博客</title>
<link rel="shortcut icon" href="/favicon.ico?v=1676567121311">
<link rel="stylesheet" href="/media/css/gemini.css">
<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/androidstudio.css"
  rel="stylesheet">

<link rel="stylesheet" href="/styles/main.css">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"
  integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"
  integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"
  integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"
  onload="renderMathInElement(document.body);"></script>





  <meta name="description" content="Linux用户变量相关" />
  <meta name="keywords" content="环境配置,Linux" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class="gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>宋宇航的博客</span>
            </a>  
          
        </div>
        
          <p class="subtitle">越努力,越幸运</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://songdlut.github.io/" target="_self">
                  <i class="fa fa-globe"></i> 首页
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://songdlut.github.io/archives/" target="_self">
                  <i class="fa fa-globe"></i> 归档
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://songdlut.github.io/tags/" target="_self">
                  <i class="fa fa-globe"></i> 标签
                </a>
              
            </li>
          
            
            
              
            
            <li class="nav-item ">
              
              
                <a href="https://songdlut.github.io/post/about/" target="_self">
                  <i class="fa fa-globe"></i> 关于
                </a>
              
            </li>
          
          
            
              <li class="nav-item ">
                <a href="/friends/" target="_self">
                  
                    <i class="fa fa-address-book"></i> 友情链接
                  
                </a>
              </li>
            
          
          
            <li id="fa_search" class="nav-item">
              <a href="javascript:void(0);">
                <i class="fa fa-search"></i> <span class="language" data-lan="search">搜索</span>
              </a>
            </li>
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active language" data-lan="index">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item language" data-lan="preview">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">宋宇航</p>
    
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">141</span>
        <span class="site-item-stat-name language" data-lan="article">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">26</span>
        <span class="site-item-stat-name language" data-lan="category">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">26</span>
        <span class="site-item-stat-name language" data-lan="tag">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://songdlut.github.io/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
        
          
            <a class="social-img" href="#">
              <img src="" />
              <i class="fa fa-globe" title="" ></i>
            </a>
          
        
      </div>
    </div>
  



  <div style="width: 100%; position: relative;">
    <canvas id="canvasDiyBlock" style="width:100%;">当前浏览器不支持canvas，请更换浏览器后再试</canvas>
    <script src="/media/js/magic/clock.js"></script>
  </div>

</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number auto"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E6%9F%A5%E7%9C%8Bpath">查看PATH</a></li>
<li><a href="#1-%E7%9B%B4%E6%8E%A5export">1 直接export</a></li>
<li><a href="#bashrc%E6%96%87%E4%BB%B6">.bashrc文件</a></li>
<li><a href="#%E9%80%9A%E8%BF%87%E4%BF%AE%E6%94%B9profile%E6%96%87%E4%BB%B6">通过修改profile文件:</a></li>
<li><a href="#%E8%BF%87%E4%BF%AE%E6%94%B9environment%E6%96%87%E4%BB%B6">过修改environment文件:</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0] && elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://songdlut.github.io/post/linux-yong-hu-bian-liang-xiang-guan/">
      Linux用户变量相关
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span class="language" data-lan="publish">发布于</span>
      <span>2022-03-25</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show language" data-lan="category-in">分类于</span>
      
      
      <a href="https://songdlut.github.io/tag/wpZJg44hLT/">
        <span>环境配置</span>
      </a>、
      
      
      
      <a href="https://songdlut.github.io/tag/gLf7Nkzziz/">
        <span>Linux</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>2<span class="language" data-lan="minute">分钟</span></span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>261<span class="pc-show language" data-lan="words">字数</span></span>
    </span>
    
    
    
    <span id="/post/linux-yong-hu-bian-liang-xiang-guan/" data-flag-title="Linux用户变量相关" class="meta-item pc-show leancloud_visitors">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-eye"></i>
      <span><span class="language" data-lan="view">浏览量</span>：<span class="leancloud-visitors-count"></span></span>
    </span>
    
  </div>
</header>
            <div class="post-body next-md-body" id="post_body">
              <h2 id="查看path">查看PATH</h2>
<pre><code class="language-shell">echo $PATH #显示PATH设置
env  #显示当前用户变量
</code></pre>
<h2 id="1-直接export">1 直接export</h2>
<pre><code class="language-shell">export PATH=/......./bin:$PATH
</code></pre>
<p>生效方法：立即生效<br>
有效期限：临时改变，只能在当前终端有效，关了重开就没了<br>
用户局限：仅对当前用户</p>
<h2 id="bashrc文件">.bashrc文件</h2>
<pre><code class="language-shell">vim ~/.bashrc
#文件后面添加：
export PATH=/......./bin:$PATH
</code></pre>
<p>生效方法：（有以下两种）<br>
1、关闭当前终端窗口，重新打开一个新终端窗口就能生效<br>
2、输入“source ~/.bashrc”命令，立即生效<br>
有效期限：永久有效<br>
用户局限：仅对当前用户</p>
<h2 id="通过修改profile文件">通过修改profile文件:</h2>
<p>vim /etc/profile<br>
/export PATH //找到设置PATH的行，添加<br>
export PATH=/usr/local/mongodb/bin:$PATH<br>
生效方法：系统重启<br>
有效期限：永久有效<br>
用户局限：对所有用户</p>
<h2 id="过修改environment文件">过修改environment文件:</h2>
<p>vim /etc/environment<br>
在PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games&quot;中加入“:/usr/local/mongodb/bin”<br>
生效方法：系统重启<br>
有效期限：永久有效<br>
用户局限：对所有用户</p>

            </div>
            
            
              <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong class="language" data-lan="author">本文作者：</strong>
      宋宇航
    </li>
    <li class="post-copyright-link">
      <strong class="language" data-lan="link">本文链接：</strong>
      <a href="https://songdlut.github.io/post/linux-yong-hu-bian-liang-xiang-guan/" title="Linux用户变量相关">https://songdlut.github.io/post/linux-yong-hu-bian-liang-xiang-guan/</a>
    </li>
    <li class="post-copyright-license">
      <strong class="language" data-lan="copyright">版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://songdlut.github.io/tag/wpZJg44hLT/"># 环境配置</a>
    
      <a href="https://songdlut.github.io/tag/gLf7Nkzziz/"># Linux</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="typedef用法" href="https://songdlut.github.io/post/typedef-yong-fa/">typedef用法</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="typedef用法" href="https://songdlut.github.io/post/typedef-yong-fa/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="Trie树（字典树，单词查找树）" href="https://songdlut.github.io/post/trie-shu-zi-dian-shu-dan-ci-cha-zhao-shu/">Trie树（字典树，单词查找树）</a>
        <a class="nav-mobile-next" title="Trie树（字典树，单词查找树）" href="https://songdlut.github.io/post/trie-shu-zi-dian-shu-dan-ci-cha-zhao-shu/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
            
  
    
      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>
  var gitalk = new Gitalk({
    clientID: '293a9ce2fed12e5929b8',
    clientSecret: 'd7bfd198c2befcba2cf59326be85e9b9d5bcba5f',
    repo: 'songdlut.github.io',
    owner: 'songdlut',
    admin: ['songdlut'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>
    
    
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a
        href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
  
<link rel="stylesheet" href="/media/live2d/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: 10px;bottom: 10px;"
    data-key="">
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    

      <div class="message" style="opacity:0"></div>
      <div class="live_talk_input_body">
        <div class="live_talk_input_name_body">
          <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off"
            placeholder="你的名字" />
        </div>
        <div class="live_talk_input_text_body">
          <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off"
            placeholder="要和我聊什么呀？" />
          <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
        </div>
      </div>
      <input name="live_talk" id="live_talk" value="1" type="hidden" />
      <div class="live_ico_box">
        <div class="live_ico_item type_info" id="showInfoBtn"></div>
        <div class="live_ico_item type_talk" id="showTalkBtn"></div>
        
        <div class="live_ico_item type_youdu" id="youduButton"></div>
        <div class="live_ico_item type_quit" id="hideButton"></div>
        <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
        <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
        <input id="duType" value="douqilai" type="hidden">
        
      </div>
    
  </div>
</div>
<div id="open_live2d">召唤看板娘</div>
<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
  var message_Path = 'https://cdn.jsdelivr.net/gh/hsxyhao/live2d.github.io@master/';
  let landlord = document.querySelector('#landlord');
  var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/js/live2d.js"></script>
<script>
	var home_Path = document.location.protocol + '//' + window.document.location.hostname + ":" + window.document.location.port + '/';
	var userAgent = window.navigator.userAgent.toLowerCase();
	var norunAI = ["android", "iphone", "ipod", "ipad", "windows phone", "mqqbrowser", "msie", "trident/7.0"];
	var norunFlag = false;

	for (var i = 0; i < norunAI.length; i++) {
		if (userAgent.indexOf(norunAI[i]) > -1) {
			norunFlag = true;
			break;
		}
	}

	if (!window.WebGLRenderingContext) {
		norunFlag = true;
	}

	if (!norunFlag) {
		var hitFlag = false;
		var AIFadeFlag = false;
		var liveTlakTimer = null;
		var sleepTimer_ = null;
		var AITalkFlag = false;
		var talkNum = 0;
		(function () {
			function renderTip(template, context) {
				var tokenReg = /(\\)?\{([^\{\}\\]+)(\\)?\}/g;
				return template.replace(tokenReg, function (word, slash1, token, slash2) {
					if (slash1 || slash2) {
						return word.replace('\\', '');
					}
					var variables = token.replace(/\s/g, '').split('.');
					var currentObject = context;
					var i, length, variable;
					for (i = 0, length = variables.length; i < length; ++i) {
						variable = variables[i];
						currentObject = currentObject[variable];
						if (currentObject === undefined || currentObject === null) return '';
					}
					return currentObject;
				});
			}

			String.prototype.renderTip = function (context) {
				return renderTip(this, context);
			};

			var re = /x/;
			re.toString = function () {
				showMessage('哈哈，你打开了控制台，是想要看看我的秘密吗？', 5000);
				return '';
			};

			$(document).on('copy', function () {
				showMessage('你都复制了些什么呀，转载要记得加上出处哦~~', 5000);
			});

			function initTips() {
				$.ajax({
					cache: true,
					url: message_Path + 'message.json',
					dataType: "json",
					success: function (result) {
						$.each(result.mouseover, function (index, tips) {
							$(tips.selector).mouseover(function () {
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
								talkValTimer();
								clearInterval(liveTlakTimer);
								liveTlakTimer = null;
							});
							$(tips.selector).mouseout(function () {
								showHitokoto();
								if (liveTlakTimer == null) {
									liveTlakTimer = window.setInterval(function () {
										showHitokoto();
									}, 15000);
								};
							});
						});
						$.each(result.click, function (index, tips) {
							$(tips.selector).click(function () {
								if (hitFlag) {
									return false
								}
								hitFlag = true;
								setTimeout(function () {
									hitFlag = false;
								}, 8000);
								var text = tips.text;
								if (Array.isArray(tips.text)) text = tips.text[Math.floor(Math.random() * tips.text.length + 1) - 1];
								text = text.renderTip({ text: $(this).text() });
								showMessage(text, 3000);
							});
							clearInterval(liveTlakTimer);
							liveTlakTimer = null;
							if (liveTlakTimer == null) {
								liveTlakTimer = window.setInterval(function () {
									showHitokoto();
								}, 15000);
							};
						});
					}
				});
			}
			initTips();

			var text;
			if (document.referrer !== '') {
				var referrer = document.createElement('a');
				referrer.href = document.referrer;
				text = '嗨！来自 <span style="color:#0099cc;">' + referrer.hostname + '</span> 的朋友！';
				var domain = referrer.hostname.split('.')[1];
				if (domain == 'baidu') {
					text = '嗨！ 来自 百度搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'so') {
					text = '嗨！ 来自 360搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				} else if (domain == 'google') {
					text = '嗨！ 来自 谷歌搜索 的朋友！<br>欢迎访问<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			} else {
				if (window.location.href == home_Path) { //主页URL判断，需要斜杠结尾
					var now = (new Date()).getHours();
					if (now > 23 || now <= 5) {
						text = '你是夜猫子呀？这么晚还不睡觉，明天起的来嘛？';
					} else if (now > 5 && now <= 7) {
						text = '早上好！一日之计在于晨，美好的一天就要开始了！';
					} else if (now > 7 && now <= 11) {
						text = '上午好！工作顺利嘛，不要久坐，多起来走动走动哦！';
					} else if (now > 11 && now <= 14) {
						text = '中午了，工作了一个上午，现在是午餐时间！';
					} else if (now > 14 && now <= 17) {
						text = '午后很容易犯困呢，今天的运动目标完成了吗？';
					} else if (now > 17 && now <= 19) {
						text = '傍晚了！窗外夕阳的景色很美丽呢，最美不过夕阳红~~';
					} else if (now > 19 && now <= 21) {
						text = '晚上好，今天过得怎么样？';
					} else if (now > 21 && now <= 23) {
						text = '已经这么晚了呀，早点休息吧，晚安~~';
					} else {
						text = '嗨~ 快来逗我玩吧！';
					}
				} else {
					text = '欢迎阅读<span style="color:#0099cc;">「 ' + document.title.split(' - ')[0] + ' 」</span>';
				}
			}
			showMessage(text, 12000);
		})();

		liveTlakTimer = setInterval(function () {
			showHitokoto();
		}, 15000);

		function showHitokoto() {
			if (sessionStorage.getItem("Sleepy") !== "1") {
				if (!AITalkFlag) {
					$.getJSON('https://v1.hitokoto.cn/', function (result) {
						talkValTimer();
						showMessage(result.hitokoto, 0);
					});
				}
			} else {
				hideMessage(0);
				if (sleepTimer_ == null) {
					sleepTimer_ = setInterval(function () {
						checkSleep();
					}, 200);
				}
			}
		}

		function checkSleep() {
			var sleepStatu = sessionStorage.getItem("Sleepy");
			if (sleepStatu !== '1') {
				talkValTimer();
				showMessage('你回来啦~', 0);
				clearInterval(sleepTimer_);
				sleepTimer_ = null;
			}
		}

		function showMessage(text, timeout) {
			if (Array.isArray(text)) text = text[Math.floor(Math.random() * text.length + 1) - 1];
			$('.message').stop();
			$('.message').html(text);
			$('.message').fadeTo(200, 1);
			//if (timeout === null) timeout = 5000;
			//hideMessage(timeout);
		}
		function talkValTimer() {
			$('#live_talk').val('1');
		}

		function hideMessage(timeout) {
			//$('.message').stop().css('opacity',1);
			if (timeout === null) timeout = 5000;
			$('.message').delay(timeout).fadeTo(200, 0);
		}

		function initLive2d() {
			$('#hideButton').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "0");
					$('#landlord').fadeOut(200);
					$('#open_live2d').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#open_live2d').on('click', function () {
				if (AIFadeFlag) {
					return false;
				} else {
					AIFadeFlag = true;
					localStorage.setItem("live2dhidden", "1");
					$('#open_live2d').fadeOut(200);
					$('#landlord').delay(200).fadeIn(200);
					setTimeout(function () {
						AIFadeFlag = false;
					}, 300);
				}
			});
			$('#youduButton').on('click', function () {
				if ($('#youduButton').hasClass('doudong')) {
					var typeIs = $('#youduButton').attr('data-type');
					$('#youduButton').removeClass('doudong');
					$('body').removeClass(typeIs);
					$('#youduButton').attr('data-type', '');
				} else {
					var duType = $('#duType').val();
					var duArr = duType.split(",");
					var dataType = duArr[Math.floor(Math.random() * duArr.length)];

					$('#youduButton').addClass('doudong');
					$('#youduButton').attr('data-type', dataType);
					$('body').addClass(dataType);
				}
			});
			if (apiKey) {
				$('#showInfoBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "0") {
						return
					} else {
						$('#live_statu_val').val("0");
						$('.live_talk_input_body').fadeOut(500);
						AITalkFlag = false;
						showHitokoto();
						$('#showTalkBtn').show();
						$('#showInfoBtn').hide();
					}
				});
				$('#showTalkBtn').on('click', function () {
					var live_statu = $('#live_statu_val').val();
					if (live_statu == "1") {
						return
					} else {
						$('#live_statu_val').val("1");
						$('.live_talk_input_body').fadeIn(500);
						AITalkFlag = true;
						$('#showTalkBtn').hide();
						$('#showInfoBtn').show();

					}
				});
				$('#talk_send').on('click', function () {
					var info_ = $('#AIuserText').val();
					var userid_ = $('#AIuserName').val();
					if (info_ == "") {
						showMessage('写点什么吧！', 0);
						return;
					}
					if (userid_ == "") {
						showMessage('聊之前请告诉我你的名字吧！', 0);
						return;
					}
					showMessage('思考中~', 0);
					let protocol = window.location.protocol.indexOf("s") > 0 ? "https" : "http";
					$.ajax({
						type: "get",
						url: `${protocol}://www.tuling123.com/openapi/api?key=${apiKey}&info=${info_}`,
						dataType: "json",
						success: function (res) {
							talkValTimer();
							showMessage(res.text, 0);
							$('#AIuserText').val("");
							sessionStorage.setItem("live2duser", userid_);
						},
						error: function (e) {
							talkValTimer();
							showMessage('似乎有什么错误，请和站长联系！', 0);
						}
					});
				});
			} else {
				$('#showInfoBtn').hide();
				$('#showTalkBtn').hide();
			}
			//获取音乐信息初始化
			var bgmListInfo = $('input[name=live2dBGM]');
			if (bgmListInfo.length == 0) {
				$('#musicButton').hide();
			} else {
				var bgmPlayNow = parseInt($('#live2d_bgm').attr('data-bgm'));
				var bgmPlayTime = 0;
				var live2dBGM_Num = sessionStorage.getItem("live2dBGM_Num");
				var live2dBGM_PlayTime = sessionStorage.getItem("live2dBGM_PlayTime");
				if (live2dBGM_Num) {
					if (live2dBGM_Num <= $('input[name=live2dBGM]').length - 1) {
						bgmPlayNow = parseInt(live2dBGM_Num);
					}
				}
				if (live2dBGM_PlayTime) {
					bgmPlayTime = parseInt(live2dBGM_PlayTime);
				}
				var live2dBGMSrc = bgmListInfo.eq(bgmPlayNow).val();
				$('#live2d_bgm').attr('data-bgm', bgmPlayNow);
				$('#live2d_bgm').attr('src', live2dBGMSrc);
				$('#live2d_bgm')[0].currentTime = bgmPlayTime;
				$('#live2d_bgm')[0].volume = 0.5;
				var live2dBGM_IsPlay = sessionStorage.getItem("live2dBGM_IsPlay");
				var live2dBGM_WindowClose = sessionStorage.getItem("live2dBGM_WindowClose");
				if (live2dBGM_IsPlay == '0' && live2dBGM_WindowClose == '0') {
					$('#live2d_bgm')[0].play();
					$('#musicButton').addClass('play');
				}
				sessionStorage.setItem("live2dBGM_WindowClose", '1');
				$('#musicButton').on('click', function () {
					if ($('#musicButton').hasClass('play')) {
						$('#live2d_bgm')[0].pause();
						$('#musicButton').removeClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '1');
					} else {
						$('#live2d_bgm')[0].play();
						$('#musicButton').addClass('play');
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				});
				window.onbeforeunload = function () {
					sessionStorage.setItem("live2dBGM_WindowClose", '0');
					if ($('#musicButton').hasClass('play')) {
						sessionStorage.setItem("live2dBGM_IsPlay", '0');
					}
				}
				document.getElementById('live2d_bgm').addEventListener("timeupdate", function () {
					var live2dBgmPlayTimeNow = document.getElementById('live2d_bgm').currentTime;
					sessionStorage.setItem("live2dBGM_PlayTime", live2dBgmPlayTimeNow);
				});
				document.getElementById('live2d_bgm').addEventListener("ended", function () {
					var listNow = parseInt($('#live2d_bgm').attr('data-bgm'));
					listNow++;
					if (listNow > $('input[name=live2dBGM]').length - 1) {
						listNow = 0;
					}
					var listNewSrc = $('input[name=live2dBGM]').eq(listNow).val();
					sessionStorage.setItem("live2dBGM_Num", listNow);
					$('#live2d_bgm').attr('src', listNewSrc);
					$('#live2d_bgm')[0].play();
					$('#live2d_bgm').attr('data-bgm', listNow);
				});
				document.getElementById('live2d_bgm').addEventListener("error", function () {
					$('#live2d_bgm')[0].pause();
					$('#musicButton').removeClass('play');
					showMessage('音乐似乎加载不出来了呢！', 0);
				});
			}
			//获取用户名
			var live2dUser = sessionStorage.getItem("live2duser");
			if (live2dUser !== null) {
				$('#AIuserName').val(live2dUser);
			}
			//获取位置
			var landL = sessionStorage.getItem("historywidth");
			var landB = sessionStorage.getItem("historyheight");
			if (landL == null || landB == null) {
				landL = '5px'
				landB = '0px'
			}
			$('#landlord').css('left', landL + 'px');
			$('#landlord').css('bottom', landB + 'px');
			//移动
			function getEvent() {
				return window.event || arguments.callee.caller.arguments[0];
			}
			var smcc = document.getElementById("landlord");
			var moveX = 0;
			var moveY = 0;
			var moveBottom = 0;
			var moveLeft = 0;
			var moveable = false;
			var docMouseMoveEvent = document.onmousemove;
			var docMouseUpEvent = document.onmouseup;
			smcc.onmousedown = function () {
				var ent = getEvent();
				moveable = true;
				moveX = ent.clientX;
				moveY = ent.clientY;
				var obj = smcc;
				moveBottom = parseInt(obj.style.bottom);
				moveLeft = parseInt(obj.style.left);
				if (isFirefox = navigator.userAgent.indexOf("Firefox") > 0) {
					window.getSelection().removeAllRanges();
				}
				document.onmousemove = function () {
					if (moveable) {
						var ent = getEvent();
						var x = moveLeft + ent.clientX - moveX;
						var y = moveBottom + (moveY - ent.clientY);
						obj.style.left = x + "px";
						obj.style.bottom = y + "px";
					}
				};
				document.onmouseup = function () {
					if (moveable) {
						var historywidth = obj.style.left;
						var historyheight = obj.style.bottom;
						historywidth = historywidth.replace('px', '');
						historyheight = historyheight.replace('px', '');
						sessionStorage.setItem("historywidth", historywidth);
						sessionStorage.setItem("historyheight", historyheight);
						document.onmousemove = docMouseMoveEvent;
						document.onmouseup = docMouseUpEvent;
						moveable = false;
						moveX = 0;
						moveY = 0;
						moveBottom = 0;
						moveLeft = 0;
					}
				};
			};
		}
		$(document).ready(function () {
			var AIimgSrc = [];
			let chooseLive2d = 'aoba'
			if (chooseLive2d === 'histoire') {
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_00.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_01.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_02.png");
				AIimgSrc.push(message_Path + "model/histoire/histoire.1024/texture_03.png");
			} else if (chooseLive2d === 'rem') {
				AIimgSrc.push(message_Path + "model/rem/remu2048/texture_00.png");
			} else if (chooseLive2d === 'aoba') {
				AIimgSrc.push(message_Path + "model/aoba/textures/texture_00.png");
			} else if (chooseLive2d === 'hijiki') {
				AIimgSrc.push(message_Path + "model/hijiki/moc/hijiki.2048/texture_00.png");
			} else if (chooseLive2d === 'tororo') {
				AIimgSrc.push(message_Path + "model/tororo/moc/tororo.2048/texture_00.png");
			}
			var images = [];
			var imgLength = AIimgSrc.length;
			var loadingNum = 0;
			for (var i = 0; i < imgLength; i++) {
				images[i] = new Image();
				images[i].src = AIimgSrc[i];
				images[i].onload = function () {
					loadingNum++;
					if (loadingNum === imgLength) {
						var live2dhidden = localStorage.getItem("live2dhidden");
						if (live2dhidden === "0") {
							setTimeout(function () {
								$('#open_live2d').fadeIn(200);
							}, 1300);
						} else {
							setTimeout(function () {
								$('#landlord').fadeIn(200);
							}, 1300);
						}
						let model = '';
						if (chooseLive2d === 'histoire') {
							model = message_Path + "model/histoire/model.json";
						} else if (chooseLive2d === 'rem') {
							model = message_Path + "model/rem/model.json";
						} else if (chooseLive2d === 'aoba') {
							model = message_Path + "model/aoba/model.json";
						} else if (chooseLive2d === 'hijiki') {
							model = message_Path + "model/hijiki/hijiki.model.json";
						} else if (chooseLive2d === 'tororo') {
							model = message_Path + "model/tororo/tororo.model.json";
						}
						setTimeout(function () {
							loadlive2d("live2d", model);
						}, 1000);
						initLive2d();
						images = null;
					}
				}
			}
		});
	}
</script>
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
    back2TopText = document.querySelector('#back_to_top_text'),
    drawerBox = document.querySelector('#drawer_box'),
    rightSideBar = document.querySelector('.sidebar'),
    viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {

    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function (e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });

  window.addEventListener('scroll', function (e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });


  let hasCacu = false;
  window.onresize = function () {
    calcuHeight();
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();

  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function () {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, transitionDir, {});
          }
        })
        window.Velocity(viewport, openProp, {
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function () {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp, {
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target", "_blank");
      }
    })
  }

  let faSearch = document.querySelector('#fa_search');
  faSearch.addEventListener('click', function () {
    document.querySelector('#search_mask').style = ''
  })

  // 代码高亮
  hljs.initHighlightingOnLoad();
  
  // 离开当前页title变化
  var leaveTitle = "";
  if (leaveTitle) {
    document.addEventListener('visibilitychange', function () {
      if (document.visibilityState == 'hidden') {
        normal_title = document.title;
        document.title = leaveTitle;
      } else {
        document.title = normal_title;
      }
    });
  }

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px;border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
    <div class="reward-mask" style="display: none;">
  <div class="reward-relative">
    <span class="close" aria-hidden="true">x</span>
    <div class="reward-body">
      <h2>感谢您的支持，我会继续努力的!</h2>
      <div class="reward-img-box">
        <div style="position: relative; width: 140px; height: 140px;">
          
          
          
        </div>
      </div>
      <p class="reward-word">扫码打赏，你说多少就多少</p>
      <p class="reward-tip">打开微信扫一扫，即可进行扫码打赏哦</p>
    </div>
    <div class="bottom">
      
      
    </div>
  </div>
</div>
<style>
  .reward-mask {
    position: fixed;
    z-index: 99999;
    top: 0;
    bottom: 0;
    left: 0;
    right: 0;
    background-color: #00000054;
  }

  .reward-relative {
    position: relative;
    width: 480px;
    text-align: center;
    margin: 0 auto;
    border-radius: 5px;
    background-color: #fff;
    top: 50%;
    margin-top: -205px;
  }

  .reward-relative .close {
    position: absolute;
    right: 10px;
    font-weight: normal;
    font-size: 16px;
    color: #929292;
  }

  .reward-body {
    padding: 40px 20px 20px;
  }

  .bottom {
    display: flex;
  }

  .reward-btn {
    text-align: center;
  }

  .reward-btn-text {
    display: inline-block;
    cursor: pointer;
    width: 60px;
    height: 60px;
    line-height: 60px;
    border-radius: 50%;
    background-color: #ff9734;
    color: #FFF;
    margin-top: 20px;
  }

  .pay-text {
    margin-top: 10px;
    padding: 10px;
    flex: 1;
    transition: all .2s linear;
  }

  .pay-text:hover {
    background-color: #a5a5a536;
  }

  .reward-body h2 {
    padding-top: 10px;
    text-align: center;
    color: #a3a3a3;
    font-size: 16px;
    font-weight: normal;
    margin: 0 0 20px;
  }

  .reward-body h2:after,
  .reward-body h2:before {
    font-family: Arial, Helvetica, sans-serif;
    background: 0 0;
    width: 0;
    height: 0;
    font-style: normal;
    color: #eee;
    font-size: 80px;
    position: absolute;
    top: 20px;
  }

  .reward-body h2:before {
    content: '\201c';
    left: 50px;
  }

  .reward-body h2:after {
    content: '\201d';
    right: 80px;
  }

  .reward-img-box {
    display: inline-block;
    padding: 10px;
    border: 6px solid #ea5f00;
    margin: 0 auto;
    border-radius: 3px;
    position: relative;
  }

  .reward-img {
    position: absolute;
    left: 0px;
    top: 0px;
    width: 100%;
    height: 100%;
  }

  @media (max-width: 767px) {
    .reward-relative {
      height: 100%;
      top: 0px;
      margin-top: 0;
      width: auto;
    }

    .reward-relative .bottom {
      flex-direction: column;
    }

    .reward-relative .pay-text {
      width: 80%;
      margin: 5px auto;
      border: 1px solid silver;
      padding: 6px;
      border-radius: 4px;
    }

    .reward-body h2:after {
      right: 40px;
    }

    .reward-body h2:after,
    .reward-body h2:before {
      font-size: 60px;
    }

    .reward-body h2:before {
      left: 20px;
    }
  }
</style>
<script>
  !function () {
    var mask = document.querySelector('.reward-mask');
    let close = document.querySelector('.reward-relative .close');
    let rewardBtn = document.querySelector('.reward-btn');

    let zfb = document.querySelector('#zfb'),
      wx = document.querySelector('#wx'),
      zfbBtn = document.querySelector('#zfbBtn'),
      wxBtn = document.querySelector('#wxBtn');

    if (zfbBtn && wxBtn) {
      zfbBtn.addEventListener('click', () => {
        window.Velocity(zfb, 'transition.slideLeftIn', {
          duration: 400
        });
        window.Velocity(wx, 'transition.slideRightOut', {
          display: 'none',
          duration: 400
        });
      });

      wxBtn.addEventListener('click', () => {
        window.Velocity(wx, 'transition.slideRightIn', {
          duration: 400
        });
        window.Velocity(zfb, 'transition.slideLeftOut', {
          display: 'none',
          duration: 400
        });
      });
    }

    rewardBtn.addEventListener('click', (e) => {
      window.Velocity(mask, 'transition.slideDownIn', {
        duration: 400
      })
    });

    close.addEventListener('click', (e) => {
      e.preventDefault();
      window.Velocity(mask, 'transition.slideUpOut', {
        duration: 400
      })
    })
  }()
</script>

  </div>
</body>

  <div class="search-mask" id="search_mask" style="display: none;">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input id="search" type="text" class="language" data-lan="search" placeholder="搜索">
      </div>
      <i id="close" class="fa fa-times-circle"></i>
    </div>
    <div class="stat-box">
      <span id="stat_count">0</span><span class="language" data-lan="stat">条相关条目，使用了</span><span id="stat_times">0</span><span class="language" data-lan="stat-time">毫秒</span>
      <hr>
    </div>
    <div class="result" id="result">
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/lun-wen-da-gang/"" data-c="
          &lt;h1 id=&#34;中文摘要&#34;&gt;中文摘要&lt;/h1&gt;
&lt;h1 id=&#34;英文摘要&#34;&gt;英文摘要&lt;/h1&gt;
&lt;h1 id=&#34;第一章-引言&#34;&gt;第一章 引言&lt;/h1&gt;
&lt;h2 id=&#34;11-项目背景&#34;&gt;1.1 项目背景&lt;/h2&gt;
&lt;h2 id=&#34;12-国内外实物取材于自定义纹理画图技术研究现状&#34;&gt;1.2 国内外实物取材于自定义纹理画图技术研究现状&lt;/h2&gt;
&lt;h2 id=&#34;13-论文主要工作和组织结构&#34;&gt;1.3 论文主要工作和组织结构&lt;/h2&gt;
&lt;h1 id=&#34;第二章项目开发技术概述&#34;&gt;第二章项目开发技术概述&lt;/h1&gt;
&lt;h2 id=&#34;21-面向过程与对象cc&#34;&gt;2.1 面向过程与对象（C/C++）&lt;/h2&gt;
&lt;h2 id=&#34;22-qt技术&#34;&gt;2.2 QT技术&lt;/h2&gt;
&lt;h2 id=&#34;23-图像处理&#34;&gt;2.3 图像处理&lt;/h2&gt;
&lt;h3 id=&#34;231-图像旋转技术&#34;&gt;2.3.1 图像旋转技术&lt;/h3&gt;
&lt;h3 id=&#34;232-jpeg图像处理&#34;&gt;2.3.2 JPEG图像处理&lt;/h3&gt;
&lt;h2 id=&#34;24-涉及的硬件部分&#34;&gt;2.4 涉及的硬件部分&lt;/h2&gt;
&lt;h3 id=&#34;2-41-主控stm32f4单片机&#34;&gt;2. 4.1 主控STM32F4单片机&lt;/h3&gt;
&lt;h3 id=&#34;242-ov2640-摄像头模块&#34;&gt;2.4.2 ov2640 摄像头模块&lt;/h3&gt;
&lt;h3 id=&#34;243-蓝牙模块按键模块&#34;&gt;2.4.3 蓝牙模块，按键模块&lt;/h3&gt;
&lt;h1 id=&#34;第三章-需求分析与概要设计&#34;&gt;第三章 需求分析与概要设计&lt;/h1&gt;
&lt;h2 id=&#34;31-项目整体概述&#34;&gt;3.1 项目整体概述&lt;/h2&gt;
&lt;h2 id=&#34;32-项目需求分析&#34;&gt;3.2 项目需求分析&lt;/h2&gt;
&lt;h3 id=&#34;321-用例图及用例描述&#34;&gt;3.2.1 用例图及用例描述&lt;/h3&gt;
&lt;h3 id=&#34;322-系统顺序图&#34;&gt;3.2.2 系统顺序图&lt;/h3&gt;
&lt;h3 id=&#34;323-非功能性需求描述&#34;&gt;3.2.3 非功能性需求描述&lt;/h3&gt;
&lt;h2 id=&#34;33-项目的系统概要设计&#34;&gt;3.3 项目的系统概要设计&lt;/h2&gt;
&lt;h3 id=&#34;331-体系结构逻辑视图&#34;&gt;3.3.1 体系结构逻辑视图&lt;/h3&gt;
&lt;h3 id=&#34;332-系统模块设计概述&#34;&gt;3.3.2 系统模块设计概述&lt;/h3&gt;
&lt;h3 id=&#34;332-系统概念类图&#34;&gt;3.3.2 系统概念类图&lt;/h3&gt;
&lt;h3 id=&#34;333-iobrush画笔硬件连接图&#34;&gt;3.3.3 IOBrush画笔硬件连接图&lt;/h3&gt;
&lt;h1 id=&#34;第四章-实物取材画笔io-brush项目的详细设计与实现&#34;&gt;第四章 实物取材画笔I/O Brush项目的详细设计与实现&lt;/h1&gt;
&lt;h2 id=&#34;41-项目主要模块概述&#34;&gt;4.1 项目主要模块概述&lt;/h2&gt;
&lt;h3 id=&#34;411-画笔硬件模块42-45&#34;&gt;4.1.1 画笔硬件模块（4.2-4.5）&lt;/h3&gt;
&lt;h3 id=&#34;412-绘画软件模块46-410&#34;&gt;4.1.2 绘画软件模块（4.6-4.10）&lt;/h3&gt;
&lt;h2 id=&#34;42-图像采集模块设计&#34;&gt;4.2 图像采集模块设计&lt;/h2&gt;
&lt;h3 id=&#34;421-模块概述&#34;&gt;4.2.1 模块概述&lt;/h3&gt;
&lt;h3 id=&#34;422-电路连接与配置&#34;&gt;4.2.2 电路连接与配置&lt;/h3&gt;
&lt;p&gt;（硬件模块的连接端口与初始化配置）&lt;/p&gt;
&lt;h3 id=&#34;423-接口规范&#34;&gt;4.2.3 接口规范&lt;/h3&gt;
&lt;p&gt;C语言实现，面向过程的设计方法&lt;/p&gt;
&lt;h2 id=&#34;43-按键与逻辑控制模块设计&#34;&gt;4.3 按键与逻辑控制模块设计&lt;/h2&gt;
&lt;h3 id=&#34;431-模块概述&#34;&gt;4.3.1 模块概述&lt;/h3&gt;
&lt;h3 id=&#34;432-电路连接与配置&#34;&gt;4.3.2 电路连接与配置&lt;/h3&gt;
&lt;h3 id=&#34;433-接口规范&#34;&gt;4.3.3 接口规范&lt;/h3&gt;
&lt;h2 id=&#34;44-图像传输模块设计&#34;&gt;4.4 图像传输模块设计&lt;/h2&gt;
&lt;h3 id=&#34;441-模块概述&#34;&gt;4.4.1 模块概述&lt;/h3&gt;
&lt;h3 id=&#34;442-电路连接与配置&#34;&gt;4.4.2 电路连接与配置&lt;/h3&gt;
&lt;h3 id=&#34;443-接口规范&#34;&gt;4.4.3 接口规范&lt;/h3&gt;
&lt;h2 id=&#34;45-图像接收与处理模块&#34;&gt;4.5 图像接收与处理模块&lt;/h2&gt;
&lt;h3 id=&#34;461模块概述&#34;&gt;4.6.1模块概述&lt;/h3&gt;
&lt;p&gt;python实现&lt;/p&gt;
&lt;h3 id=&#34;462模块类图&#34;&gt;4.6.2模块类图&lt;/h3&gt;
&lt;h3 id=&#34;463接口规范&#34;&gt;4.6.3接口规范&lt;/h3&gt;
&lt;h2 id=&#34;46-paletteui模块详细设计&#34;&gt;4.6 paletteUI模块详细设计&lt;/h2&gt;
&lt;h3 id=&#34;461模块概述-2&#34;&gt;4.6.1模块概述&lt;/h3&gt;
&lt;h3 id=&#34;462模块类图-2&#34;&gt;4.6.2模块类图&lt;/h3&gt;
&lt;h3 id=&#34;463接口规范-2&#34;&gt;4.6.3接口规范&lt;/h3&gt;
&lt;h2 id=&#34;47-painter模块详细设计&#34;&gt;4.7 painter模块详细设计&lt;/h2&gt;
&lt;h3 id=&#34;471模块概述&#34;&gt;4.7.1模块概述&lt;/h3&gt;
&lt;h3 id=&#34;472模块类图&#34;&gt;4.7.2模块类图&lt;/h3&gt;
&lt;h3 id=&#34;473接口规范&#34;&gt;4.7.3接口规范&lt;/h3&gt;
&lt;h2 id=&#34;48-palettecontroller模块详细设计&#34;&gt;4.8 paletteController模块详细设计&lt;/h2&gt;
&lt;h3 id=&#34;481模块概述&#34;&gt;4.8.1模块概述&lt;/h3&gt;
&lt;h3 id=&#34;482模块类图&#34;&gt;4.8.2模块类图&lt;/h3&gt;
&lt;h3 id=&#34;483接口规范&#34;&gt;4.8.3接口规范&lt;/h3&gt;
&lt;h2 id=&#34;49-imgsaver模块详细设计&#34;&gt;4.9 imgSaver模块详细设计&lt;/h2&gt;
&lt;h3 id=&#34;491模块概述&#34;&gt;4.9.1模块概述&lt;/h3&gt;
&lt;h3 id=&#34;492模块类图&#34;&gt;4.9.2模块类图&lt;/h3&gt;
&lt;h3 id=&#34;493接口规范&#34;&gt;4.9.3接口规范&lt;/h3&gt;
&lt;h2 id=&#34;410-io-brush项目模块的实现&#34;&gt;4.10 I/O Brush项目模块的实现&lt;/h2&gt;
&lt;h3 id=&#34;4101-painter模块的实现&#34;&gt;4.10.1 painter模块的实现&lt;/h3&gt;
&lt;h3 id=&#34;4102-palettecontroller模块的实现&#34;&gt;4.10.2 paletteController模块的实现&lt;/h3&gt;
&lt;h3 id=&#34;4103-paletteui模块的实现&#34;&gt;4.10.3 paletteUI模块的实现&lt;/h3&gt;
&lt;h2 id=&#34;411-项目运行效果截图&#34;&gt;4.11 项目运行效果截图&lt;/h2&gt;
&lt;h2 id=&#34;412-本章小结&#34;&gt;4.12 本章小结&lt;/h2&gt;
&lt;h1 id=&#34;第五章-测试与部署&#34;&gt;第五章 测试与部署&lt;/h1&gt;
&lt;h2 id=&#34;51-单元测试&#34;&gt;5.1 单元测试&lt;/h2&gt;
&lt;h3 id=&#34;511-图像采集功能测试&#34;&gt;5.1.1 图像采集功能测试&lt;/h3&gt;
&lt;h3 id=&#34;512-按键与逻辑控制测试&#34;&gt;5.1.2 按键与逻辑控制测试&lt;/h3&gt;
&lt;h3 id=&#34;513-图像传输测试&#34;&gt;5.1.3 图像传输测试&lt;/h3&gt;
&lt;h3 id=&#34;514-图像接收测试&#34;&gt;5.1.4 图像接收测试&lt;/h3&gt;
&lt;h3 id=&#34;515-视频接收测试&#34;&gt;5.1.5 视频接收测试&lt;/h3&gt;
&lt;h3 id=&#34;516-painter模块测试&#34;&gt;5.1.6 painter模块测试&lt;/h3&gt;
&lt;h3 id=&#34;517-palette模块测试&#34;&gt;5.1.7 palette模块测试&lt;/h3&gt;
&lt;h3 id=&#34;518-imgsaver模块测试&#34;&gt;5.1.8 imgSaver模块测试&lt;/h3&gt;
&lt;h2 id=&#34;52-集成测试&#34;&gt;5.2 集成测试&lt;/h2&gt;
&lt;h2 id=&#34;53-打包与部署&#34;&gt;5.3 打包与部署&lt;/h2&gt;
&lt;p&gt;python实现的部分打包成windows可执行程序，与QT部分合并部署&lt;/p&gt;
">论文大纲</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/ying-jian-mo-kuai/"" data-c="
          &lt;ol&gt;
&lt;li&gt;STM32F103C4T6&lt;br&gt;
&lt;img src=&#34;https://songdlut.github.io/post-images/1670587108161.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;摄像头模组ov7670模块&lt;br&gt;
&lt;img src=&#34;https://songdlut.github.io/post-images/1670587338973.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;DC电源模块&lt;br&gt;
&lt;img src=&#34;https://songdlut.github.io/post-images/1670587349667.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;E10白炽灯模块&lt;br&gt;
&lt;img src=&#34;https://songdlut.github.io/post-images/1670587355051.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;HC-05蓝牙模块&lt;br&gt;
&lt;img src=&#34;https://songdlut.github.io/post-images/1670587364100.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;带帽按键模块&lt;br&gt;
&lt;img src=&#34;https://songdlut.github.io/post-images/1670587370344.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
">硬件模块</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/guan-lian-rong-qi-die-dai-qi/"" data-c="
          &lt;p&gt;1&lt;/p&gt;
">关联容器迭代器</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/xu-han-shu-chun-xu-han-shu/"" data-c="
          &lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;
&lt;p&gt;non-virtual function：不建议重写&lt;br&gt;
virtual function：建议重写&lt;br&gt;
pure-virtual function：子类一定要重写&lt;/p&gt;
&lt;h2 id=&#34;注意点&#34;&gt;注意点&lt;/h2&gt;
&lt;p&gt;基类中的虚函数不能只要声明没有定义，哪怕加个{}空函数体都行，不然编译不能通过，或者定义成纯虚函数（=0）&lt;br&gt;
会报错：undefined reference to `vtable for&lt;/p&gt;
">虚函数，纯虚函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/lei-mo-ban-han-shu-mo-ban/"" data-c="
          &lt;h2 id=&#34;1&#34;&gt;1&lt;/h2&gt;
">类模板，函数模板</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/guan-yu-new-he-delete/"" data-c="
          &lt;h2 id=&#34;1-new的过程&#34;&gt;1 new的过程&lt;/h2&gt;
&lt;p&gt;先分配memory，再调用ctor（构造函数）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Complex* pc = new Complex(1, 2);
//编译器转化为：

Complex *pc;
void* mem = operator new( sizeof (Complex) );//operator new内部调用malloc
pc = static_cast&amp;lt;Complex*&amp;gt;(mem);
pc-&amp;gt;Comlex::Complex(1, 2);
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;a href=&#34;https://imgtu.com/i/qfEkG9&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2022/03/31/qfEkG9.png&#34; alt=&#34;qfEkG9.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h2 id=&#34;2-delete过程&#34;&gt;2 delete过程&lt;/h2&gt;
&lt;p&gt;先调用析构，再释放内存&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Complex* pc =  new Complex(1, 2);
...
delete pc;

//编译器转化为：
Complex::~Complex(pc); //析构函数
operator delete(pc); //释放内存，内部是调用free(pc)
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;a href=&#34;https://imgtu.com/i/qfEer6&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2022/03/31/qfEer6.png&#34; alt=&#34;qfEer6.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-new和deletenew数组和delete-p&#34;&gt;3 new和delete，new数组和delete [] p&lt;/h2&gt;
&lt;p&gt;new数组要搭配delete [] p使用，因为一个delete调用一次析构，如果不用[]会导致另外几个对象的成员变量没有释放，造成内存泄露;虽然complex可以不用，但是还是得养成好习惯&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;String* p = new String[3];
....
delete p;//只调用了一次析构，另外两个的char* 成员就没有释放掉，造成内存泄露
//应该是
delete [] p;
&lt;/code&gt;&lt;/pre&gt;
">关于new和delete</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/qian-kao-bei-he-shen-kao-bei/"" data-c="
          &lt;p&gt;成员变量有指针的，编译器自带的拷贝构造或赋值，是浅拷贝，会使俩对象指向同一个地方，&lt;/p&gt;
">浅拷贝和深拷贝</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/cao-zuo-fu-chong-zai/"" data-c="
          &lt;p&gt;11&lt;/p&gt;
">操作符重载*</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/guan-yu-fan-hui-zhi-neng-bu-neng-yong-yin-yong/"" data-c="
          &lt;p&gt;不能用的情况：在函数内创建的对象，然后将它用引用返回是不行的，因为函数执行完后，这个对象会被销毁，它的引用就没有意义可。&lt;/p&gt;
">关于返回值能不能用引用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/guan-yu-gou-zao-han-shu/"" data-c="
          &lt;h2 id=&#34;构造函数参数问题&#34;&gt;构造函数参数问题&lt;/h2&gt;
&lt;p&gt;如下情况是不允许的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class complex {
    public:
        complex (double r = 0, double i = 0) : re(r), im (i) { }
        complex () : re(r), im (i) { }
    private:
        double re, img;
};
{
    complex c1;
    complex c2 ();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为第一个构造函数已经指定了默认的值，所以调用构造函数没有给参数时，编译器不知道应该调用第一个还是第二个。&lt;/p&gt;
&lt;p&gt;扩充一下：&lt;br&gt;
假如有n个成员变量，一个构造函数有个n个参数，有一个设了默认值（=x），还有一个有n-1个参数（无论有没有给初值），现在定义一个类对象，参数给了n-1个，那么是无法通过的，因为不知道该调用第一个还是第二个构造函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class A {
    public:
        A (int a1, int a2, int a3, ..... , int an-2, int an-1, int an = 0) : ........ { }
        A (int a1, int a2, int a3, ..... , int an-2, int an-1) : ........ { }
    private:
        int a1,a2,a3.......,an;
}
int main()
{
    A a(a1,a2,a3.......,an-1);//不行
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;构造函数位置问题&#34;&gt;构造函数位置问题&lt;/h2&gt;
&lt;p&gt;一般都放在public里，但是也有放在private里，比如&lt;strong&gt;单例模式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class A {
    public:
        static A&amp;amp; getInstance ()；
        setup () { ...}
    private:
        A ();
        A (const A&amp;amp; rhs);
        ...
};
A&amp;amp; A::getInstance()
{
    static A a;
    return a;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;拷贝构造函数的参数为什么不能是值传递必须是引用传递&#34;&gt;拷贝构造函数的参数为什么不能是值传递，必须是引用传递&lt;/h2&gt;
&lt;p&gt;如果把拷贝构造函数的参数设置为值传递，那么参数肯定就是本类的一个object，采用值传递，在形参和实参相结合的时候，是要调用本类的拷贝构造函数,那么就陷入死循环了，一直调&lt;/p&gt;
&lt;h2 id=&#34;必须在初始化列表初始化的情况&#34;&gt;必须在初始化列表初始化的情况&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;需要初始化的数据成员是对象的情况(这里包含了继承情况下，通过显示调用父类的构造函数对父类数据成员进行初始化)；&lt;/li&gt;
&lt;li&gt;需要初始化const修饰的类成员或初始化引用成员数据；&lt;/li&gt;
&lt;li&gt;子类初始化父类的私有成员；&lt;/li&gt;
&lt;/ol&gt;
">关于构造函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/inline-nei-lian-han-shu/"" data-c="
          &lt;ol&gt;
&lt;li&gt;函数若在class body里定义完成，则自动成为inline候选人&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
">inline内联函数</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/zai-han-shu-ti-zhi-qian-jia-const-guan-jian-zi-de-zuo-yong-shi-shi-me/"" data-c="
          &lt;h2 id=&#34;1-作用&#34;&gt;1 作用&lt;/h2&gt;
&lt;p&gt;限定函数的功能，不允许函数改变成员变量的值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
 
using namespace std;
class MyClass{
public:
    void setVal(int val) const
    {
        this-&amp;gt;val = val;
    }
private:
    int val;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样写，在编译的时候就会提示错误：&lt;br&gt;
error: cannot assign to non-static data member within const member function &#39;setVal&#39;&lt;/p&gt;
&lt;h2 id=&#34;2-用法&#34;&gt;2 用法&lt;/h2&gt;
&lt;p&gt;如果作为单独的函数，const限定符不能够这样使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
 
using namespace std;
 
int getRef() const
{
    return 1;
}
 
int main(int argc, char **argv)
{
    cout &amp;lt;&amp;lt; getRef() &amp;lt;&amp;lt; endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;testconst.cpp:5:14: error: non-member function cannot have &#39;const&#39; qualifier&lt;br&gt;
int getRef() const&lt;br&gt;
^~~~~&lt;br&gt;
1 error generated&lt;/p&gt;
&lt;p&gt;** 非成员函数不能使用const限定符。需要在类里面使用。**&lt;/p&gt;
&lt;h2 id=&#34;如果没有加const&#34;&gt;如果没有加const&lt;/h2&gt;
&lt;p&gt;如果函数体前没加const，且在定义对象的时候前面加了const，对象在调用这个函数的时候会报错&lt;/p&gt;
">在函数体{ }之前加const关键字的作用是什么</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/lambda-biao-da-shi/"" data-c="
          &lt;p&gt;1&lt;/p&gt;
">lambda表达式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/typedef-yong-fa/"" data-c="
          &lt;h2 id=&#34;1-定义机器无关的类型&#34;&gt;1 定义机器无关的类型&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;typedef long double REAL;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在不支持long double的机器上运行相关代码，只要修改对应的typedef&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;typedef double REAL;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-使用typedef为现有类型创建别名&#34;&gt;2 使用typedef为现有类型创建别名&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;typedef unsigned int UINT;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-简化一些比较复杂的类型声明回调函数比较多&#34;&gt;3 简化一些比较复杂的类型声明（回调函数比较多）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;typedef void (*PFunCallBack)(char* pMsg, unsigned int nMsgLen);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述声明引入了 PFunCallBack 类型作为函数指针的同义字，PFunCallBack 类型定义的指针会指向1个函数，该函数包含两个类型分别为 char* 和 unsigned int 的参数，以及一个类型为 void 的返回值。通常，当函数的参数是一个回调函数时，就可能会使用 typedef 来简化声明。&lt;br&gt;
就可以像下面这样使用：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;RedisSubCommand(const string&amp;amp; strKey, PFunCallBack pcb, bool bOnlyOne);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果不使用typedef声明，则该函数声明如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;RedisSubCommand(const string&amp;amp; strKey, void (*pFunCallback)(char* pMsg, unsigned int nMsgLen), bool bOnlyOne); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非常复杂&lt;/p&gt;
&lt;h2 id=&#34;4-与define的一些区别&#34;&gt;4 与define的一些区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;#define 进行简单的进行字符串替换。 #define 宏定义可以使用 #ifdef、#ifndef 等来进行逻辑判断，还可以使用 #undef 来取消定义。&lt;/li&gt;
&lt;li&gt;typedef 是为一个类型起新名字。typedef 符合（C语言）范围规则，使用 typedef 定义的变量类型，其作用范围限制在所定义的函数或者文件内（取决于此变量定义的位置），而宏定义则没有这种特性。&lt;br&gt;
通常，使用 typedef 要比使用 #define 要好，特别是在有指针的场合里&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;typedef　char*　pStr1;
#define　pStr2　char*　
pStr1　s1, s2; //s1,s2均为指针，相当于char *s1,*s2;
pStr2　s3, s4;//s3是指针，s4是char类型，因为define只是简单的做字符串替换,等于char *s3,s4;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;typedef char *pStr;
char string[5]=&amp;quot;test&amp;quot;;
const char *p1=string;
const pStr p2=string;//不等于直接替换为const char* pStr p2 = string;而是char* const p2 = string;
p1++;
p2++;//会报错
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;p2++报错是因为这里p2是一个顶层const了，本身是一个常量&lt;br&gt;
也就是说，const pStr p2 和 pStr const p2 本质上没有区别（可类比 const int p2 和 int const p2），都是对变量 p2 进行只读限制，只不过此处变量 p2 的数据类型是我们自己定义的 pStr，而不是系统固有类型（如 int）而已。&lt;/p&gt;
">typedef用法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/linux-yong-hu-bian-liang-xiang-guan/"" data-c="
          &lt;h2 id=&#34;查看path&#34;&gt;查看PATH&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo $PATH #显示PATH设置
env  #显示当前用户变量
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;1-直接export&#34;&gt;1 直接export&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export PATH=/......./bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生效方法：立即生效&lt;br&gt;
有效期限：临时改变，只能在当前终端有效，关了重开就没了&lt;br&gt;
用户局限：仅对当前用户&lt;/p&gt;
&lt;h2 id=&#34;bashrc文件&#34;&gt;.bashrc文件&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;vim ~/.bashrc
#文件后面添加：
export PATH=/......./bin:$PATH
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;生效方法：（有以下两种）&lt;br&gt;
1、关闭当前终端窗口，重新打开一个新终端窗口就能生效&lt;br&gt;
2、输入“source ~/.bashrc”命令，立即生效&lt;br&gt;
有效期限：永久有效&lt;br&gt;
用户局限：仅对当前用户&lt;/p&gt;
&lt;h2 id=&#34;通过修改profile文件&#34;&gt;通过修改profile文件:&lt;/h2&gt;
&lt;p&gt;vim /etc/profile&lt;br&gt;
/export PATH //找到设置PATH的行，添加&lt;br&gt;
export PATH=/usr/local/mongodb/bin:$PATH&lt;br&gt;
生效方法：系统重启&lt;br&gt;
有效期限：永久有效&lt;br&gt;
用户局限：对所有用户&lt;/p&gt;
&lt;h2 id=&#34;过修改environment文件&#34;&gt;过修改environment文件:&lt;/h2&gt;
&lt;p&gt;vim /etc/environment&lt;br&gt;
在PATH=&amp;quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games&amp;quot;中加入“:/usr/local/mongodb/bin”&lt;br&gt;
生效方法：系统重启&lt;br&gt;
有效期限：永久有效&lt;br&gt;
用户局限：对所有用户&lt;/p&gt;
">Linux用户变量相关</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/trie-shu-zi-dian-shu-dan-ci-cha-zhao-shu/"" data-c="
          &lt;p&gt;111&lt;/p&gt;
">Trie树（字典树，单词查找树）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/makefile-zhong/"" data-c="
          &lt;p&gt;= 是最基本的赋值&lt;br&gt;
:= 是覆盖之前的值&lt;br&gt;
?= 是如果没有被赋值过就赋予等号后面的值&lt;br&gt;
+= 是添加等号后面的值&lt;/p&gt;
&lt;h2 id=&#34;和-的区别&#34;&gt;=和 := 的区别&lt;/h2&gt;
&lt;h3 id=&#34;&#34;&gt;=&lt;/h3&gt;
&lt;p&gt;make会将整个makefile展开后，再决定变量的值。也就是说，变量的值将会是整个makefile中最后被指定的值。看例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;x = foo
y = $(x) bar
x = xyz

在上例中，y的值将会是 xyz bar ，而不是 foo bar 。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;-2&#34;&gt;:=&lt;/h3&gt;
&lt;p&gt;“:=”表示变量的值决定于它在makefile中的位置，而不是整个makefile展开后的最终值。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;x := foo
y := $(x) bar
x := xyz

在上例中，y的值将会是 foo bar ，而不是 xyz bar 了。
&lt;/code&gt;&lt;/pre&gt;
">makefile中=，:=,?=,+=</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/htonsshi-yong/"" data-c="
          &lt;h1 id=&#34;大小端&#34;&gt;大小端&lt;/h1&gt;
&lt;p&gt;int num = 16777220;&lt;br&gt;
这个数用十六进制表示就是 0x12345678&lt;br&gt;
从左往右数， 0x12 是高位字节，0x78 是低位字节。&lt;br&gt;
在小端序机子上依次是 0x78、0x56、0x34、0x12 存储，数据高位（高字节）存储在内存高地址，低位（低字节）对应低地址；&lt;br&gt;
大端序就是反过来 0x12、0x34、0x56、0x78，数据高位存储在内存低地址，低位对应高地址。&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;a href=&#34;https://imgtu.com/i/bhfCa8&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2022/03/10/bhfCa8.png&#34; alt=&#34;bhfCa8.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h1 id=&#34;为啥转换&#34;&gt;为啥转换&lt;/h1&gt;
&lt;p&gt;TCP/IP协议是按照大端传输方式，如果有必要就转&lt;/p&gt;
&lt;h1 id=&#34;四个转换函数&#34;&gt;四个转换函数&lt;/h1&gt;
&lt;p&gt;C/C++中有如下四个常用的转换函数，这四个函数在小端系统中生效，大端系统由于和网络字节序相同，所以无需转换。&lt;/p&gt;
&lt;p&gt;htons —— 把unsigned short类型从主机序转成网络字节序&lt;br&gt;
ntohs —— 把unsigned short类型从网络字节序转成主机序&lt;br&gt;
htonl —— 把unsigned long类型从主机序转成网络字节序&lt;br&gt;
ntohl —— 把unsigned long类型从网络字节序转成主机序&lt;br&gt;
以上函数包含头文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#if defined(_LINUX) || defined(_DARWIN)
#include &amp;lt;netinet/in.h&amp;gt;
//看到的另外的博客是
#include &amp;lt;arpa/inet.h&amp;gt;
#endif

#ifdef WIN32
#include &amp;lt;WINSOCK2.H&amp;gt;
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;具体如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;htonl()函数
函数原型是：uint32_t htonl(uint32_t hostlong)
其中,hostlong是主机字节顺序表达的32位数，htonl中的h–host主机地址，to–to,n–net网络，l–unsigned long无符号的长整型(32位的系统是4字节)；
函数返回值是一个32位的网络字节顺序；
函数的作用是将一个32位数从主机字节顺序转换成网络字节顺序。

htons()函数
函数原型是：uint16_t htons(uint16_t hostlong)
其中,hostlong是主机字节顺序表达的16位数，htons中的h–host主机地址，to–to,n–net网络，s–signed long无符号的短整型(32位的系统是2字节)；
函数返回值是一个16位的网络字节顺序；
函数的作用是将一个16位数从主机字节顺序转换成网络字节顺序，简单的说就是把一个16位数高低位呼唤。

ntohs()函数
函数原型是：uint16_t ntohs(uint16_t hostlong)
其中,hostlong是网络字节顺序表达的16位数，ntohs中的,n–net网络，to–toh–host主机地址，s–signed long有符号的短整型(32位的系统是2字节)；
函数返回值是一个16位的主机字节顺序；
函数的作用是将一个16位数由网络字节顺序转换为主机字节顺序，简单的说就是把一个16位数高低位互换。

ntohl()函数
函数原型是：uint32_t ntohs(uint32_t hostlong)
其中,hostlong是网络字节顺序表达的32位数，ntohs中的,n–net网络，to–toh–host主机地址，s–unsigned long无符号的短整型(32位的系统是4字节)；
函数返回值是一个32位的主机字节顺序；
函数的作用是将一个32位数由网络字节顺序转换为主机字节顺序。
&lt;/code&gt;&lt;/pre&gt;
">htons()使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/af_inet-he-pf_inet-de-dian-dian-bu-tong/"" data-c="
          &lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;sockfd = socket(PF_INET, SOCK_STREAM, 0);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在绑定本地地址或连接远程地址时需要初始化sockaddr_in结构，其中指定address family时一般设置为AF_INET，即使用IP。&lt;/p&gt;
&lt;p&gt;相关头文件中的定义：&lt;br&gt;
AF = Address Family//地址族&lt;br&gt;
PF = Protocol Family//协议族&lt;br&gt;
AF_INET = PF_INET&lt;/p&gt;
&lt;p&gt;所以在windows中AF_INET与PF_INET完全一样. 而在Unix/Linux系统中，在不同的版本中这两者有微小差别.对于BSD,是AF,对于POSIX是PF.&lt;/p&gt;
&lt;p&gt;理论上建立socket时是指定协议，应该用PF_xxxx，设置地址时应该用AF_xxxx。当然AF_INET和PF_INET的值是相同的，混用也不会有太大的问题。&lt;/p&gt;
">AF_INET和PF_INET的点点不同</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/webserver-xiang-mu-bi-ji/"" data-c="
          &lt;ol&gt;
&lt;li&gt;三次握手在connect里发生&lt;/li&gt;
&lt;li&gt;鲸群效应：主线程将任务添加到任务队列时，所有等待的子线程都会被唤醒，但是只有一个能获取，其余的子线程再次进入睡眠。&lt;/li&gt;
&lt;li&gt;Reactor .vs Proactor
&lt;ol&gt;
&lt;li&gt;Reactor是主线程只管将任务放到任务队列，子线程拿到后自己去读&lt;/li&gt;
&lt;li&gt;Proactor是将就绪时间里的IO用主线程先读出来&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;服务器类型，IO密集型和CPU密集型两种，IO密集型线程池线程个数可以设成核心数的两倍。&lt;/li&gt;
&lt;li&gt;高性能线程池，动态扩容，（搜美团线程池看文章）&lt;/li&gt;
&lt;li&gt;问QueryPerSecond（每秒请求）:答2000ps，从软硬件两个角度答
&lt;ol&gt;
&lt;li&gt;硬件，租的服务器，核心少，内存小，计算频率不太行&lt;/li&gt;
&lt;li&gt;软件，我线程池个数是8，不支持动态扩容，动态扩容和前面的就沾上了,互斥锁（读写锁，自旋锁，CAS(无所编程),定时器（升序双链表，时间轮））&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;EdgeT和LevelT
&lt;ol&gt;
&lt;li&gt;都是socket的属性&lt;/li&gt;
&lt;li&gt;当就绪事件到来时，如果是ET模式，需要立刻处理，socket的缓冲区得一次性读完&lt;/li&gt;
&lt;li&gt;LT不用立刻处理，可以等到调度时再处理，缓冲区也不用一次读完&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
">Webserver项目笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/mian-xiang-dui-xiang-xiang-jie/"" data-c="
          &lt;h1 id=&#34;&#34;&gt;&lt;/h1&gt;
">面向对象详解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/define-shi-yong-xiang-jie-tiao-jian-bian-yi-deng/"" data-c="
          &lt;h2 id=&#34;1-无参宏&#34;&gt;1 无参宏&lt;/h2&gt;
&lt;p&gt;无参宏即宏名之后不带参数，只是简单的文本替换&lt;/p&gt;
&lt;h3 id=&#34;11-define与typedef区别&#34;&gt;1.1 define与typedef区别&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;两者都可以表示数据类型  1 #define INIT1 int 2 typedef in UINT2&lt;/li&gt;
&lt;li&gt;但有时候也会有区别比如定义指针类型的变量时&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define INT1 int *
typedef int * INT2;
INT1 a1, b1;//a1是指针，b1是int型
INT2 a2, b2;//两个都是指针

//INT1 a1,b1;被替换后为 int *a1,b1;即一个指向int类型的指针一个int类型的变量
//INT2  a2,b2;则是两个指向int类型的指针
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;宏定义是用宏名来表示一个字符串，在宏展开时又以该字符串取代宏名，这只是一种简单的代换，字符串中可以含任何字符，可以是常数，也可以是表达式，预处理程序对它不作任何检查。如有错误，只能在编译已被宏展开后的源程序时发现。&lt;/li&gt;
&lt;li&gt;宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起置换。&lt;/li&gt;
&lt;li&gt;宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用#undef命令。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-有参宏&#34;&gt;2 有参宏&lt;/h2&gt;
&lt;p&gt;带参宏定义的一般形式为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;#define 宏名(形参表) 字符串&lt;br&gt;
在字符串中含有各个形参。&lt;br&gt;
带参宏调用的一般形式为：&lt;br&gt;
宏名(形参表)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;iostream&amp;gt;
using namespace std;
#define MAX(a,b) a&amp;gt;b?a:b
int main()
{
    int i=5;
    int j=3;
    int max=MAX(i,j);
    cout&amp;lt;&amp;lt;&amp;quot;MAX(a,b)&amp;quot;&amp;lt;&amp;lt;max&amp;lt;&amp;lt;endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;21-宏定义和函数有何区别&#34;&gt;2.1 宏定义和函数有何区别？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宏函数不要在最后加分号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;22-运算符&#34;&gt;2.2 #运算符&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//#的作用就是将#后边的宏参数进行字符串的操作，也就是将#后边的参数两边加上一对双引号使其成为字符串。例如a是一个宏的形参，则替换文本中的#a被系统转化为&amp;quot;a&amp;quot;,这个转换过程即为字符串化。

#define TEST(param) #param
char *pStr=TEST(123);
printf(&amp;quot;pSrt=%s\n&amp;quot;,pStr);
//输出结果为字符  ”123“
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;23-运算符&#34;&gt;2.3 ##运算符&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//##运算符也可以用在替换文本中，它的作用起到粘合的作用，即将两个宏参数连接为一个数
#define TEST(param1,param2) (param1##param2)
int num =TEST(12,34);
printf(&amp;quot;num=%d\n&amp;quot;,num);
//输出结果为：num=1234
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-条件编译相关&#34;&gt;3 条件编译相关&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#ifdef
#ifndef
#endif
#if
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;防止头文件被重复包含&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#ifndef COMDEF_H

#define COMDEF_H
//头文件的内容

#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;用于注释·&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;#if 0
   不进行编译的代码
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;只在调试时进行编译，调试开关可以使用一个宏来实现&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define DEBUG

#ifdef DEBUG
   cerr &amp;lt;&amp;lt;&amp;quot;Variable x = &amp;quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; endl;
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;c-预定义宏&#34;&gt;C++ 预定义宏：&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;宏&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;LINE&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;这会在程序编译时包含当前行号。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;FILE&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;这会在程序编译时包含当前文件名。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;DATE&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;TIME&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include &amp;lt;iostream&amp;gt;
using namespace std;
 
int main ()
{
    cout &amp;lt;&amp;lt; &amp;quot;Value of __LINE__ : &amp;quot; &amp;lt;&amp;lt; __LINE__ &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; &amp;quot;Value of __FILE__ : &amp;quot; &amp;lt;&amp;lt; __FILE__ &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; &amp;quot;Value of __DATE__ : &amp;quot; &amp;lt;&amp;lt; __DATE__ &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; &amp;quot;Value of __TIME__ : &amp;quot; &amp;lt;&amp;lt; __TIME__ &amp;lt;&amp;lt; endl;
 
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当上面的代码被编译和执行时，它会产生下列结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Value of __LINE__ : 6
Value of __FILE__ : test.cpp
Value of __DATE__ : Feb 28 2011
Value of __TIME__ : 18:52:48
&lt;/code&gt;&lt;/pre&gt;
">define使用详解，条件编译等</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/assert-duan-yan-shi-yong/"" data-c="
          &lt;h2 id=&#34;契约式编程和防御式编程&#34;&gt;契约式编程和防御式编程&lt;/h2&gt;
&lt;p&gt;契约式编程契约作用于两方，每一方都会完成一些任务，从而促成契约的达成，但同时，每一方也会接受一些义务，作为制定契约的前提，有任意一方无视了必尽义的义务，则契约失败。函数调用者应该保证传入函数的参数是符合函数的要求，如果不符合函数要求，函数将拒绝继续执行。如果按照契约式编程的思想编写代码，就要求我们写函数时检查函数参数。有时候是简单的判断某个参数不能为空，或者数值不能小于0。如果在项目中全面应用契约式编程，则应该有一个“契约框架”帮我们来做这些事情，全部手动检查，代码就繁琐不堪了。在面向对象中，我们认为“接口”是唯一重要的东西，接口定义了组件，接口确定了系统，接口是我们唯一需要关心的东西，仅仅通过接口还不足以传达足够的信息，为了正确使用接口，必须考虑契约。只有考虑契约，才可能实现面向对象的目标：可靠性、可扩展性和可复用性。&lt;/p&gt;
&lt;p&gt;防御式编程《代码大全》给我们提供了一个定义，人类都是不安全、不值得信任的，所有的人，都会犯错误，而你写的代码，应该考虑到所有可能发生的错误，让你的程序不会因为他人的错误而发生错误。 程序需要对可能的错误输入，做出兼容，例如一个除法的函数，你必须判断分母可能为0的情况，从而给调用者返回错误提示。另外，一般的高级编程语言，都提供了『断言』和『异常』两种方式来进行错误处理。断言断言是指在开发期间使用的、让程序在运行时进行自检的代码。断言为真，则表明程序运行正常，而断言为假，则意味着它已经在代码中发现了意料之外的错误。断言对于大型的复杂程序或可靠性要求极高的程序来说尤其有用。通过使用断言，程序员能更快速地排查出因修改代码或者别的原因，而弄进程序里的不匹配的接口假定和错误等。一个断言通常包含两个参数：一个描述假设为真时的情况的布尔表达式，和一个断言为假时需要显示的信息。&lt;/p&gt;
&lt;p&gt;防御式编程就是持怀疑态度审视所有的代码，在游戏行业里，游戏服务端承担着游戏复杂业务逻辑实现，玩家数据持久化等重要作用，很多计算都是客户端发给服务器进行计算的，客户端很容易受到恶意用户的恶意修改，所以服务端会针对收到的数据进行严格的认证，在支付，金融行业更是如此。这些只是代码层面的，延伸了讲，个人认为用户行为日志，配置开关，一定的扩展涉及，等都是防御式编程思想的应用。&lt;/p&gt;
&lt;p&gt;防御式编程和契约式编程都是一种理想化的，全面实现都是比较困难的。但必要的防御措施以及必要的契约还是要有的，让每个人都对自己写的代码负责，建立起良好的信任关系，服务模块之间保持必要的信任。常见的开发模式中，lib库或者rpc服务是server端，调用方式client端，个人觉得服务端需要做更多的防御式验证，不能因为非法调用而运行异常，但调用方要相信server端，不要在做二次验证，就拿那个争论来说，你给我返回了非null的Long对象，我就默认是正确的，我不去做额外的检查他是-1还是-2，在调用方看来只有成功和失败。&lt;/p&gt;
&lt;h2 id=&#34;assert断言的使用&#34;&gt;assert断言的使用&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;头文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;cassert&amp;gt;//c++
#include&amp;lt;assert.h&amp;gt;//c
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;使用&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;assert(expr);//expr为假（0）,输出信息并终止程序进行，为真，什么也不做
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;解除&lt;br&gt;
在DEBUG模式下才运行，用于调试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#define NDEBUG//assert不执行
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;或者编译时：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;gcc -D NDEBUG main.c//相当于在文件开始加上上面的define
&lt;/code&gt;&lt;/pre&gt;
">assert断言使用，调试</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/vector-gou-jian-er-wei-shu-zu/"" data-c="
          &lt;h2 id=&#34;1-初始化&#34;&gt;1 初始化&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;用push_back初始化&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ve;

vector&amp;lt;int&amp;gt; a;
a.push_back(1);
a.push_back(2);
a.push_back(3);

vector&amp;lt;int&amp;gt; b;
b.push_back(4);
b.push_back(5);
b.push_back(6);

ve.push_back(a);
ve.push_back(b);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;先定义二维数组结构，再赋值&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int i,j;
vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; array(10);//这是一个10行x列的，一定要有这个
for (i = 0; i &amp;lt; array.size(); i++)
    array[i].resize(3);//确定列数

for(i = 0; i &amp;lt; array.size(); i++)//遍历行
{
    for (j = 0; j &amp;lt; array[0].size();j++)
    {
        array[i][j] = (i+1)*(j+1);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-遍历&#34;&gt;2 遍历&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;利用迭代器遍历&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void reverse_with_iterator(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; vec)
{
    if (vec.empty())
    {
        cout &amp;lt;&amp;lt; &amp;quot;The vector is empty!&amp;quot; &amp;lt;&amp;lt; endl;
        return;
    }

    vector&amp;lt;int&amp;gt;::iterator it;//这才是里层，因为每个迭代器指向的是一个int型
    vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;::iterator iter;//这是外层，迭代器指向的是vector&amp;lt;int&amp;gt;型
    vector&amp;lt;int&amp;gt; vec_tmp;

    cout &amp;lt;&amp;lt; &amp;quot;Use iterator : &amp;quot; &amp;lt;&amp;lt; endl;
    for(iter = vec.begin(); iter != vec.end(); iter++)
    {
        vec_tmp = *iter;
        for(it = vec_tmp.begin(); it != vec_tmp.end(); it++)
            cout &amp;lt;&amp;lt; *it &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        cout &amp;lt;&amp;lt; endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;利用行列直接遍历，当成一个二维数组&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;void reverse_with_index(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; vec)
{
    if (vec.empty())
    {
        cout &amp;lt;&amp;lt; &amp;quot;The vector is empty!&amp;quot; &amp;lt;&amp;lt; endl;
        return;
    }

    int i,j;
    cout &amp;lt;&amp;lt; &amp;quot;Use index : &amp;quot; &amp;lt;&amp;lt; endl;
    for (i = 0; i &amp;lt; vec.size(); i++)
    {
        for(j = 0; j &amp;lt; vec[0].size(); j++)
            cout &amp;lt;&amp;lt; vec[i][j] &amp;lt;&amp;lt; &amp;quot; &amp;quot;;
        cout &amp;lt;&amp;lt; endl;
    }
}
&lt;/code&gt;&lt;/pre&gt;
">vector构建二维数组</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/shell-jiao-ben-xue-xi/"" data-c="
          &lt;h1 id=&#34;1-使用&#34;&gt;1 使用&lt;/h1&gt;
&lt;p&gt;先赋予执行权限&lt;br&gt;
chmod +x  xxx.sh&lt;br&gt;
./xxx.sh&lt;br&gt;
&lt;strong&gt;注：chmod没有指定用户类型，则默认所有的都是+x&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;2-shell变量&#34;&gt;2 Shell变量&lt;/h1&gt;
&lt;h2 id=&#34;21-变量名命名规则&#34;&gt;2.1 变量名命名规则&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;和C语言差不多&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。&lt;/li&gt;
&lt;li&gt;中间不能有空格，可以使用下划线 _。&lt;/li&gt;
&lt;li&gt;不能使用标点符号。&lt;/li&gt;
&lt;li&gt;不能使用bash里的关键字（可用help命令查看保留关键字）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;赋值时变量和等号不能有空格&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;filename=&amp;quot;a.txt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;隐式赋值&#34;&gt;隐式赋值&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;for file in `ls /etc `
for file in $(ls /etc)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;22-使用变量&#34;&gt;2.2 使用变量&lt;/h2&gt;
&lt;p&gt;使用变量时用&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;符&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;号&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;加&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;不&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;加&lt;/mi&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;括&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;起&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;来&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;变&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;量&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;都&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;行&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;但&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;建&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;议&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;加&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;不&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;然&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;会&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;和&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;连&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;着&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;字&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;符&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;算&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;一&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;个&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;变&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;量&lt;/mi&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;只&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;有&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;要&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;使&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;用&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;这&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;个&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;变&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;量&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;的&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;时&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;候&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;加&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;符号，加不加{}括起来变量都行，但是建议加，不然会和连着的字符算一个变量
**只有是要使用这个变量的时候加&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.46528em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;符&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;号&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;加&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;不&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;加&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;括&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;起&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;来&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;变&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;量&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;都&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;行&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;但&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;是&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;建&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;议&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;加&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;不&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;然&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;会&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;和&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;连&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;着&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;字&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;符&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;算&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;一&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;个&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;变&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;量&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mbin&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2222222222222222em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.46528em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;只&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;有&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;是&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;要&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;使&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;用&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;这&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;个&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;变&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;量&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;的&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;时&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;候&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;加&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;，不能$变量=xxxx**&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;file_name=&amp;quot;a.txt&amp;quot;
ehco $file_name
ehco ${file_name}
file_name=&amp;quot;b.txt&amp;quot; #重新定义允许的
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;23-只读变量与删除变量&#34;&gt;2.3 只读变量与删除变量&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;只读变量&lt;br&gt;
使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;#!/bin/bash
myUrl=&amp;quot;https://www.google.com&amp;quot;
readonly myUrl
#或者
readonly myname=&amp;quot;syh&amp;quot; #自己试的
myname=&amp;quot;ssss&amp;quot;#报错
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;删除变量&lt;br&gt;
使用 unset 命令可以删除变量。语法：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;unset variable_name
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;变量被删除后不能再次使用。unset 命令不能删除只读变量。&lt;/p&gt;
&lt;h2 id=&#34;24-变量类型&#34;&gt;2.4 变量类型&lt;/h2&gt;
&lt;p&gt;运行shell时，会同时存在三种变量：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;局部变量 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。&lt;/li&gt;
&lt;li&gt;环境变量 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。&lt;/li&gt;
&lt;li&gt;shell变量 shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;25-shell字符串&#34;&gt;2.5 Shell字符串&lt;/h2&gt;
&lt;h3 id=&#34;单引号&#34;&gt;单引号&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;str=&#39;this is a string&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；&lt;/li&gt;
&lt;li&gt;单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;双引号&#34;&gt;双引号&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;your_name=&amp;quot;runoob&amp;quot;
str=&amp;quot;Hello, I know you are \&amp;quot;$your_name\&amp;quot;! \n&amp;quot;
echo -e $str
# 输出结果为：
Hello, I know you are &amp;quot;runoob&amp;quot;! 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;双引号的优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;双引号里可以有变量&lt;/li&gt;
&lt;li&gt;双引号里可以出现转义字符&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;字符串拼接&#34;&gt;字符串拼接&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;your_name=&amp;quot;runoob&amp;quot;
# 使用双引号拼接
greeting=&amp;quot;hello, &amp;quot;$your_name&amp;quot; !&amp;quot; # 这里是&amp;quot;  &amp;quot;+变量内容+&amp;quot;   &amp;quot;,并不是双引号里面有个双引号，是三个部分拼接
greeting_1=&amp;quot;hello, ${your_name} !&amp;quot; # {}去掉也一样
echo $greeting  $greeting_1
# 输出
# hello, runoob ! hello, runoob !

# 使用单引号拼接
greeting_2=&#39;hello, &#39;$your_name&#39; !&#39;  # 和双引号一样是三个部分拼接
greeting_3=&#39;hello, ${your_name} !&#39;# 变量没法直接用
echo $greeting_2  $greeting_3
# 输出
# hello, runoob ! hello, ${your_name} !
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;获取字符串长度&#34;&gt;获取字符串长度&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;string=&amp;quot;abcd&amp;quot;
echo ${#string} #输出 4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;提取子字符串&#34;&gt;提取子字符串&lt;/h3&gt;
&lt;p&gt;以下实例从字符串第 2 个字符开始截取 4 个字符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;string=&amp;quot;runoob is a great site&amp;quot;
echo ${string:1:4} # 输出 unoo
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;查找子字符串&#34;&gt;查找子字符串&lt;/h3&gt;
&lt;p&gt;查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;string=&amp;quot;runoob is a great site&amp;quot;
echo `expr index &amp;quot;$string&amp;quot; io`  # 输出 4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;expr在后面运算符会解释&lt;/p&gt;
&lt;h2 id=&#34;26-shell数组&#34;&gt;2.6 Shell数组&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;bash支持一维数组（不支持多维数组），并且没有限定数组的大小。&lt;/strong&gt;&lt;br&gt;
类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。&lt;/p&gt;
&lt;h3 id=&#34;定义数组&#34;&gt;定义数组&lt;/h3&gt;
&lt;p&gt;在 Shell 中，用括号来表示数组，数组元素用&amp;quot;空格&amp;quot;符号分割开。定义数组的一般形式为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数组名=(值1 值2 ... 值n)&lt;br&gt;
例如：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;array_name=(value0 value1 value2 value3)  # value类型不同也行，数字或字符串可以放一起
my_array=(A B &amp;quot;C&amp;quot; D) # 正确
# 或者
array_name=(
value0
value1
value2
value3
)
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;还可以单独定义数组的各个分量：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;array_name[0]=value0
array_name[1]=value1
array_name[n]=valuen
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以不使用连续的下标，而且下标的范围没有限制。&lt;/p&gt;
&lt;h3 id=&#34;读取数组&#34;&gt;读取数组&lt;/h3&gt;
&lt;p&gt;读取数组元素值的一般格式是：&lt;/p&gt;
&lt;p&gt;${数组名[下标]}&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 例如：
valuen=${array_name[n]}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 @ 符号可以获取数组中的所有元素，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo ${array_name[@]}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;获取数组的长度&#34;&gt;获取数组的长度&lt;/h3&gt;
&lt;p&gt;获取数组长度的方法与获取字符串长度的方法相同，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 取得数组元素的个数
length=${#array_name[@]}
# 或者
length=${#array_name[*]}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;取得数组单个元素的长度&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;lengthn=${#array_name[n]}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;27-注释&#34;&gt;2.7 注释&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;单行：#&lt;/li&gt;
&lt;li&gt;多行如下：&lt;br&gt;
多行注释还可以使用以下格式：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;:&amp;lt;&amp;lt;EOF
注释内容...
注释内容...
注释内容...
EOF
EOF 也可以使用其他符号:

:&amp;lt;&amp;lt;&#39;
注释内容...
注释内容...
注释内容...
&#39;

:&amp;lt;&amp;lt;!
注释内容...
注释内容...
注释内容...
!
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;3-shell传递参数&#34;&gt;3 Shell传递参数&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数处理&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;$#&lt;/td&gt;
&lt;td&gt;传递到脚本的参数个数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$*&lt;/td&gt;
&lt;td&gt;以一个单字符串显示所有向脚本传递的参数。如&amp;quot;$*&amp;quot;用「&amp;quot;」括起来的情况、以&amp;quot;$1 $2 … $n&amp;quot;的形式输出所有参数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$$&lt;/td&gt;
&lt;td&gt;脚本运行的当前进程ID号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$!&lt;/td&gt;
&lt;td&gt;后台运行的最后一个进程的ID号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$@&lt;/td&gt;
&lt;td&gt;与&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mo&gt;∗&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;相&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;同&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;但&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;是&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;使&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;用&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;时&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;加&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;引&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;号&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;，&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;并&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;在&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;引&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;号&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;中&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;返&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;回&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;每&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;个&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;参&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;数&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;。&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;如&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;*相同，但是使用时加引号，并在引号中返回每个参数。如&amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;∗&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;相&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;同&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;但&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;是&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;使&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;用&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;时&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;加&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;引&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;号&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;并&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;在&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;引&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;号&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;中&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;返&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;回&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;每&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;个&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;参&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;数&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;。&lt;/span&gt;&lt;span class=&#34;mord cjk_fallback&#34;&gt;如&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;@&amp;quot;用「&amp;quot;」括起来的情况、以&amp;quot;$1&amp;quot; &amp;quot;&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;mo&gt;…&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;&amp;quot;&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;2&amp;quot; … &amp;quot;&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;minner&#34;&gt;…&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;n&amp;quot; 的形式输出所有参数。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$-&lt;/td&gt;
&lt;td&gt;显示Shell使用的当前选项，与set命令功能相同。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$?&lt;/td&gt;
&lt;td&gt;显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;与-区别&#34;&gt;$* 与 $@ 区别：&lt;/h2&gt;
&lt;p&gt;相同点：都是引用所有参数。&lt;br&gt;
不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 &amp;quot; * &amp;quot; 等价于 &amp;quot;1 2 3&amp;quot;（传递了一个参数），而 &amp;quot;@&amp;quot; 等价于 &amp;quot;1&amp;quot; &amp;quot;2&amp;quot; &amp;quot;3&amp;quot;（传递了三个参数）。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;for i in &amp;quot;$*&amp;quot;
do
echo $i
done
# 输出 1 2 4
for i in &amp;quot;$@&amp;quot;
do
echo $i
done
#输出
#1
#2
#4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;练习：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;echo $1
echo &amp;quot;$1 is&amp;quot;
echo &#39;$1 is&#39;
for i in &amp;quot;$*&amp;quot;
do
echo $i
done

for i in &amp;quot;$@&amp;quot;
do
echo $i
done

echo &#39;$- :&#39; $-
echo &#39;$? :&#39; $?
echo &#39;$$ :&#39; $$
echo &#39;$# :&#39; $#
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;syh@test-Precision-7920-Tower:~/cpp$ ./canshu.sh 1 2 4 -t -c
1
1 is
$1 is
1 2 4 -t -c
1
2
4
-t
-c
$- : hB
$? : 0
$$ : 22211
$# : 5
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&#34;4-shell运算符&#34;&gt;4 Shell运算符&lt;/h1&gt;
&lt;h2 id=&#34;41-基础部分&#34;&gt;4.1 基础部分&lt;/h2&gt;
&lt;p&gt;Shell 和其他编程语言一样，支持多种运算符，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;算数运算符&lt;/li&gt;
&lt;li&gt;关系运算符&lt;/li&gt;
&lt;li&gt;布尔运算符&lt;/li&gt;
&lt;li&gt;字符串运算符&lt;/li&gt;
&lt;li&gt;文件测试运算符&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。&lt;br&gt;
expr 是一款表达式计算工具，使用它能完成表达式的求值操作。&lt;br&gt;
例如，两个数相加(注意使用的是反引号 ` 而不是单引号 &#39;)：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;val=`expr 2 + 2`
echo &amp;quot;两数之和为 : $val&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;特别注意：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;表达式和运算符之间要有空格&lt;/strong&gt;，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。&lt;/li&gt;
&lt;li&gt;完整的表达式要被 &lt;code&gt; &lt;/code&gt; 包含，注意这个字符不是常用的单引号，在 Esc 键下边。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;42-算数运算符&#34;&gt;4.2 算数运算符&lt;/h2&gt;
&lt;p&gt;下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;举例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;加法&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expr $a + $b&lt;/code&gt; 结果为 30。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;减法&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expr $a - $b&lt;/code&gt; 结果为 -10。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;乘法&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expr $a \* $b&lt;/code&gt; 结果为  200。一定要有转义符|&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;除法&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expr $b / $a&lt;/code&gt; 结果为 2。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%&lt;/td&gt;
&lt;td&gt;取余&lt;/td&gt;
&lt;td&gt;&lt;code&gt;expr $b % $a&lt;/code&gt; 结果为 0。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;赋值&lt;/td&gt;
&lt;td&gt;a=$b 把变量 b 的值赋给 a。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;==&lt;/td&gt;
&lt;td&gt;相等。&lt;/td&gt;
&lt;td&gt;用于比较两个数字，相同则返回 true。	[ $a == $b ] 返回 false。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;不相等。&lt;/td&gt;
&lt;td&gt;用于比较两个数字，不相同则返回 true。	[ $a != $b ] 返回 true。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;注意：&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;条件表达式要放在方括号之间，并且要有空格，例如: [&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a==&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.43056em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.36687em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;b] 是错误的，必须写成 [ $a == $b ]。&lt;/li&gt;
&lt;li&gt;乘法要有转义符\&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;示例&#34;&gt;示例&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;a=10
b=20

val=`expr $a + $b`
echo &amp;quot;a + b : $val&amp;quot;

val=`expr $a - $b`
echo &amp;quot;a - b : $val&amp;quot;

val=`expr $a \* $b`
echo &amp;quot;a * b : $val&amp;quot;

val=`expr $b / $a`
echo &amp;quot;b / a : $val&amp;quot;

val=`expr $b % $a`
echo &amp;quot;b % a : $val&amp;quot;

if [ $a == $b ]
then
   echo &amp;quot;a 等于 b&amp;quot;
fi
if [ $a != $b ]
then
   echo &amp;quot;a 不等于 b&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;** 在 MAC 中 shell 的 expr 语法是：$((表达式))，此处表达式中的 &amp;quot;*&amp;quot; 不需要转义符号 &amp;quot;&amp;quot; 。**&lt;/p&gt;
&lt;h2 id=&#34;43-关系运算符&#34;&gt;4.3 关系运算符&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;关系运算符只支持数字，不支持字符串，除非字符串的值是数字。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;举例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-eq&lt;/td&gt;
&lt;td&gt;检测两个数是否相等，相等返回 true。&lt;/td&gt;
&lt;td&gt;[ $a -eq $b ] 返回 false。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-ne&lt;/td&gt;
&lt;td&gt;检测两个数是否不相等，不相等返回 true。&lt;/td&gt;
&lt;td&gt;[ $a -ne $b ] 返回 true。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-gt&lt;/td&gt;
&lt;td&gt;检测左边的数是否大于右边的，如果是，则返回 true。&lt;/td&gt;
&lt;td&gt;[ $a -gt $b ] 返回 false。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-lt&lt;/td&gt;
&lt;td&gt;检测左边的数是否小于右边的，如果是，则返回 true。&lt;/td&gt;
&lt;td&gt;[ $a -lt $b ] 返回 true。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-ge&lt;/td&gt;
&lt;td&gt;检测左边的数是否大于等于右边的，如果是，则返回 true。&lt;/td&gt;
&lt;td&gt;[ $a -ge $b ] 返回 false。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-le&lt;/td&gt;
&lt;td&gt;检测左边的数是否小于等于右边的，如果是，则返回 true。&lt;/td&gt;
&lt;td&gt;[ $a -le $b ] 返回 true。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;a=10
b=20

if [ $a -eq $b ]
then
   echo &amp;quot;$a -eq $b : a 等于 b&amp;quot;
else
   echo &amp;quot;$a -eq $b: a 不等于 b&amp;quot;
fi
if [ $a -ne $b ]
then
   echo &amp;quot;$a -ne $b: a 不等于 b&amp;quot;
else
   echo &amp;quot;$a -ne $b : a 等于 b&amp;quot;
fi
if [ $a -gt $b ]
then
   echo &amp;quot;$a -gt $b: a 大于 b&amp;quot;
else
   echo &amp;quot;$a -gt $b: a 不大于 b&amp;quot;
fi
if [ $a -lt $b ]
then
   echo &amp;quot;$a -lt $b: a 小于 b&amp;quot;
else
   echo &amp;quot;$a -lt $b: a 不小于 b&amp;quot;
fi
if [ $a -ge $b ]
then
   echo &amp;quot;$a -ge $b: a 大于或等于 b&amp;quot;
else
   echo &amp;quot;$a -ge $b: a 小于 b&amp;quot;
fi
if [ $a -le $b ]
then
   echo &amp;quot;$a -le $b: a 小于或等于 b&amp;quot;
else
   echo &amp;quot;$a -le $b: a 大于 b&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;44-布尔运算符&#34;&gt;4.4 布尔运算符&lt;/h2&gt;
&lt;p&gt;下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;举例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;!&lt;/td&gt;
&lt;td&gt;非运算，表达式为 true 则返回 false，否则返回 true。&lt;/td&gt;
&lt;td&gt;[ ! false ] 返回 true。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-o&lt;/td&gt;
&lt;td&gt;或运算，有一个表达式为 true 则返回 true。&lt;/td&gt;
&lt;td&gt;[ $a -lt 20 -o $b -gt 100 ] 返回true。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-a&lt;/td&gt;
&lt;td&gt;与运算，两个表达式都为 true 才返回 true。&lt;/td&gt;
&lt;td&gt;[ $a -lt 20 -a $b -gt 100 ] 返回 false。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;a=10
b=20

if [ $a != $b ]
then
   echo &amp;quot;$a != $b : a 不等于 b&amp;quot;
else
   echo &amp;quot;$a == $b: a 等于 b&amp;quot;
fi
if [ $a -lt 100 -a $b -gt 15 ]
then
   echo &amp;quot;$a 小于 100 且 $b 大于 15 : 返回 true&amp;quot;
else
   echo &amp;quot;$a 小于 100 且 $b 大于 15 : 返回 false&amp;quot;
fi
if [ $a -lt 100 -o $b -gt 100 ]
then
   echo &amp;quot;$a 小于 100 或 $b 大于 100 : 返回 true&amp;quot;
else
   echo &amp;quot;$a 小于 100 或 $b 大于 100 : 返回 false&amp;quot;
fi
if [ $a -lt 5 -o $b -gt 100 ]
then
   echo &amp;quot;$a 小于 5 或 $b 大于 100 : 返回 true&amp;quot;
else
   echo &amp;quot;$a 小于 5 或 $b 大于 100 : 返回 false&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;45-逻辑运算符&#34;&gt;4.5 逻辑运算符&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;举例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
&lt;td&gt;逻辑的 AND&lt;/td&gt;
&lt;td&gt;[[ $a -lt 100 &amp;amp;&amp;amp; $b -gt 100 ]] 返回 false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;||&lt;/td&gt;
&lt;td&gt;逻辑的 OR&lt;/td&gt;
&lt;td&gt;[[ $a -lt 100&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;双层[]&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;a=10
b=20

if [[ $a -lt 100 &amp;amp;&amp;amp; $b -gt 100 ]]
then
   echo &amp;quot;返回 true&amp;quot;
else
   echo &amp;quot;返回 false&amp;quot;
fi

if [[ $a -lt 100 || $b -gt 100 ]]
then
   echo &amp;quot;返回 true&amp;quot;
else
   echo &amp;quot;返回 false&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;46-字符串运算符&#34;&gt;4.6 字符串运算符&lt;/h2&gt;
&lt;p&gt;下表列出了常用的字符串运算符，假定变量 a 为 &amp;quot;abc&amp;quot;，变量 b 为 &amp;quot;efg&amp;quot;：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;举例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;=&lt;/td&gt;
&lt;td&gt;检测两个字符串是否相等，相等返回 true。&lt;/td&gt;
&lt;td&gt;[ $a = $b ] 返回 false。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;检测两个字符串是否不相等，不相等返回 true。&lt;/td&gt;
&lt;td&gt;[ $a != $b ] 返回 true。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-z&lt;/td&gt;
&lt;td&gt;检测字符串长度是否为0，为0返回 true。&lt;/td&gt;
&lt;td&gt;[ -z $a ] 返回 false。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-n&lt;/td&gt;
&lt;td&gt;检测字符串长度是否不为 0，不为 0 返回 true。&lt;/td&gt;
&lt;td&gt;[ -n &amp;quot;$a&amp;quot; ] 返回 true。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;检测字符串是否为空，不为空返回 true。&lt;/td&gt;
&lt;td&gt;[ $a ] 返回 true。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;47-文件测试运算符&#34;&gt;4.7 文件测试运算符&lt;/h2&gt;
&lt;p&gt;用于检测 Unix 文件的各种属性。&lt;br&gt;
属性检测描述如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;举例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-b file&lt;/td&gt;
&lt;td&gt;检测文件是否是块设备文件，如果是，则返回 true。&lt;/td&gt;
&lt;td&gt;[ -b $file ] 返回 false。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-c file&lt;/td&gt;
&lt;td&gt;检测文件是否是字符设备文件，如果是，则返回 true。&lt;/td&gt;
&lt;td&gt;[ -c $file ] 返回 false。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-d file&lt;/td&gt;
&lt;td&gt;检测文件是否是目录，如果是，则返回 true。&lt;/td&gt;
&lt;td&gt;[ -d $file ] 返回 false。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-f file&lt;/td&gt;
&lt;td&gt;检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。&lt;/td&gt;
&lt;td&gt;[ -f $file ] 返回 true。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-g file&lt;/td&gt;
&lt;td&gt;检测文件是否设置了 SGID 位，如果是，则返回 true。&lt;/td&gt;
&lt;td&gt;[ -g $file ] 返回 false。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-k file&lt;/td&gt;
&lt;td&gt;检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。&lt;/td&gt;
&lt;td&gt;[ -k $file ] 返回 false。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-p file&lt;/td&gt;
&lt;td&gt;检测文件是否是有名管道，如果是，则返回 true。&lt;/td&gt;
&lt;td&gt;[ -p $file ] 返回 false。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-u file&lt;/td&gt;
&lt;td&gt;检测文件是否设置了 SUID 位，如果是，则返回 true。&lt;/td&gt;
&lt;td&gt;[ -u $file ] 返回 false。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-r file&lt;/td&gt;
&lt;td&gt;检测文件是否可读，如果是，则返回 true。&lt;/td&gt;
&lt;td&gt;[ -r $file ] 返回 true。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-w file&lt;/td&gt;
&lt;td&gt;检测文件是否可写，如果是，则返回 true。&lt;/td&gt;
&lt;td&gt;[ -w $file ] 返回 true。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-x file&lt;/td&gt;
&lt;td&gt;检测文件是否可执行，如果是，则返回 true。&lt;/td&gt;
&lt;td&gt;[ -x $file ] 返回 true。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-s file&lt;/td&gt;
&lt;td&gt;检测文件是否为空（文件大小是否大于0），不为空返回 true。&lt;/td&gt;
&lt;td&gt;[ -s $file ] 返回 true。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-e file&lt;/td&gt;
&lt;td&gt;检测文件（包括目录）是否存在，如果是，则返回 true。&lt;/td&gt;
&lt;td&gt;[ -e $file ] 返回 true。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;file=&amp;quot;/var/www/runoob/test.sh&amp;quot;
if [ -r $file ]
then
   echo &amp;quot;文件可读&amp;quot;
else
   echo &amp;quot;文件不可读&amp;quot;
fi
if [ -w $file ]
then
   echo &amp;quot;文件可写&amp;quot;
else
   echo &amp;quot;文件不可写&amp;quot;
fi
if [ -x $file ]
then
   echo &amp;quot;文件可执行&amp;quot;
else
   echo &amp;quot;文件不可执行&amp;quot;
fi
if [ -f $file ]
then
   echo &amp;quot;文件为普通文件&amp;quot;
else
   echo &amp;quot;文件为特殊文件&amp;quot;
fi
if [ -d $file ]
then
   echo &amp;quot;文件是个目录&amp;quot;
else
   echo &amp;quot;文件不是个目录&amp;quot;
fi
if [ -s $file ]
then
   echo &amp;quot;文件不为空&amp;quot;
else
   echo &amp;quot;文件为空&amp;quot;
fi
if [ -e $file ]
then
   echo &amp;quot;文件存在&amp;quot;
else
   echo &amp;quot;文件不存在&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;
">Shell脚本学习</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/register-xiu-shi-fu-yong-fa/"" data-c="
          &lt;p&gt;register修饰符暗示编译程序相应的变量将被频繁地使用，如果可能的话，应将其保存在CPU的寄存器中，以加快其存储速度。&lt;/p&gt;
&lt;p&gt;但是，使用register修饰符有以下几点限制：&lt;/p&gt;
&lt;p&gt;1、register变量必须是能被CPU所接受的类型。这通常意味着register变量必须是一个单个的值，并且长度小于等于整型的长度。不过有些机器的寄存器也可以放浮点型。&lt;/p&gt;
&lt;p&gt;2、register变量很可能不放在内存中，因此不能用&amp;amp;取地址。&lt;/p&gt;
&lt;p&gt;3、由于寄存器数量限制，而且某些寄存器只接受特点类型的数据（如指针或浮点数），因此真正起作用的register修饰符的数目和类型都依赖于运行程序的机器，而任何多余的register修饰变量都将被编译程序所忽略。&lt;/p&gt;
&lt;p&gt;4、随着编译程序设计技术的进步，在决定那些变量应该被存到寄存器中时，现在的C编译环境能比程序员做出更好的决定。实际上，许多编译程序都会忽略register修饰符，因为尽管它完全合法，但它仅仅是暗示而不是命令。&lt;/p&gt;
">register修饰符用法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/duo-xian-cheng-zhu-yi-dian/"" data-c="
          &lt;ol&gt;
&lt;li&gt;互斥锁没有初始化的时候，直接lock和unlock会出问题，力扣第1115题&lt;/li&gt;
&lt;/ol&gt;
">多线程注意点</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/stl-rong-qi-bi-ji/"" data-c="
          &lt;h1 id=&#34;1-顺序容器&#34;&gt;1 顺序容器&lt;/h1&gt;
&lt;h2 id=&#34;11-顺序容器概述&#34;&gt;1.1 顺序容器概述&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;容器&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;vector&lt;/td&gt;
&lt;td&gt;可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;deque&lt;/td&gt;
&lt;td&gt;双端队列。支持快速随机访问。在头尾位置插入/删除速度很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;list&lt;/td&gt;
&lt;td&gt;双向链表。只支持双向顺序访问。在list 中任何位置进行插入删除操作速度都很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;forward_list&lt;/td&gt;
&lt;td&gt;单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;array&lt;/td&gt;
&lt;td&gt;固定大小数组。支持快速随机访问。不能添加或删除元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;string&lt;/td&gt;
&lt;td&gt;与 vector 相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;112-选择容器的基本原则&#34;&gt;1.1.2 选择容器的基本原则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;除非你有很好的理由选择其他容器，否则应使用 vector。&lt;/li&gt;
&lt;li&gt;如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用 list 或 forward_list。&lt;/li&gt;
&lt;li&gt;如果程序要求随机访问元素，应使用vector或 deque。&lt;/li&gt;
&lt;li&gt;如果程序要求在容器的中间插入或删除元素，应使用list或 forward_1ist。&lt;/li&gt;
&lt;li&gt;如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用deque。&lt;/li&gt;
&lt;li&gt;如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则
&lt;ul&gt;
&lt;li&gt;首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向 vector 追加数据，然后再调用标准库的 sort 函数（我们将在10.2.3节介绍 sort（第343页））来重排容器中的元素，从而避免在中间位置添加元素。&lt;/li&gt;
&lt;li&gt;如果必须在中间位置插入元素，考虑在输入阶段使用1ist，一旦输入完成，将list中的内容拷贝到一个 vector中。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12-容器库概览&#34;&gt;1.2 容器库概览&lt;/h2&gt;
&lt;h3 id=&#34;121-头文件&#34;&gt;1.2.1 头文件&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;vector&amp;gt;//类似的
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;较旧的编译器可能需要在两个&amp;gt;间加上空格&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;vector&amp;lt;int&amp;gt; &amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;122-容器适用操作&#34;&gt;1.2.2 容器适用操作&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://imgtu.com/i/bOJBqK&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2022/03/14/bOJBqK.png&#34; alt=&#34;bOJBqK.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
续：&lt;br&gt;
反向容器的额外成员（不支持 forward_list）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;reverse iterator&lt;/td&gt;
&lt;td&gt;按逆序寻址元素的迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;const_reverse_iterator&lt;/td&gt;
&lt;td&gt;不能修改元素的逆序迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.rbegin(),C.rend ()&lt;/td&gt;
&lt;td&gt;返回指向c 的尾元素和首元素之前位置的迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.crbegin(),c.crend()&lt;/td&gt;
&lt;td&gt;返回 const_reverse_iterator&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;123-迭代器所有操作&#34;&gt;1.2.3 迭代器所有操作&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;*iter&lt;/td&gt;
&lt;td&gt;返回迭代器 iter 所指元素的引用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iter-&amp;gt;mem&lt;/td&gt;
&lt;td&gt;解引用iter并获取该元素的名为mem的成员，等价于（*iter）.mem&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;++iter&lt;/td&gt;
&lt;td&gt;令iter指示容器中的下一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;--iter&lt;/td&gt;
&lt;td&gt;令iter指示容器中的上一个元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iter1 == iter2&lt;/td&gt;
&lt;td&gt;判断两个迭代器是否相等（不相等），如果两个迭代器指示的是同一个元&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;iter1 != iter2&lt;/td&gt;
&lt;td&gt;素或者它们是同一个容器的尾后迭代器，则相等;反之，不相等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;124容器类型成员&#34;&gt;1.2.4容器类型成员&lt;/h3&gt;
&lt;p&gt;iterator:迭代器&lt;br&gt;
const_iterator:cbegin(),cend();只能读，不能用迭代器写&lt;br&gt;
反向迭代器：++返回的是上一个而不是下一个&lt;br&gt;
类型别名：reference和const_reference;在泛型编程中非常有用，16章看完后再整理&lt;/p&gt;
&lt;h3 id=&#34;125-begin和end成员&#34;&gt;1.2.5 begin和end成员&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;list&amp;lt;string&amp;gt; a = {&amp;quot;Milton&amp;quot;,&amp;quot;Shakespeare&amp;quot;,&amp;quot;Austen&amp;quot;);
auto it1 = a.begin();//list&amp;lt;string&amp;gt;;:iterator
auto it2 = a.rbeqin();//list&amp;lt;string&amp;gt;::reverse iterator
auto it3 = a.cbegin();//1ist&amp;lt;string&amp;gt;::const iterator
auto it4 a.crbegin();// list&amp;lt;string&amp;gt;::const_reverseiterator


// 显式指定类型
list&amp;lt;string&amp;gt;::iterator it5 = a.begin();
list&amp;lt;string&amp;gt;::const_iterator it6 = a.begin();
//是iterator还是 const iterator依赖于a的类型
auto it7= a.begin（）;// 仅当a是const时，it7是constiterator
auto it8 = a.cbegin（）;// it8是const_iterator
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当 auto与begin 或end结合使用时，获得的迭代器类型依赖于容器类型，与我们想要如何使用迭代器毫不相干。但以c开头的版本还是可以获得 const iterator的，而不管容器的类型是什么。&lt;br&gt;
&lt;strong&gt;当不需要写访问时，应使用 cbegin和 cend。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;126-容器定义和初始化&#34;&gt;1.2.6 容器定义和初始化&lt;/h3&gt;
&lt;p&gt;每个容器类型都定义了一个默认构造函数（参见7.1.4 节，第 236 页）。除 array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;结构&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;C c;&lt;/td&gt;
&lt;td&gt;默认构造函数。如果C是一个array，则c中元素按默认方式初始化;否则c为空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C c1(c2)&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C c1=c2&lt;/td&gt;
&lt;td&gt;c1初始化为c2的拷贝。cl和 c2必须是相同类型（即，它们必须是 ccl=c2 相同的容器类型，且保存的是相同的元素类型;对于array类型，两者还必须具有相同大小）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C c{a,b,c... }&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C c=(a,b,c...)&lt;/td&gt;
&lt;td&gt;c 初始化为初始化列表中元素的拷贝。列表中元素的类型必须与C 的元素类型相容。对于 array类型，列表中元素数目必须等于或小于array 的大小，任何遗漏的元素都进行值初始化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C c(b,e)&lt;/td&gt;
&lt;td&gt;c初始化为迭代器b和e指定范围中的元素的拷贝。范围中元素的类型必须与C的元素类型相容（array不适用）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;只有&lt;/td&gt;
&lt;td&gt;顺序容器（不包括 array）的构造函数才能接受大小参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C seq(n)&lt;/td&gt;
&lt;td&gt;seq 包含 n 个元素，这些元素进行了值初始化;此构造函数是explicit的（参见7.5.4节，第265页）。（string不适用）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C seq(n,t)&lt;/td&gt;
&lt;td&gt;seq包含n个初始化为值t的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;1-一个容器初始化为另一个的拷贝&#34;&gt;(1) 一个容器初始化为另一个的拷贝&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;不使用迭代器直接拷贝&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//每个容器有三个元素，用给定的初始化器进行初始化
list&amp;lt;string&amp;gt; authors =(&amp;quot;Milton&amp;quot;,&amp;quot;Shakespeare&amp;quot;,&amp;quot;Austen&amp;quot;);
vector&amp;lt;const char*&amp;gt; articles= {&amp;quot;a&amp;quot;,&amp;quot;an&amp;quot;,&amp;quot;the&amp;quot;);
list&amp;lt;string&amp;gt; list2 (authors);;///正确∶类型匹配
deque&amp;lt;string&amp;gt; authList（authors）;//错误∶客器类型不匹配
vector&amp;lt;string&amp;gt; words（articles）;// 错误;容器类型必须匹配
// 正确∶可以将const char*元素转换为 string
forward_list&amp;lt;string&amp;gt; words(articles.begin(),articles.end());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;使用迭代器的方法&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//拷贝元素，直到（但不包括）it指向的元素
deque&amp;lt;string&amp;gt; authList(authors,begin(),it);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;列表初始化&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//每个容器有三个元素，用给定的初始化器进行初始化
list&amp;lt;string&amp;gt; authors =(&amp;quot;Milton&amp;quot;,&amp;quot;Shakespeare&amp;quot;,&amp;quot;Austen&amp;quot;);
vector&amp;lt;const char*&amp;gt; articles={&amp;quot;a&amp;quot;,&amp;quot;an&amp;quot;,&amp;quot;the&amp;quot;);
//当这样做时，我们就显式地指定了容器中每个元素的值。对于除 array之外的容器类型，初始化列表还隐含地指定了容器的大小∶容器将包含与初始值一样多的元素。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;与顺序容器大小相关的构造函数,即C seg(n,t),array除外&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;int&amp;gt; ivec (10,-1); //10个int元素，每个都初始化为-1
list&amp;lt;string&amp;gt; svec (10,&amp;quot;hi!&amp;quot;); // 10个 strings;每个都初始化为&amp;quot;hi!&amp;quot;
forward_1ist&amp;lt;int&amp;gt; ivec (10); //10个元素，每个都初始化为0
deque&amp;lt;string&amp;gt; svec(10); //10个元素，每个都是空string
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;只有顺序容器的构造函数才接收大小参数，关联容器不支持&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;只有有默认构造函数的才可以只指定大小参数而不指定初始值&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;关于array的&lt;br&gt;
a. 必须指定容器大小&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;array&amp;lt;int,42&amp;gt; // 类型为∶保存42个int的数组
array&amp;lt;string,10&amp;gt; ///类型为∶保存10个string的数组

//为了使用 array类型，我们必须同时指定元素类型和大小∶
array&amp;lt;int,10&amp;gt;::size_type i; // 数组类型包括元素类型和大小
array&amp;lt;int&amp;gt;::size_type j; // 错误∶array&amp;lt;int&amp;gt;不是一个类型
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;b. 列表初始化时，初始值数目必须小于等于array大小&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;array&amp;lt;int,10&amp;gt; ial; // 10个默认初始化的 int
array&amp;lt;int，10&amp;gt; ia2=（0，1，2，3，4，5，6，7，8，9};// 列表初始化
array&amp;lt;int，10&amp;gt;ia3 ={42}; // ia3[0]为42，剩余元素为0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;c. 不能对内置数组类型进行拷贝或对象赋值操作，但 array并无此限制∶&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int digs[10] =(0,1,2,3,4,5,6,7,8,9};
int cpy[10] = digs; //错误∶内置数组不支持拷贝或赋值
array&amp;lt;int,10&amp;gt; digits =(0,1,2,3,4,5,6,7,8,9);
array&amp;lt;int，10&amp;gt; copy = digits;//正确∶只要数组类型匹配即合法
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;d. array类只能在初始化时才可以用列表，赋值时不可以用列表赋&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;array&amp;lt;int,10&amp;gt; al =(0,1,2,3,4,5,6,7,8,9};
array&amp;lt;int，10&amp;gt; a2=（0};//所有元素值均为0
al = a2;// 替换 al中的元素
a2 =（0};//错误∶不能将一个花括号列表赋予数组
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;由于右边运算对象的大小可能与左边运算对象的大小不同，因此array类型不支持 assign，&lt;br&gt;
也不允许用花括号包围的值列表进行赋值。&lt;/strong&gt;&lt;br&gt;
e. array使用swap会真正的交换数据&lt;/p&gt;
&lt;h3 id=&#34;127-赋值和swap&#34;&gt;1.2.7 赋值和swap&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;c1=c2&lt;/td&gt;
&lt;td&gt;将 c1中的元素替换为 c2中元素的拷贝。&lt;strong&gt;c1和c2 必须具有相同的类型&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c={a,b,c... }&lt;/td&gt;
&lt;td&gt;将c1中元素替换为初始化列表中元素的拷贝（array 不适用）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;swap (c1,c2) ;  cl.swap (c2)&lt;/td&gt;
&lt;td&gt;交换 cl和c2中的元素。c1和 c2必须具有相同的类型。swap通常比从 c2向c1拷贝元素快得多&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;assign 操作不适用于关联容器和 array&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;seq.assign (b,e) :&lt;/td&gt;
&lt;td&gt;将 seg中的元素替换为迭代器b和 e 所表示的范围中的元素。迭代器b和e不能指向 seg中的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;seq.assign(il)&lt;/td&gt;
&lt;td&gt;将 seq中的元素替换为初始化列表11中的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;seg.assign (n,t)&lt;/td&gt;
&lt;td&gt;将seg中的元素替换为n 个值为t的元素&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;c1=c2; // 将c1的内容替换为c2中元素的拷贝
cl = {a，b，c};// 赋值后，cl大小为3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意：第一个赋值运算后，左边容器将与有边容器相等。如果两个容器原来大小不同，赋值运算后两者的大小都与右边容器的原大小相同。第二个赋值运算后，c1的 size变为3，即花括号列表中值的数目。&lt;/p&gt;
&lt;h4 id=&#34;1-assign的使用仅顺序容器&#34;&gt;(1) assign的使用(仅顺序容器)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;一个容器给另一个赋值&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;list&amp;lt;string&amp;gt; names;
vector&amp;lt;const char*&amp;gt; oldstyle;
names = oldstyle;//错误∶客器类型不匹配
// 正确∶可以将 const char*转换为 string
names.assign (oldstyle.cbegin(),oldstyle.cend());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：1. 前面初始化时也是，可以这样用&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;用指定数目且具有相同给定值的元素替换容器中原有的元素&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//等价于slist1.clear（）;
//后跟 slist1.insert（slist1.begin（），10，&amp;quot;Hiya!&amp;quot;》;
1ist&amp;lt;string&amp;gt; slist1(1); // 1个元素，为空string
slist1.assign（10，&amp;quot;Hiya!&amp;quot;); // 10个元素，每个都是&amp;quot;Hiya!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-使用swap&#34;&gt;(2) 使用swap&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//swap 操作交换两个相同类型容器的内容。调用swap 之后，两个容器中的元素将会交换∶
vector&amp;lt;string&amp;gt; svecl（10）;// 10个元素的vector
vector&amp;lt;string&amp;gt; svec2（24）;// 24个元素的 vector
swap (svec1,svec2);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;调用 swap 后，svecl将包含24个string 元素，svec2将包含10个string.除 array外，交换两个容器内容的操作保证会很快——元素本身并未交换，swap 只是交换了两个容器的内部数据结构。&lt;br&gt;
除 array 外，swap 不对任何元素进行拷贝、删除或插入操作，因此可以保证 Nte 在常数时间内完成。&lt;br&gt;
元素不会被移动的事实意味着，除 string 外，指向容器的迭代器、引用和指针在swap 操作之后都不会失效。它们仍指向 swap操作之前所指向的那些元素。但是，在swap之后，这些元素已经属于不同的容器了。例如，假定iter在 swap 之前指向 svecl[3]的string，那么在swap之后它指向 svec2[3]的元素。与其他容器不同，对一个string调用 swap 会导致迭代器、引用和指针失效。&lt;/p&gt;
&lt;h3 id=&#34;128-容器大小的操作&#34;&gt;1.2.8 容器大小的操作&lt;/h3&gt;
&lt;p&gt;除了一个例外，每个容器类型都有三个与大小相关的操作。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;成员函数 size返回容器中元素的数目；&lt;/li&gt;
&lt;li&gt;empty当size 为0时返回布尔值 true，否则返回 false;&lt;/li&gt;
&lt;li&gt;max_size 返回一个大于或等于该类型容器所能容纳的最大元素数的值。&lt;/li&gt;
&lt;li&gt;forwardlist支持max_size 和empty，但不支持size，原因我们将在下一节解释。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;129-关系运算符&#34;&gt;1.2.9 关系运算符&lt;/h3&gt;
&lt;p&gt;顺序与关联均支持：==和!=&lt;br&gt;
仅顺序支持：&amp;gt;,&amp;lt;,&amp;gt;=,&amp;lt;=&lt;/p&gt;
&lt;h4 id=&#34;1-使用规则&#34;&gt;(1) 使用规则&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;左右必须是相同类型的容器&lt;/li&gt;
&lt;li&gt;比较实际上是逐元素比较的&lt;/li&gt;
&lt;li&gt;如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等;否则两个容器不等。&lt;/li&gt;
&lt;li&gt;如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。（感觉和第五个判断冲突了）&lt;/li&gt;
&lt;li&gt;如果两个容器都不是另一个容器的前缀子序列，则它们的比较结果取决于第一个不相等的元素的比较结果。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;int&amp;gt; vl=! 1,3,5,7,9,12 );
vector&amp;lt;int&amp;gt; v2 =1,3,9J;
vector&amp;lt;int&amp;gt; v3 =[ 1,3,5,7 1;
vector&amp;lt;int&amp;gt; v4=[1,3,5,7,9,12);
v1&amp;lt; v2 //true;v1和v2在元素【2】处不同∶v1【2】小于等于v2【2】
vl &amp;lt; v3 // false;所有元素都相等，但v3中元素数目更少
v1 == v4// true;每个元素都相等，且v1和v4大小相间
vl== v2 // false;v2元素数目比v1少
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：容器的运算符比较实际还是内部元素的比较，如果元素没有定义这种比较，就会报错&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;13-顺序容器的操作&#34;&gt;1.3 顺序容器的操作&lt;/h2&gt;
&lt;h3 id=&#34;131-添加元素&#34;&gt;1.3.1 添加元素&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;c.push_back(t) ; c.emplace_back(args)&lt;/td&gt;
&lt;td&gt;在c的尾部创建一个值为t或由 args 创建的元素。返回void。&lt;strong&gt;forward_list不支持这俩&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.push_front(t) ;c.emplace_front (args)&lt;/td&gt;
&lt;td&gt;在c 的头部创建一个值为t或由 angs创建的元素。返回 void。&lt;strong&gt;vector和string不支持这俩&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.insert(p, t) ;c.emplace (p,args)&lt;/td&gt;
&lt;td&gt;在迭代器 &lt;strong&gt;p指向的元素之前&lt;/strong&gt;创建一个值为t或由 args创建的元素。返回指向新添加的元素的迭代器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.insert(p,n,t)&lt;/td&gt;
&lt;td&gt;在选代器&lt;strong&gt;p指向的元素之前&lt;/strong&gt;插入n个值为t的元素。返回指向新添加的第一个元素的迭代器;若n为0，则返回p&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.insert(p,b, e)&lt;/td&gt;
&lt;td&gt;将迭代器b 和e指定的范围内的元素插入到迭代器p指向的元素之前。b 和 e 不能指向 c中的元素。返回指向新添加的第一个元素的迭代器;若范围为空，则返回p&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c.insert(p,il)&lt;/td&gt;
&lt;td&gt;i1是一个花括号包围的元素值列表。将这些给定值插入到迭代器p指向的元素之前。返回指向新添加的第一个元素的迭代器;若列表为空，则返回p&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;注意：这些操作array都没有；向vector,string,deque插入元素会使所有指向容器的迭代器，引用和指针失效&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;forward_list有自己版本的insert和emplace&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;1-push_back的使用&#34;&gt;(1) push_back的使用&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;除array和forward_list之外都支持&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;string以外的&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//例如，下面的循环每次读取一个 string到 word中，然后追加到容器尾部∶
// 从标准输入读取数据，将每个单词放到容器末尾
string word;
while (cin &amp;gt;&amp;gt; word)
    container.push_back (word);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对 push back的调用在container尾部创建了一个新的元素，将container的 size增大了1。该元素的值为 word的一个拷贝。container 的类型可以是list、vector或 deque。&lt;br&gt;
2. string&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;由于string是一个字符容器，我们也可以用push_back 在string末尾添加字符∶
void pluralize(size_t cnt,string word)
{
    if (cnt &amp;gt; 1)
        word.push_back（&#39;s&#39;）;// 等价于word +=&#39;s&#39;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;2-push_front&#34;&gt;(2) push_front&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;仅list，forward_list,deque支持&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;list&amp;lt;int&amp;gt; ilist;
// 将元素添加到ilist开头
for(size_t ix = 0;ix != 4;++ix)
    ilist.pushfront(ix);
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;3-特定位置插入元素&#34;&gt;(3) 特定位置插入元素&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;第一个参数都是迭代器&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;插入单个元素&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;list.insert（iter，&amp;quot;Hello!&amp;quot;）;//将&amp;quot;Hello!&amp;quot;添加到iter之前的位置

vector&amp;lt;string&amp;gt; svec;
list&amp;lt;string&amp;gt; slist;
//等价于调用slist.push_front（&amp;quot;Hello!&amp;quot;）;
s1ist.insert(slist.begin(),&amp;quot;Hello!&amp;quot;);
// vector 不支持push front，但我们可以插入到 begin（）之前
//警告∶插入到vector末尾之外的任何位置都可能很慢
svec.insert(svec.begin(),&amp;quot;Hello!&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;插入范围元素&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;a. 其中一个版本接受一个元素数目和一个值，它将指定数量的元素添加到指定位置之前，这些元素都按给定值初始化∶&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;svec.insert(svec.end(),10,&amp;quot;Anna&amp;quot;);
//这行代码将10个元素插入到svec的末尾，并将所有元素都初始化为string&amp;quot;Anna&amp;quot;。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;b. 接受一对迭代器或一个初始化列表的 insert 版本将给定范围中的元素插入到指定位置之前∶&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;string&amp;gt; v={&amp;quot;quasi&amp;quot;,&amp;quot;simba&amp;quot;,&amp;quot;frollo&amp;quot;,&amp;quot;scar&amp;quot;);
//将v的最后两个元素添加到slist的开始位置
slist.insert(slist.begin(),v.end()-2,v.end();
slist.insert(slist.end(),{&amp;quot;these&amp;quot;,&amp;quot;words&amp;quot;,&amp;quot;will&amp;quot;,&amp;quot;go&amp;quot;,&amp;quot;at&amp;quot;,&amp;quot;the&amp;quot;,&amp;quot;end&amp;quot;});
//运行时错误∶迭代器表示要拷贝的范围，不能指向与目的位置相同的容器
slist.insert(slist.begin(),slist.begin(),slist.end());
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如果我们传递给 insert一对迭代器，它们不能指向添加元素的目标容器。&lt;/strong&gt;&lt;br&gt;
3. 返回值&lt;br&gt;
在新标准下，接受元素个数或范围的insert 版本返回指向第一个新加入元素的迭代器。（在旧版本的标准库中，这些操作返回void。）如果范围为空，不插入任何元素，insert 操作会将第一个参数返回。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;vector&amp;lt;int&amp;gt; v1={1,2,3,4,5,6};
    vector&amp;lt;int&amp;gt; v2={7,8,9};
    auto it=v1.begin();
    it++;
    auto it2=v1.insert(it,{7,8,9});
    cout&amp;lt;&amp;lt;*it2&amp;lt;&amp;lt;endl;
    for(int i=0;i&amp;lt;v1.size();i++)
    {
        cout&amp;lt;&amp;lt;v1[i]&amp;lt;&amp;lt;endl;
    }
//输出
7//返回第一个插入的元素的迭代器
1
7
8
9
2
3
4
5
6
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;4-emplace操作&#34;&gt;(4) emplace操作&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;与push，insert的不同处&lt;br&gt;
push，insert是将对象传递给他们，这些对象被拷贝到容器中，会去创建一个局部临时对象，并将其压入容器中&lt;br&gt;
emplace是将参数传递给元素类型的构造函数，emplace成员使用这些参数在容器管理的内存空间直接构造元素&lt;/li&gt;
&lt;li&gt;emplace接收的是容器内元素的构造函数的参数&lt;/li&gt;
&lt;li&gt;emplace_back的使用，front类似&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/ 在c的末尾构造一个Sales data对象
// 使用三个参数的 Sale3_data构造函数
c.emplace_back(&amp;quot;978-0590353403&amp;quot;,25,15.99);
// 错误∶没有接受三个参数的 push_back 版本
c.push back(&amp;quot;978-0590353403&amp;quot;,25,15.99);
//正确;创建一个临时的 Sales data对象传递给push back
c.push_back(Sales_data(&amp;quot;978-0590353403&amp;quot;,25,15.99));
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;emplace的使用&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;//iter指向c中一个元素，其中保存了Sales data元素
c.emplace_back();//使用Sales data 的默认构造函数
c.emplace(iter，&amp;quot;999-999999999&amp;quot;);//使用Sales_data（string）
//使用 Sales_data的接受一个ISBN、一个count和一个price的构造函数
c.emplace_front(&amp;quot;978-0590353403&amp;quot;,25,15.99);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;emplace 函数在容器中直接构造元素。传递给emplace 函数的参数必须与元素类型的构造函数相匹配&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;132-元素访问&#34;&gt;1.3.2 元素访问&lt;/h3&gt;
">STL容器笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/guan-yu-yong-hu-nei-cun-shi-yong-de-bi-ji/"" data-c="
          &lt;h2 id=&#34;空间示意图32位&#34;&gt;空间示意图（32位）&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://imgtu.com/i/bJa0bD&#34;&gt;&lt;img src=&#34;https://s4.ax1x.com/2022/03/03/bJa0bD.png&#34; alt=&#34;bJa0bD.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
&lt;strong&gt;.data在低地址，.bss在高地址&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;bss段data段text段&#34;&gt;bss段，data段，text段&lt;/h3&gt;
&lt;p&gt;未初始化的全局变量、静态局部变量，存储在.bss段中，具体体现为一个占位符；&lt;br&gt;
已初始化的全局变量、静态局部变量，存储在.data段中；&lt;br&gt;
此外，非静态局部变量，都在栈中分配空间。&lt;/p&gt;
&lt;p&gt;.bss 是不占用.exe文件空间的，其内容由操作系统初始化（清零）；&lt;br&gt;
.data 却需要占用，其内容由程序初始化。因此造成了上述情况。&lt;/p&gt;
&lt;p&gt;bss 段，不为数据分配空间，只是记录数据所需空间的大小；&lt;br&gt;
bss 段的大小从可执行文件中得到 ，然后链接器得到这个大小的内存块，紧跟在data段后面。&lt;/p&gt;
&lt;p&gt;data 段，则为数据分配空间，数据保存在目标文件中；&lt;br&gt;
data 段包含经过初始化的全局变量以及它们的值。&lt;/p&gt;
&lt;p&gt;作者：JamFF&lt;br&gt;
链接：https://www.jianshu.com/p/ddfb284c1f7a&lt;br&gt;
来源：简书&lt;br&gt;
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;
&lt;h3 id=&#34;堆栈&#34;&gt;堆，栈&lt;/h3&gt;
&lt;p&gt;https://www.jianshu.com/p/431dbb8878fb&lt;/p&gt;
">关于用户内存使用的笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/sui-shou-ji/"" data-c="
          &lt;ol&gt;
&lt;li&gt;定义在函数体之外的内置类型的变量被初始化为0&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int i;
int func()
{
    return i;
}
int main()
{
    printf(&amp;quot;%d&amp;quot;,func());//print 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;内联函数和constexpr函数可以在程序中多次定义，但是它的多个定义必须完全一致，&lt;/li&gt;
&lt;/ol&gt;
">随手记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/zhi-zhen-chang-liang-zhi-xiang-chang-liang-de-zhi-zhen-chang-liang-zhi-zhen-chang-liang-yin-yong/"" data-c="
          &lt;h2 id=&#34;1-指针常量&#34;&gt;1 指针常量&lt;/h2&gt;
&lt;p&gt;指的是指针本身是一个常量，必须初始化，也不能改指向别的对象。&lt;br&gt;
能否通过指针改变指向对象的值取决于指向的对象是否是常量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int a=1;
int *const ptr=&amp;amp;a;
(*ptr)=100;//可以，a不是一个常量
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-常量指针&#34;&gt;2 常量指针&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;const int *ptr
int const *ptr
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指向常量的指针并没有规定其所指向的对象必须是一个常量，也就是可以指向一个const限制的，也可以指向一个普通的变量；所谓指向常量的指针，仅仅要求不能通过该指针改变对象的值，而没有规定那个对象不能通过其他途径改变。&lt;br&gt;
&lt;strong&gt;但是要注意：一个常量不能用一个普通指针指向他，自己试的可以通过编译，但是会报warning&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;const double pi = 3.14;
double *ptr = &amp;amp;pi;//错误的

const double *cptr=&amp;amp;pi;//正确
*cptr=44;//错误
double a=11;
cptr=&amp;amp;a;//正确
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-顶层const与底层const&#34;&gt;3 顶层const与底层const&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;顶层const：指针本身是一个常量，也就是指针常量&lt;/li&gt;
&lt;li&gt;底层const：指针所指的对象是一个常量&lt;/li&gt;
&lt;li&gt;顶层const也可以表示任意的对象是常量&lt;/li&gt;
&lt;li&gt;用于声明引用的const都是底层const&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int i=0;
int *const p1 =&amp;amp;i;//顶层const，本身的值不可变
const int c=33;//顶层const，c的值也不可变
const int* p2=&amp;amp;c;//底层const，p2的值可变

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;要注意非常量可以转化成常量，反之不行&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-常量引用&#34;&gt;4 常量引用&lt;/h2&gt;
&lt;p&gt;常量引用和常量指针一样，没说引用或指向的一定得是常量，只是说不能通过该引用或者指针来改变引用或指向的对象，但是这个对象可以通过其他方式改变（如果不是常量的话）。&lt;br&gt;
同样的，不能用一个普通的引用来引用一个常量。&lt;/p&gt;
&lt;h2 id=&#34;5-常量表达式&#34;&gt;5 常量表达式&lt;/h2&gt;
&lt;p&gt;定义：指值不会改变并且在编译过程中就能得到计算结果的表达式。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;const int i=20;//is const expression
const int j=i+1;//is ... 
int x = 20;//is not a const expression
const int ss=get_ss()//is not a...,编译是不能确定
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;constexpr类型&#34;&gt;constexpr类型&lt;/h3&gt;
&lt;p&gt;声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;constexpr int mf = 20;//20是常量表达式
constexpr int limit = mf+1;//mf+1是常量表达式
constexpr int sz = size();//只有当size()是一个constexpr函数时，才是一条正确的声明
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;constexpr修饰指针仅与指针有关，而与指向的对象无关，就是个指针常量&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;const int *p=nullptr;//p是一个指向整常量的指针，常量指针
constexpr *q=nullptr;//q是一个指向整数的常量指针，指针常量
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;constexpr指针不能指向放在函数体内的变量，引用也不可以，必须是全局变量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int i=100;
int main()
{
    int j=100;
    constexpr int *p=&amp;amp;i;//right
    constexpr int *q=&amp;amp;j;//wrong
    constexpr int &amp;amp;t=i;//right
    constexpr int &amp;amp;y=j;//wrong
}
&lt;/code&gt;&lt;/pre&gt;
">const 相关，指针常量,  指向常量的指针（常量指针）,常量引用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/pyu-pp-yu-pde-li-jie/"" data-c="
          &lt;h2 id=&#34;1-优先级&#34;&gt;1 优先级&lt;/h2&gt;
&lt;p&gt;后置++和--大于前置++和--&lt;br&gt;
*比这都小&lt;br&gt;
结合都是右结合&lt;/p&gt;
&lt;h3 id=&#34;11-左右结合&#34;&gt;1.1 左右结合&lt;/h3&gt;
&lt;p&gt;就是好几个同一优先级的，等于右边的加个括号&lt;/p&gt;
&lt;h2 id=&#34;2-例子&#34;&gt;2 例子&lt;/h2&gt;
&lt;h3 id=&#34;21-p&#34;&gt;2.1 *p++&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;=是右结合
a=b=c
相当于
a=(b=c)
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;int a[3]={1,2,3};
int *p=a;
cout&amp;lt;&amp;lt;*p++&amp;lt;&amp;lt;endl;//结果为1
cout&amp;lt;&amp;lt;*p&amp;lt;&amp;lt;endl;//结果为2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;*p++相当于*(p++),但是由于后置++将自增前的原始副本作为右值返回，因此*p++还是对自增前的p解引用&lt;br&gt;
&lt;strong&gt;注意：后置++也就不可以作为左值了，a++=b，是错的&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;22-p&#34;&gt;2.2 *++p&lt;/h3&gt;
&lt;p&gt;由于右结合，*++p相当于*(++p),且前置++返回的是对象本身，这里也就是自增过后的本身&lt;br&gt;
&lt;strong&gt;注意：前置++可以作为左值，++a=b，是对的&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;23-p和p一样的&#34;&gt;2.3 (*p)++和++(*p)一样的&lt;/h3&gt;
&lt;p&gt;就是先解引用再自增&lt;/p&gt;
&lt;h3 id=&#34;24-p&#34;&gt;2.4 ++*p&lt;/h3&gt;
&lt;p&gt;由于前置++和*优先级一样，且是右结合，所以相当于++(*p)&lt;/p&gt;
">*p++与*++p；(*p)++ 与 ++(*p)的理解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/cpp-sui-shou-ji/"" data-c="
          &lt;ol&gt;
&lt;li&gt;重载实现编译时多态，虚函数实现运行时多态&lt;/li&gt;
&lt;/ol&gt;
">cpp随手记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/cpp-xiang-guan/"" data-c="
          &lt;h1 id=&#34;c-体系结构和内核分析&#34;&gt;C++ 体系结构和内核分析&lt;/h1&gt;
&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&#34;写在前面的-编程规范&#34;&gt;写在前面的 —— 编程规范&lt;/h1&gt;
&lt;h2 id=&#34;常规&#34;&gt;常规&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;每行不得超过一个表达式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能将函数写在一行上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单行不得超过 120 个字符 ，并且始终不得超过 140 个字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行不应以空格或制表符结尾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件必须以空行结尾&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有命名都必须由正确的英语单词或其缩写构成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变量 的定义应尽可能的接近使⽤点 应有尽可能⼩的作⽤域&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有 变量 都 应 在 定义时 初始化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有的常量都应用 const 标记&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果通过引用传递的函数参数在函数中无更改 ，则其也应用 const 标记&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每单位的缩进为两个字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缩进反映了程序的逻辑结构&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在循环中的语句的缩进值必须大于循环标头&lt;/li&gt;
&lt;li&gt;在 if 和 else 中的语句必须具有⼤于 if 和 else 标头的缩进&lt;/li&gt;
&lt;li&gt;switch 中的 case 关键字必须与 switch 对齐&lt;/li&gt;
&lt;li&gt;在 switch 中包含的语句 ，其缩进应至少大于一个一个单位 性对于 switch 的缩进&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;循环和条件判断中的所有语句都应用打括号括起来 ，及时它为单条语句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打括号必须 规范放置 ，有以下两种选择&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;img src=&#34;Readme.assets/image-20210804154958445.png&#34; alt=&#34;image-20210804154958445&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;Readme.assets/image-20210804155004724.png&#34; alt=&#34;image-20210804155004724&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;函数的括号放置只允许一种情况：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;Readme.assets/image-20210804155025280.png&#34; alt=&#34;image-20210804155025280&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;在程序中括号的放置只应遵循一种 ，不得多种方法混用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关键字 if 和 else 可以组合在一起 ，以便减少缩进&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;Readme.assets/image-20210804155104112.png&#34; alt=&#34;image-20210804155104112&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所有的命名不得以下划线开头&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宏定义必须为大写&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;较长语句的分行应向如下所示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在下一行的开头，必须有一个连字符运算符（逗号除外）&lt;/li&gt;
&lt;li&gt;边距的缩进必须大于 &lt;strong&gt;2&lt;/strong&gt; 个单位&lt;/li&gt;
&lt;li&gt;如果在带括号的复杂表达式中使⽤连字符，则缩进应反映括号嵌套，每个嵌套级别 在下⼀⾏添加1个缩进&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;Readme.assets/image-20210804160235035.png&#34; alt=&#34;image-20210804160235035&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在表达式内部，应使⽤括号以避免歧义。 除了明显的算数优先级外，所有表达式都应经过设计，因此在阅读时不需要知道运算符优先级&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不允许在头文件中的顶部使用命名空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;头文件必须包含 “#include 防范”，也就是必须防止头文件被重复编译&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;包含头⽂件的顺序⾮常重要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;包含应有其定义的头文件，例如：circle.cpp 首先应包含 circle.hpp&lt;/li&gt;
&lt;li&gt;标注库&lt;/li&gt;
&lt;li&gt;头文件使用的库&lt;/li&gt;
&lt;li&gt;自定义头文件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对头文件的依赖应最小化，如果头文件中包含了过多的声明，则不应该在此头文件中进行其实现&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;类的编写&#34;&gt;类的编写&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;类名必须由&lt;strong&gt;大写字母开头&lt;/strong&gt; ，如果名称有多个单词组成 ，则每个单词首字母都应大写 CapsCase 。例如 Queue 和 RoundedRectangle；此外另一种可能的命名规则为每个单词为小写且用下划线分割（不推荐）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类名必须是带有&lt;strong&gt;明确含义的完整单词&lt;/strong&gt; ，另外 ，函数名必须由动词开头 ，因为它代表一个动作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果为 struct 结构体 （无需构造和析构函数 ），结构体的命名可用小写字母加下划线分割 ，且必须在名称后面添加 &lt;code&gt;_t&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类内的部分 应按照他们的作用排序&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;public ：对外接口&lt;/li&gt;
&lt;li&gt;protected ：继承接口&lt;/li&gt;
&lt;li&gt;private ：私有部分&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类内在每个部分的信息应安排如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;类型&lt;/li&gt;
&lt;li&gt;类字段&lt;/li&gt;
&lt;li&gt;无参默认构造函数&lt;/li&gt;
&lt;li&gt;复制和移动构造&lt;/li&gt;
&lt;li&gt;所有其他构造&lt;/li&gt;
&lt;li&gt;析构函数&lt;/li&gt;
&lt;li&gt;重载运算符&lt;/li&gt;
&lt;li&gt;成员方法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数和成员方法 应使用驼峰命名法 （camelCase），即 小写字母开头紧随其后的单词首字母应为大写 ，例如 &lt;code&gt;draw() &lt;/code&gt;、 &lt;code&gt;getArea()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数名应为动词开头 因为他们代表一个动作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应在所有未改变变量值的成员方法加上 &lt;code&gt;const&lt;/code&gt; 限定符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类字段的命名必须拥有独特的字段属性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;前缀为 &lt;code&gt;m_&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在最后添加下划线 &lt;code&gt;_&lt;/code&gt; 推荐&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class Demo
{
    public:
    	...
    
    private:
    	double aurmOne_;
    	char aurmTwo_;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构造函数中的初始化列表必须每⾏最多初始化⼀个变量或基类。 初始化列表前⾯的冒号必须保留在参数列表的⾏中，不允许将其转移到下⼀⾏&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;Circle::Circle(double r_circle, const point_t&amp;amp; center):
  circle_center_(center),
  r_circle_(r_circle)
{
  assert(r_circle &amp;gt; 0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在实现⽂件中，所有函数必须具有完全限定的名称，其中名称空间和类名称使⽤“::”与函数名称分隔。 例如，对于&lt;strong&gt;lab::detail&lt;/strong&gt; 名称空间中名为 &lt;strong&gt;foo()&lt;/strong&gt; 的函数，实现应如下所示：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;Readme.assets/image-20210804160428577.png&#34; alt=&#34;image-20210804160428577&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;一-流&#34;&gt;一. 流&lt;/h1&gt;
&lt;h2 id=&#34;11-std&#34;&gt;1.1 std&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;std::getline(输入流，string，终止符[可选])   &lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从输入流中获取一整行，可以是单个普通字符、&lt;strong&gt;空字符、制表符&lt;/strong&gt;和&lt;strong&gt;换行符&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;  std::string str;
  std::getline(std::cin, str);	// 将输入流作为参数传入
  std::getline(std::cin, str, &#39;,&#39;);	// 最后一个参数是终止字符，即读取到这个字符后结束
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;std::skipws&lt;/code&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;code&gt;std::noskipws&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义于头文件 &lt;code&gt;&amp;lt;ios&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;启用或禁用有格式输入函数所做的跳过前导空白符**（默认启用）**。在输出上无效果。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如同用调用 &lt;code&gt;str.setf([std::ios_base::skipws] &lt;/code&gt; &lt;strong&gt;启用&lt;/strong&gt;流 &lt;code&gt;str&lt;/code&gt; 中的 &lt;code&gt;skipws&lt;/code&gt; 标志&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如同用调用 &lt;code&gt;str.unsetf([std::ios_base::skipws]&lt;/code&gt; &lt;strong&gt;禁用&lt;/strong&gt;流 &lt;code&gt;str&lt;/code&gt; 中的 &lt;code&gt;skipws&lt;/code&gt; 标志**(会对整个流生效知道使用 &lt;code&gt;std::skipws&lt;/code&gt; 取消)**&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;sstream&amp;gt;
int main()
{
    char c1, c2, c3;
    std::istringstream(&amp;quot;a b c&amp;quot;) &amp;gt;&amp;gt; c1 &amp;gt;&amp;gt; c2 &amp;gt;&amp;gt; c3;
    std::cout &amp;lt;&amp;lt; &amp;quot;Default  behavior: c1 = &amp;quot; &amp;lt;&amp;lt; c1 &amp;lt;&amp;lt; &amp;quot; c2 = &amp;quot; &amp;lt;&amp;lt; c2 &amp;lt;&amp;lt; &amp;quot; c3 = &amp;quot; &amp;lt;&amp;lt; c3 &amp;lt;&amp;lt; &#39;\n&#39;;
  std::istringstream(&amp;quot;a b c&amp;quot;) &amp;gt;&amp;gt; std::noskipws &amp;gt;&amp;gt; c1 &amp;gt;&amp;gt; c2 &amp;gt;&amp;gt; c3;
    std::cout &amp;lt;&amp;lt; &amp;quot;noskipws behavior: c1 = &amp;quot; &amp;lt;&amp;lt; c1 &amp;lt;&amp;lt; &amp;quot; c2 = &amp;quot; &amp;lt;&amp;lt; c2 &amp;lt;&amp;lt; &amp;quot; c3 = &amp;quot; &amp;lt;&amp;lt; c3 &amp;lt;&amp;lt; &#39;\n&#39;;
}
=================================================================
输出：
Default  behavior: c1 = a c2 = b c3 = c
noskipws behavior: c1 = a c2 =   c3 = b
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;std::ws&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;剔除流中的&lt;strong&gt;空字符、制表符&lt;/strong&gt;和&lt;strong&gt;换行符&lt;/strong&gt;，直到匹配到非空字符，可使用 &lt;strong&gt;&lt;code&gt;std::noskipws&lt;/code&gt;&lt;/strong&gt; 将此禁用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int main()
{
    std::string str;
    std::cin &amp;gt;&amp;gt; std::ws &amp;gt;&amp;gt; str;	// 剔除str前面的所有空字符，当然在这里不用也行
    
    // 读取一串数字中的一个字母（使用空格分隔）
    // 比如：&amp;gt;&amp;gt;&amp;gt;    16468   f     23541
    int num1 = 0;
    int num2 = 0;
    char c_sign = &#39;\0&#39;;
    std::cin &amp;gt;&amp;gt; std::ws &amp;gt;&amp;gt; num1 &amp;gt;&amp;gt; std::ws &amp;gt;&amp;gt;  c_sign &amp;gt;&amp;gt; std::ws &amp;gt;&amp;gt; num2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12-iostream&#34;&gt;1.2 iostream&lt;/h2&gt;
&lt;h3 id=&#34;121-常用函数&#34;&gt;1.2.1 常用函数&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;所有流中未处理或读取的字符都会在缓冲区等待&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;头文件：&lt;code&gt;#include &amp;lt;iostream&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入和输出流都能够作为参数传递，除了在 main 函数（主进程中），其他的函数中的输入输出流都应该作为参数传入，而不应该直接使用 &lt;code&gt;std::cin&lt;/code&gt; 或者 &lt;code&gt;std::cout&lt;/code&gt; ，因为在引发异常时主线程必须能够将子线程中的流覆盖&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;

// 在函数中 istr 和 ostr 可以像 std::cin 和 std::cout 一样自由使用
void foo(int num, istream&amp;amp; istr, ostream&amp;amp; ostr)
{
    ostr &amp;lt;&amp;lt; &amp;quot;Please input one number: &amp;quot;;
    istr &amp;gt;&amp;gt; num;
    
    if (!istr.good() || !ostr.good())
    {
        // 抛出异常
	}
}

int main(int args, char * argv[])
{
    int num;
    
    // 将 std::cin 和 std::cout 从 main 函数中作为参数传入
    foo(num, std::cin, std::cout);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;std::cin &amp;lt;&amp;lt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入时自动跳过前置&lt;strong&gt;空字符&lt;/strong&gt;及&lt;strong&gt;空行&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;std::cin.get()&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从输入流中获取一个字符，这个字符可以是普通字符、&lt;strong&gt;空字符、制表符&lt;/strong&gt;和&lt;strong&gt;换行符&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;std::cin.peek()&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查看输入流中的下一个字符，但是不读取，这个字符可以是普通字符、&lt;strong&gt;空字符、制表符&lt;/strong&gt;和&lt;strong&gt;换行符&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;// 从输入流中读取一个字符，如果是字母 A 则读取读取并输出，如果不是则返回
void foo(istream&amp;amp; istr, ostream&amp;amp; ostr)
{
    char c_sign = &#39;\0&#39;;
    if (istr.peek() == &#39;A&#39;)
    {
        ostr &amp;lt;&amp;lt; istr.get();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;std::cin.ignore&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std::cin.ignore()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;从输入流中忽略一个字符&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std::cin.ignore(num, 终止字符)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;跳过输入流中n个字符，或在遇到指定的终止字符时提前结束（此时跳过包括终止字符在内的若干字符）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std::cin.ignore(numeric_limits&amp;lt;std::streamsize&amp;gt;::max(), ‘\n’)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;清除当前行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std::cin.ignore(numeric_limits&amp;lt;std::streamsize&amp;gt;::max())&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;清除 cin 里所有内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ignore(std::numeric_limits&amp;lt;std::streamsize&amp;gt;::max(), &#39;,&#39;)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;忽略逗号前面的所有内容&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;121-流状态标志&#34;&gt;1.2.1 流状态标志&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;std::ios_base::iostate&lt;/p&gt;
&lt;p&gt;https://zh.cppreference.com/w/cpp/io/ios_base/iostate&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;**&lt;code&gt;goodbit&lt;/code&gt;**无错误&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**&lt;code&gt;badbit&lt;/code&gt;**不可恢复的流错误&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**&lt;code&gt;failbit&lt;/code&gt;**输入/输出操作失败（格式化或提取错误）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**&lt;code&gt;eofbit&lt;/code&gt;**关联的输出序列已抵达文件尾&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相关函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;std::cin.fail()&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入/输出操作失败（格式化或提取错误）。比如 &lt;code&gt;int&lt;/code&gt; 类型的却读取了一个 &lt;code&gt;char&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;std::cin.good()&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入流无错误&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;std::cin.setstate(std::istream::failbit)&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将输入流设置为 &lt;code&gt;failbit&lt;/code&gt;，也可以是上面其他的 &lt;strong&gt;&lt;code&gt;goodbit&lt;/code&gt;&lt;/strong&gt;，&lt;strong&gt;&lt;code&gt;badbit&lt;/code&gt;&lt;/strong&gt;，&lt;strong&gt;&lt;code&gt;eofbit&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;13-string-stream&#34;&gt;1.3 string stream&lt;/h2&gt;
&lt;h3 id=&#34;131-常用方法&#34;&gt;1.3.1 常用方法&lt;/h3&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;将 std::cin 输入流中的内容导入到一个 stringstream 中，再处理这个 stringstream 而不是处理 std::cin 流&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int main()
{
  std::string str_line;
  std::getline(std::cin, str_line);
  std::stringstream str_stream(str_line);

  int num;
  str_stream &amp;gt;&amp;gt; num;	// 会像 std::cin 一样自动互忽略流中的空字符
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h1 id=&#34;二-c标准库&#34;&gt;二. C++标准库&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;重要的网站：&lt;/p&gt;
&lt;p&gt;www.cplusplus.com&lt;/p&gt;
&lt;p&gt;www.en.cppreference.com/w/&lt;/p&gt;
&lt;p&gt;www.gcc.gnu.org&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;21-前置知识&#34;&gt;2.1 前置知识&lt;/h2&gt;
&lt;p&gt;Q: 什么是&lt;code&gt;泛型编程&lt;/code&gt;？&lt;/p&gt;
&lt;p&gt;A: 所谓泛型编程，就是使用&lt;code&gt;template（模板）&lt;/code&gt;为主要工具来编程，STL就是泛型编程最成功的作品&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Q：什么是STL&lt;/p&gt;
&lt;p&gt;A：STL - Standard Template Library - 标准模板库&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;标准库以头文件的形式呈现，而不是编译好的，所以直接看到源代码&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C++的标准库的头文件不带拓展名&lt;code&gt;.h&lt;/code&gt;，例如 &lt;code&gt;#include &amp;lt;vector&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;新的C文件也不带&lt;code&gt;.h&lt;/code&gt;了，例如 &lt;code&gt;#include &amp;lt;cstdio&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;新的头文件里的组件都被封装在了 &lt;code&gt;namespace std&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;using namespace std&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;using std::cout&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;旧的头文件中的组件&lt;strong&gt;没有&lt;/strong&gt;封装在 &lt;code&gt;namespace std&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;STL六大部件（Components）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;容器（Containers）&lt;/li&gt;
&lt;li&gt;分配器（Allocators） - 为容器分配内存&lt;/li&gt;
&lt;li&gt;算法（Algorithms）&lt;/li&gt;
&lt;li&gt;迭代器（Iterators） - 类似于一个泛化指针&lt;/li&gt;
&lt;li&gt;适配器（Adapters）&lt;/li&gt;
&lt;li&gt;仿函数（Functors）&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201205185708070.png&#34; alt=&#34;image-20201205185708070&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;实例程序：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;functional&amp;gt;

int main()
{
	int arr[6] = { 21, 210, 100, 40, 56, 6 };
    //    ↓container      ↓allocator
    std::vector&amp;lt;int, allocator&amp;lt;int&amp;gt; &amp;gt; vec(arr, arr + 6);
    
    //           ↓algorithm     ↓iterator↓        ↓function adapter(negator)
    std::cout &amp;lt;&amp;lt; count_if(vec.begin(), vec.end(), not1(bind2nd(less&amp;lt;int&amp;gt;(), 40)));
    //                                            function object↑
    // 整个 not1(bind2nd(less&amp;lt;int&amp;gt;(), 40)) 是一个 谓词（predicate）
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;22-算法复杂度&#34;&gt;2.2 算法复杂度&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;O(1) or O(N)：常数时间（constant time）&lt;/li&gt;
&lt;li&gt;O(N)：线性时间（linear time）&lt;/li&gt;
&lt;li&gt;O(log2N)：二次线性时间（sub-liner time）&lt;/li&gt;
&lt;li&gt;O(N^2)：平方时间（quadratic time）&lt;/li&gt;
&lt;li&gt;O(N^3)：立方时间（cubic time）&lt;/li&gt;
&lt;li&gt;O(2^N)：指数时间（exponential time）&lt;/li&gt;
&lt;li&gt;O(Nlog2N)：介于线性及二次方的中间行为模式&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;23-oop-vs-gp&#34;&gt;2.3 OOP vs. GP&lt;/h2&gt;
&lt;h3 id=&#34;231-oop&#34;&gt;2.3.1 OOP&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201220235225378.png&#34; alt=&#34;image-20201220235225378&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;OOP&lt;/code&gt; - Object-Oriented programming&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OOP 企图将 数据(datas) 和 方法 (methods) 联系在一起&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;list&lt;/code&gt; 容器将许多方法和保存的数据保存到了一起&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;template&amp;lt;typename T&amp;gt;
class list
{
public:
    push_back(T data);
    push_frount(T data);
    ...
    ...
    sort();
	// Q: 考虑一下为什么 list 提供了自己的 sort 方法，而不是像其他容器一样可以随意的使用标准库提供的 			::sort 方法？
    // A: 因为 list 是一个双向链表，元素在内存上不是连续的，所以泛化指针不能随意的执行++、--等操作
private:
    T data_;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;232-gp&#34;&gt;2.3.2 GP&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201220235418794.png&#34; alt=&#34;image-20201220235418794&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;GP&lt;/code&gt; - Generic Programming&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GP 欲将  数据(datas) 和 方法 (methods) 分离&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这么做的好处有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;容器(Containers) &lt;strong&gt;和 &lt;strong&gt;算法(Algorithms)&lt;/strong&gt; 可以&lt;/strong&gt;分开设计，各尽其职&lt;/strong&gt;。然后&lt;strong&gt;之间使用迭代器(Iterator)沟通/链接&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;算法(Algorithms) 通过 迭代器(Iterator) 确定操作范围，并通过 迭代器(Iterator) 取用容器(Containers) 中的元素&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201221000016970.png&#34; alt=&#34;image-20201221000016970&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;24-操作符重载&#34;&gt;2.4 操作符重载&lt;/h2&gt;
&lt;p&gt;以下操作符不能重载：&lt;code&gt;::&lt;/code&gt;，&lt;code&gt;.&lt;/code&gt;， &lt;code&gt;.*&lt;/code&gt;，&lt;code&gt;?:&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&#34;三-容器&#34;&gt;三. 容器&lt;/h1&gt;
&lt;h2 id=&#34;31-容器的基本使用&#34;&gt;3.1 容器的基本使用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;前闭后开 [ )&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.begin()&lt;/code&gt; 指向容器中的第一个元素&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.end()&lt;/code&gt; 指向容器所有元素的下一个元素（不是容器的一部分）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;Container&amp;lt;T&amp;gt; c;
...
Container&amp;lt;T&amp;gt;::iterator it = c.begin();
for ( ; it &amp;lt; c.end(), ++it)
{
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C++ 11 新的迭代方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;range-based &lt;code&gt;for&lt;/code&gt; statement&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for ( 声明 : 容器 )
{
    ...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;for ( int i : { 21, 210, 100, 40, 56, 6 })
{
    std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;std::vector&amp;lt;double&amp;gt; vec;
...
for (auto elem : vec) // 在这里 auto 自动适配为 std::vector&amp;lt;double&amp;gt;::iterator
{
	std::cout &amp;lt;&amp;lt; elem &amp;lt;&amp;lt; std::endl; 
}

for (auto&amp;amp; elem : vec)
{
    elem *= 3;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C++11 &lt;code&gt;auto&lt;/code&gt; 关键字&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt; 为C++中的自动类型推导&lt;/p&gt;
&lt;p&gt;例如&lt;strong&gt;以往&lt;/strong&gt;的代码这么写：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;list&amp;lt;string&amp;gt; c;
...
list&amp;lt;string&amp;gt;::iterator it;
it = ::find(c.begin(), c.end(), target);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;如今可以更改为&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;list&amp;lt;string&amp;gt; c;
...
// 自动适配为 list&amp;lt;string&amp;gt;::iterator it
auto it = ::find(c.begin(), c.end(), target);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;容器不一定是连续的空间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;32-容器的基本使用&#34;&gt;3.2 容器的基本使用&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201206151434712.png&#34; alt=&#34; &#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;set&lt;/code&gt;的底层都是使用红黑树实现
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;map&lt;/code&gt;中单个节点包含 &lt;code&gt;key&lt;/code&gt;和&lt;code&gt;value&lt;/code&gt;，之后使用&lt;code&gt;key&lt;/code&gt;找&lt;code&gt;value&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set&lt;/code&gt; 的&lt;code&gt;key&lt;/code&gt;和&lt;code&gt;value&lt;/code&gt;是不分的，是一个东西&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;容器中带有**&lt;code&gt;multi&lt;/code&gt;** 的代表元素可以重复**（multi - 代表多）**，比如：&lt;code&gt;multiset&lt;/code&gt;和&lt;code&gt;multimap&lt;/code&gt;中的元素（&lt;code&gt;key&lt;/code&gt;）可以重复&lt;/li&gt;
&lt;li&gt;容器中带有**&lt;code&gt;unordered&lt;/code&gt;** 的代表底部使用了&lt;strong&gt;哈希表&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;所有的容器中，所有模板都有第二个参数 （vector&amp;lt;参数一，参数二&amp;gt;），第二个参数是一个&lt;code&gt;分配器&lt;/code&gt;&lt;/strong&gt;。如果不填写第二个参数，则使用默认的分配器&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201221150122003.png&#34; alt=&#34;image-20201221150122003&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;h3 id=&#34;321-array&#34;&gt;3.2.1 array&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201215185545057.png&#34; alt=&#34;image-20201215185545057&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;头文件：&lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;初始化：&lt;code&gt;array&amp;lt;类型, 数组大小&amp;gt; arr;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;arr.size()&lt;/code&gt; 返回数组的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr.front() &lt;/code&gt; 第一个元素的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr.back()&lt;/code&gt; 最后一个元素的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;arr.data()&lt;/code&gt; 第一个元素的&lt;strong&gt;地址&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;322-vector&#34;&gt;3.2.2 vector&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201215190852597.png&#34; alt=&#34;image-20201215190852597&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;描述：&lt;strong&gt;一端&lt;/strong&gt;开口的容器，会自动为容器提前分配空间（大约是1.5倍）。&lt;strong&gt;容器的大小/容量始终大于或等于容器中元素的个数&lt;/strong&gt;。注意，这个容器“成长”的过程是缓慢的，因为要在另一个区域重新开辟一块内存，然后将当前内存中的&lt;strong&gt;所有&lt;/strong&gt;元素一一拷贝过去&lt;/p&gt;
&lt;p&gt;头文件：&lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;初始化：&lt;code&gt;std::vector&amp;lt;类型&amp;gt; vec;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;vec.push_back()&lt;/code&gt; 将元素从尾部放入&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vec.size()&lt;/code&gt; 容器中真正的元素个数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vec.capacity()&lt;/code&gt; 容器的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vec.front()&lt;/code&gt; 返回容器中的第一个元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vec.back()&lt;/code&gt; 返回容器中最后一个元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vec.data()&lt;/code&gt; 容器的起始地址&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;323-list&#34;&gt;3.2.3 list&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201218091054364.png&#34; alt=&#34;image-20201218091054364&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;描述：双向链表&lt;/p&gt;
&lt;p&gt;头文件：&lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;初始化：&lt;code&gt;list&amp;lt;类型&amp;gt; l;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;l.size()&lt;/code&gt; 返回双向链表的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l.max_size()&lt;/code&gt; 返回双向链表的最大大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l.push_frount&lt;/code&gt; 头插&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l.push_back&lt;/code&gt; 尾插&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l.pop_frount&lt;/code&gt; 移除首元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l.pop_back&lt;/code&gt; 移除末元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l.front() &lt;/code&gt; 返回双向链表中第一个元素的内容&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l.back()&lt;/code&gt; 返回双向链表中最后一个元素的内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;l.sort()&lt;/code&gt; list 自己提供的排序算法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;324-forward_list&#34;&gt;3.2.4 forward_list&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201218210703251.png&#34; alt=&#34;image-20201218210703251&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;描述：单向链表&lt;/p&gt;
&lt;p&gt;头文件：&lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;初始化：&lt;code&gt;list&amp;lt;类型&amp;gt; f_l;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;无此方法：&lt;/strong&gt; &lt;em&gt;&lt;code&gt;f_l.size()&lt;/code&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f_l.max_size()&lt;/code&gt; 返回单向链表的最大大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;l.push_frount&lt;/code&gt; 头插&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f_l.pop_frount&lt;/code&gt; 移除首元素&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无此方法：&lt;/strong&gt; &lt;em&gt;&lt;code&gt;l.push_back&lt;/code&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f_l.front() &lt;/code&gt; 返回双向链表中第一个元素的内容&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;无此方法：&lt;/strong&gt; &lt;em&gt;&lt;code&gt;f_l.back()&lt;/code&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;f_l.sort()&lt;/code&gt; forward_list 自己提供的排序算法&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;325-slist&#34;&gt;3.2.5 slist&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;slist&lt;/code&gt; 是GUN标准下的（非标准库）一个单向链表，功能完全和标准库中的forward_list完全一样&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;326-deque&#34;&gt;3.2.6 deque&lt;/h3&gt;
&lt;p&gt;描述：duque是一个&lt;strong&gt;双向开口，可进可出&lt;/strong&gt;的容器。duque在内存中并不是连续的，连续只是一个假象。duque是有许多内存段中组合而成，&lt;strong&gt;一个内存段称为一个 &lt;code&gt;buffer&lt;/code&gt;&lt;/strong&gt; 。术语上称为：&lt;strong&gt;分段连续&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201218211839131.png&#34; alt=&#34;image-20201218211839131&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;头文件：&lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;初始化：&lt;code&gt;std::deque&amp;lt;类型&amp;gt; deq;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;deq.size()&lt;/code&gt; 目前deque容器的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deq.max_size()&lt;/code&gt; deque容器的最大大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deq.resize(N)&lt;/code&gt; 初始化N个元素到deque中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deq.at(N)&lt;/code&gt; 返回第N个元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deq.frount()&lt;/code&gt; 返回首元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deq.back()&lt;/code&gt; 返回末元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deq.pop_frount()&lt;/code&gt; 移除首元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;deq.pop_back()&lt;/code&gt; 移除末元素&lt;/li&gt;
&lt;li&gt;deque 没有提供自己的 sort&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;327-stack&#34;&gt;3.2.7 stack&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201218221718925.png&#34; alt=&#34;image-20201218221718925&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;描述：stack是栈 - &lt;strong&gt;先进后出&lt;/strong&gt;。因为容器的特性，所以不提供 &lt;code&gt;iterator&lt;/code&gt; 的操作&lt;/p&gt;
&lt;p&gt;头文件：&lt;code&gt;&amp;lt;stack&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;初始化：&lt;code&gt;std::stack&amp;lt;类型&amp;gt; s;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;s.size()&lt;/code&gt; 返回栈的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s.top()&lt;/code&gt; 返回栈顶元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s.push()&lt;/code&gt; 将元素推入栈中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s.pop()&lt;/code&gt; 将一个元素弹出栈&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;328-queue&#34;&gt;3.2.8 queue&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201218222040350.png&#34; alt=&#34;image-20201218222040350&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;描述：queue 是&lt;strong&gt;队列&lt;/strong&gt;，&lt;strong&gt;先进先出&lt;/strong&gt;。因为容器的特性，所以不提供 &lt;code&gt;iterator&lt;/code&gt; 的操作&lt;/p&gt;
&lt;p&gt;头文件：&lt;code&gt;&amp;lt;queue&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;初始化：&lt;code&gt;std::queue&amp;lt;类型&amp;gt; q;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;q.size()&lt;/code&gt; 返回队列的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;q.push()&lt;/code&gt; 将元素推入栈中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;q.front()&lt;/code&gt; 返回队手元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;q.back()&lt;/code&gt; 返回队尾元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;q.pop()&lt;/code&gt; 将一个元素弹出栈&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;329-multiset&#34;&gt;3.2.9 multiset&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201219173103348.png&#34; alt=&#34;image-20201219173103348&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;描述：小型的关联数据库，以**红黑树（高度平衡树）**形成的底层结构。&lt;strong&gt;允许出现重复元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;头文件：&lt;code&gt;&amp;lt;multiset&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;初始化：&lt;code&gt;multiset&amp;lt;类型&amp;gt; mul_set;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mul_set.insert()&lt;/code&gt; 插入一个元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mul_set.size()&lt;/code&gt; multiset 的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mul_set.max_size()&lt;/code&gt; multiset 能容纳的最多元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mul_set.find()&lt;/code&gt; 查找一个元素，并返回一个迭代器&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;set 和 map 的区别：&lt;/p&gt;
&lt;p&gt;set 容器的一个节点只能存储一个 &lt;strong&gt;value&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;map 可以的一个节点可以存储&lt;strong&gt;一个 key 和一个 value，并通过 key 来查找 value&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;3210-multimap&#34;&gt;3.2.10 multimap&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201219182902723.png&#34; alt=&#34;image-20201219182902723&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;描述：底层是一个红黑树,&lt;strong&gt;第一个参数是key，第二个参数是value&lt;/strong&gt;。multimap 不能使用 [] 做 insertion&lt;/p&gt;
&lt;p&gt;头文件：&lt;code&gt;&amp;lt;multimap&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初始化：&lt;code&gt;multimap&amp;lt;key的类型，value的类型&amp;gt; mul_map;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mul_map.insert()&lt;/code&gt; 插入一个元素&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;mul_map.insert(std::pair&amp;lt;key的类型，value的类型&amp;gt;(key值，value值))&lt;/code&gt; 插入一个元素&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mul_map.size()&lt;/code&gt; multimap 的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mul_map.max_size()&lt;/code&gt; multimap 能容纳的最多元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mul_map.find()&lt;/code&gt; 查找一个元素，并返回一个迭代器&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;3211-unordered_multiset&#34;&gt;3.2.11 unordered_multiset&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201219182923279.png&#34; alt=&#34;image-20201219182923279&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;描述：是一个关联式容器，&lt;strong&gt;底层是一个哈希表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;头文件：&lt;code&gt;&amp;lt;unordered_multiset&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;初始化：&lt;code&gt;unordered_multiset&amp;lt;类型&amp;gt; unor_mul_set;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unor_mul_set.insert()&lt;/code&gt; 插入一个元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unor_mul_set.size()&lt;/code&gt; multiset 的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unor_mul_set.max_size()&lt;/code&gt; multiset 能容纳的最多元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unor_mul_set.bucker_count()&lt;/code&gt; 因为底层是哈希表，所以此方法取得的是&lt;strong&gt;当前哈希表中篮子的数量&lt;/strong&gt;，并且&lt;strong&gt;篮子的数量一定比元素数量多&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unor_mul_set.max_bucker_count()&lt;/code&gt; 因为底层是哈希表，所以此方法取得的是&lt;strong&gt;哈希表中篮子的最大数量&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unor_mul_set.load_factor()&lt;/code&gt; 载重因子&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unor_mul_set.max_load_factor()&lt;/code&gt; 最大载重因子（一定是1）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unor_mul_set.find()&lt;/code&gt; 查找一个元素，并返回一个迭代器&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;3212-unordered_multimap&#34;&gt;3.2.12 unordered_multimap&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201219182934958.png&#34; alt=&#34;image-20201219182934958&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;描述：是一个关联式容器，底层是一个哈希表。multimap 不能使用 [] 做 insertion&lt;/p&gt;
&lt;p&gt;头文件：&lt;code&gt;&amp;lt;unordered_multimap&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初始化：&lt;code&gt;unordered_multimap&amp;lt;key的类型，value的类型&amp;gt; unord_mul_map;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unord_mul_map.insert()&lt;/code&gt; 插入一个元素&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;unord_mul_map.insert(std::pair&amp;lt;key的类型，value的类型&amp;gt;(key值，value值))&lt;/code&gt; 插入一个元素&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unord_mul_map.size()&lt;/code&gt; multiset 的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unord_mul_map.max_size()&lt;/code&gt; multiset 能容纳的最多元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unord_mul_map.find()&lt;/code&gt; 查找一个元素，并返回一个迭代器&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;3213-set&#34;&gt;3.2.13 set&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201219185139673.png&#34; alt=&#34;image-20201219185139673&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;描述：小型的关联数据库，以**红黑树（高度平衡树）**形成的底层结构。&lt;strong&gt;不允许出现重复元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;头文件：&lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;初始化：&lt;code&gt;set&amp;lt;类型&amp;gt; set;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;set.insert()&lt;/code&gt; 插入一个元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set.size()&lt;/code&gt; set 的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set.max_size()&lt;/code&gt; set 能容纳的最多元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set.find()&lt;/code&gt; 查找一个元素，并返回一个迭代器&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;3214-map&#34;&gt;3.2.14 map&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201219185147583.png&#34; alt=&#34;image-20201219185147583&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;描述：底层是一个红黑树，&lt;strong&gt;key 不能重复，value 可以重复&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;头文件：&lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初始化：&lt;code&gt;map&amp;lt;key的类型，value的类型&amp;gt; map;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;map.insert()&lt;/code&gt; 插入一个元素&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;map.insert(std::pair&amp;lt;key的类型，value的类型&amp;gt;(key值，value值))&lt;/code&gt; 插入一个元素&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;**&lt;code&gt;map[key] = value&lt;/code&gt; 在 key 处插入一个 value ** 重点！！！！！&lt;/li&gt;
&lt;li&gt;&lt;code&gt;map.size()&lt;/code&gt; map 的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;map.max_size()&lt;/code&gt; map 能容纳的最多元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mul_map.find()&lt;/code&gt; 查找一个元素，并返回一个迭代器&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;3216-unordered_set&#34;&gt;3.2.16 unordered_set&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201219181928071.png&#34; alt=&#34;image-20201219181928071&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;描述：&lt;strong&gt;底层是哈希表支撑的 set 容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;头文件：&lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;初始化：&lt;code&gt;unordered_set&amp;lt;类型&amp;gt; unord_set;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unord_set.insert()&lt;/code&gt; 插入一个元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unord_set.size()&lt;/code&gt; set 的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unord_set.max_size()&lt;/code&gt; set 能容纳的最多元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unor_set.bucker_count()&lt;/code&gt; 因为底层是哈希表，所以此方法取得的是&lt;strong&gt;当前哈希表中篮子的数量&lt;/strong&gt;，并且&lt;strong&gt;篮子的数量一定比元素数量多&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unor_set.max_bucker_count()&lt;/code&gt; 因为底层是哈希表，所以此方法取得的是&lt;strong&gt;哈希表中篮子的最大数量&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unor_set.load_factor()&lt;/code&gt; 载重因子&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unor_set.max_load_factor()&lt;/code&gt; 最大载重因子（一定是1）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set.find()&lt;/code&gt; 查找一个元素，并返回一个迭代器&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;3215-unordered_map&#34;&gt;3.2.15 unordered_map&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201219182440457.png&#34; alt=&#34;image-20201219182440457&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;描述：&lt;strong&gt;底层是哈希表支撑的 map 容器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;头文件：&lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初始化：&lt;code&gt;unordered_map&amp;lt;key的类型，value的类型&amp;gt; unord_map;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;unord_map.insert()&lt;/code&gt; 插入一个元素&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;unord_map.insert(std::pair&amp;lt;key的类型，value的类型&amp;gt;(key值，value值))&lt;/code&gt; 插入一个元素&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;**&lt;code&gt;unord_map[key] = value&lt;/code&gt; 在 key 处插入一个 value ** 重点！！！！！&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unord_map.size()&lt;/code&gt; map 的大小&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unord_map.max_size()&lt;/code&gt; map 能容纳的最多元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unord_map.find()&lt;/code&gt; 查找一个元素，并返回一个迭代器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;33-容器原码分析&#34;&gt;3.3 容器原码分析&lt;/h2&gt;
&lt;h3 id=&#34;331-array&#34;&gt;3.3.1 array&lt;/h3&gt;
&lt;h3 id=&#34;332-vector&#34;&gt;3.3.2 vector&lt;/h3&gt;
&lt;h3 id=&#34;333-list&#34;&gt;3.3.3 list&lt;/h3&gt;
&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201222095725501.png&#34; alt=&#34;image-20201222095725501&#34; style=&#34;zoom:80%;&#34; /&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201222101632401.png&#34; alt=&#34;image-20201222101632401&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201222103816861.png&#34; alt=&#34;image-20201222103816861&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201222104710288.png&#34; alt=&#34;image-20201222104710288&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201222104950584.png&#34; alt=&#34;image-20201222104950584&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201222105056295.png&#34; alt=&#34;image-20201222105056295&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;33&#34;&gt;3.3.&lt;/h3&gt;
&lt;h3 id=&#34;33-2&#34;&gt;3.3.&lt;/h3&gt;
&lt;h3 id=&#34;33-3&#34;&gt;3.3.&lt;/h3&gt;
&lt;h3 id=&#34;33-4&#34;&gt;3.3.&lt;/h3&gt;
&lt;h3 id=&#34;33-5&#34;&gt;3.3.&lt;/h3&gt;
&lt;h3 id=&#34;33-6&#34;&gt;3.3.&lt;/h3&gt;
&lt;h3 id=&#34;33-7&#34;&gt;3.3.&lt;/h3&gt;
&lt;h3 id=&#34;33-8&#34;&gt;3.3.&lt;/h3&gt;
&lt;h3 id=&#34;33-9&#34;&gt;3.3.&lt;/h3&gt;
&lt;hr&gt;
&lt;h1 id=&#34;四-模板&#34;&gt;四. 模板&lt;/h1&gt;
&lt;h2 id=&#34;41-类模板&#34;&gt;4.1 类模板&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201221034734013.png&#34; alt=&#34;image-20201221034734013&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;42-函数模板&#34;&gt;4.2 函数模板&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;34&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201221034747579.png&#34; alt=&#34;image-20201221034747579&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;函数模板不需要使用 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 告诉编译器使用的类型&lt;/strong&gt;，因为有自动类型推导。但是类模板不行，如果不提供模板参数，编译器无法确定类型&lt;/p&gt;
&lt;h2 id=&#34;43-成员模板&#34;&gt;4.3 成员模板&lt;/h2&gt;
&lt;p&gt;后续补充&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;35&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201221050407143.png&#34; alt=&#34;image-20201221050407143&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;44-模板的泛化与特化&#34;&gt;4.4 模板的泛化与特化&lt;/h2&gt;
&lt;p&gt;解释什么是泛化与特化：&lt;/p&gt;
&lt;p&gt;​	想象一下，在STL中是提供了模板，模板用于匹配参数类型。但是基础的数据类型中有 &lt;code&gt;int&lt;/code&gt;，&lt;code&gt;float&lt;/code&gt;，&lt;code&gt;double&lt;/code&gt;，&lt;code&gt;char&lt;/code&gt; 等类型，在模板自动匹配类型后如何对这些不同的类型进行操作和处理呢；其实在STL的内部已经把各种基础类型的功能或方法一一手动实现了（按各个类型最优的方式，时间或空间效率高），这些一一实现就称之为&lt;strong&gt;模板的特化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;​	泛化 - 顾名思义，就指的是一个总体的大的分类。&lt;/p&gt;
&lt;p&gt;​	特化 - 就是对这个总的大的分类进行一一具体的实现&lt;/p&gt;
&lt;p&gt;​	比如：&lt;code&gt;猫&lt;/code&gt; 是一个总称，对于会捉老鼠，喵喵叫的我们都可以称之为&lt;code&gt;猫&lt;/code&gt;。这是一个大体的分类，所以称之为**&lt;code&gt;泛化&lt;/code&gt;&lt;strong&gt;；但是猫又分为橘猫、蓝猫、中华田园猫、俄罗斯无毛猫 等等，假如我现在要写文章介绍这各个品种的猫的特点和生活习性，那么，因为我们对这些猫各自的特点和生活习惯的描述具体到了某一品种，所以就称之为&lt;/strong&gt;&lt;code&gt;特化&lt;/code&gt;**&lt;/p&gt;
&lt;hr&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;36&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201221050644237.png&#34; alt=&#34;image-20201221050644237&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;关于特化和泛化写法的记忆：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未特化的模板写法和平时一样&lt;/li&gt;
&lt;li&gt;对于特化的模板就像：把原本首行 &lt;code&gt;template&amp;lt;typename T&amp;gt;&lt;/code&gt; 中的 &lt;code&gt;T&lt;/code&gt; 拿出来了，放在了类名的后方(橘色方框的部分)，以表示对具体类型进行特化。所以说，原本的 &lt;code&gt;template&amp;lt;typename T&amp;gt;&lt;/code&gt; 的 &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 为空了，变成了 &lt;code&gt;template&amp;lt;&amp;gt;&lt;/code&gt; (黄色方框部分)&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;以下是STL库中的几种泛化和特化的实现：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其中 &lt;code&gt;__STL_TEMPLATE_NULL&lt;/code&gt; 是一个 &lt;code&gt;#define&lt;/code&gt;，其实就是 &lt;code&gt;template&amp;lt;&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;37&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201221053125192.png&#34; alt=&#34;image-20201221053125192&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;38&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201221053155758.png&#34; alt=&#34;image-20201221053155758&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;45-局部特化偏特化&#34;&gt;4.5 局部特化（偏特化）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;对于拥有&lt;strong&gt;多个模板参数&lt;/strong&gt;的类或者函数可以进行&lt;strong&gt;局部特化&lt;/strong&gt;，即对某一个模板参数进行特化&lt;/li&gt;
&lt;li&gt;对于拥有&lt;strong&gt;一个模板参数&lt;/strong&gt;的类或者函数可以进行&lt;strong&gt;局部特化&lt;/strong&gt;，即对模板参数的 &lt;em&gt;&lt;code&gt;&amp;lt;T*&amp;gt;&lt;/code&gt; (指针类型)&lt;/em&gt; 或者 &lt;em&gt;&lt;code&gt;&amp;lt;const T*&amp;gt;&lt;/code&gt; (const指针)&lt;/em&gt; 进行特化&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;39&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201221053827841.png&#34; alt=&#34;image-20201221053827841&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;五-分配器-allocator&#34;&gt;五. 分配器 - allocator&lt;/h1&gt;
&lt;h2 id=&#34;51-基本说明&#34;&gt;5.1 基本说明&lt;/h2&gt;
&lt;p&gt;分配器支持了容器对内存的使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所有内存的分配动作，最后都会涉及到 &lt;code&gt;malloc&lt;/code&gt; 操作。然后 &lt;code&gt;malloc&lt;/code&gt; 根据不同的操作系统来申请内存&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;40&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201219185923398.png&#34; alt=&#34;image-20201219185923398&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;41&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201220204737370.png&#34; alt=&#34;image-20201220204737370&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;52-基本使用&#34;&gt;5.2 基本使用&lt;/h2&gt;
&lt;p&gt;头文件 &lt;code&gt;&amp;lt;memory&amp;gt;&lt;/code&gt; 里包含了 allocator&lt;/p&gt;
&lt;p&gt;但是如果使用 std::allocator 以外的 allocator，需要自行 &lt;code&gt;#include &amp;lt;ext\...&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意：其他的分配器是在 &lt;strong&gt;&lt;code&gt;__gnu_cxx::&lt;/code&gt;&lt;/strong&gt; 下的&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;#include &amp;lt;ext\array_allocator.h&amp;gt;
#include &amp;lt;ext\mt_allocator.h&amp;gt;
#include &amp;lt;ext\debug_allocator.h&amp;gt;
#include &amp;lt;ext\pool_allocator.h&amp;gt;		// 内存池
#include &amp;lt;ext\bitmap_allocator.h&amp;gt;
#include &amp;lt;ext\malloc_allocator.h&amp;gt;
#include &amp;lt;ext\new_allocator.h&amp;gt;

void test_list_with_special_allocator()
{
	list&amp;lt;std::string, allocator&amp;lt;std::string&amp;gt; &amp;gt; c1;
    list&amp;lt;std::string, __gnu_cxx::malloc_allocator&amp;lt;std::string&amp;gt; &amp;gt; c2;
    list&amp;lt;std::string, __gnu_cxx::new_allocator&amp;lt;std::string&amp;gt; &amp;gt; c3;
    list&amp;lt;std::string, __gnu_cxx::__pool_allocator&amp;lt;std::string&amp;gt; &amp;gt; c4;
    list&amp;lt;std::string, __gnu_cxx::__mt_allocator&amp;lt;std::string&amp;gt; &amp;gt; c5;
    list&amp;lt;std::string, __gnu_cxx::bitmap_allocator&amp;lt;std::string&amp;gt; &amp;gt; c6;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;42&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201220204913799.png&#34; alt=&#34;image-20201220204913799&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;使用分配器分配并归还内存&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-cpp&#34;&gt;int* p;		// 注意：p 是一个 int 类型的**指针**

allocator&amp;lt;int&amp;gt; alloc1;
p = alloc1.allocator(1);	// 1 代表申请一份内存
alloc1.deallocator(p, 1);	// 1 代表归还一份内存, p 代表归还的对象是谁。
							// 可以通过 new 和 delete 来理解

__gnu_cxx::malloc_allocator&amp;lt;int&amp;gt; alloc2;
p = alloc2.allocator(1);
alloc2.deallocate(p, 1);

__gnu_cxx::new_allocator&amp;lt;int&amp;gt; alloc3;
p = alloc3.allocator(1);
alloc3.allocator(p, 1);

__gnu_cxx::__pool_allocator&amp;lt;int&amp;gt; alloc4;
p = alloc4.allocator(1);
alloc4.allocator(p, 1);

__gnu_cxx::__mt_allocator&amp;lt;int&amp;gt; alloc5;
p = alloc5.allocator(1);
alloc5.allocator(p, 1);

__gnu_cxx::bitmap_allocator&amp;lt;int&amp;gt; alloc6;
p = alloc6.allocator(1);
alloc6.allocator(p, 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;53-解析&#34;&gt;5.3 解析&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;43&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201221081026072.png&#34; alt=&#34;image-20201221081026072&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;531-vc6-stl-对-allocator-的使用&#34;&gt;5.3.1 VC6 STL 对 allocator 的使用&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;44&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201221140244647.png&#34; alt=&#34;image-20201221140244647&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;45&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201221140403407.png&#34; alt=&#34;image-20201221140403407&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;532-bc5-stl-对-allocator-的使用&#34;&gt;5.3.2 BC5 STL 对 allocator 的使用&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;46&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201221140519806.png&#34; alt=&#34;image-20201221140519806&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;533-g29-对-allocator-的使用&#34;&gt;5.3.3 G2.9 对 allocator 的使用&lt;/h3&gt;
&lt;p&gt;一下虽然实现了 allocator，但是没有包含在任何容器中。也不建议使用&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;47&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201221140707011.png&#34; alt=&#34;image-20201221140707011&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;以下是 G2.9 STL 中使用内存池对分配器(allocator)的实现，推荐使用。因为能节省大量在申请内存时不必要浪费的空间&lt;/p&gt;
&lt;p&gt;在 G2.9 STL 中称之为 &lt;strong&gt;&lt;code&gt;alloc&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;48&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201221141106421.png&#34; alt=&#34;image-20201221141106421&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;49&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201221141139759.png&#34; alt=&#34;image-20201221141139759&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;50&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201221142010844.png&#34; alt=&#34;image-20201221142010844&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;51&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201221142043934.png&#34; alt=&#34;image-20201221142043934&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;534-sizeof迭代器&#34;&gt;5.3.4 sizeof(迭代器)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;52&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201221142238414.png&#34; alt=&#34;image-20201221142238414&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;六-萃取机-trait&#34;&gt;六. 萃取机 - trait&lt;/h1&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;53&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201226201348707.png&#34; alt=&#34;image-20201226201348707&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;iterator_category&lt;/code&gt; iterator 的类型&lt;/li&gt;
&lt;li&gt;&lt;code&gt;difference_type&lt;/code&gt; 两个 iterator 之间的距离&lt;/li&gt;
&lt;li&gt;&lt;code&gt;value_type&lt;/code&gt; iterator (迭代器)指向的那个东西的类型&lt;/li&gt;
&lt;li&gt;剩余的两种 &lt;code&gt;reference&lt;/code&gt; 和 &lt;code&gt;pointer&lt;/code&gt; 未在标准库中使用过&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;54&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201226202806858.png&#34; alt=&#34;image-20201226202806858&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;指针是一种退化的Iterator，Iterator 是一种泛化的指针&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;55&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201227190003769.png&#34; alt=&#34;image-20201227190003769&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;56&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201227190019885.png&#34; alt=&#34;image-20201227190019885&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;57&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201227190031977.png&#34; alt=&#34;image-20201227190031977&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;58&#34;&gt;&lt;img src=&#34;https://github.com/NekoSilverFox/CPP/blob/master/images/image-20201227190044824.png&#34; alt=&#34;image-20201227190044824&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h1 id=&#34;标准库算法&#34;&gt;标准库算法&lt;/h1&gt;
&lt;p&gt;头文件：&lt;code&gt;&amp;lt;algorithm&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;功能：&lt;/p&gt;
&lt;p&gt;复杂度：&lt;/p&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;p&gt;描述：&lt;/p&gt;
&lt;p&gt;返回值：&lt;/p&gt;
&lt;h2 id=&#34;查找&#34;&gt;查找&lt;/h2&gt;
&lt;h3 id=&#34;find&#34;&gt;find&lt;/h3&gt;
&lt;p&gt;头文件：&lt;code&gt;&amp;lt;algorithm&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;功能：查找元素，循序查找法&lt;/p&gt;
&lt;p&gt;复杂度：&lt;/p&gt;
&lt;p&gt;定义：find(起始迭代器, 结束迭代器, 谓词)&lt;/p&gt;
&lt;p&gt;描述：对容器内的元素进行&lt;strong&gt;线性&lt;/strong&gt;查找&lt;/p&gt;
&lt;p&gt;返回值：指向该元素的&lt;strong&gt;迭代器&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;bsearch&#34;&gt;bsearch&lt;/h3&gt;
&lt;p&gt;头文件：&lt;code&gt;&amp;lt;algorithm&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;功能：二分查找（C标准库）&lt;/p&gt;
&lt;p&gt;复杂度：&lt;/p&gt;
&lt;p&gt;定义：bseach(谓词，容器起始地址，容器大小，单位元素大小);&lt;/p&gt;
&lt;p&gt;描述：对容器内的元素进行&lt;strong&gt;二分&lt;/strong&gt;查找，但是注意，&lt;strong&gt;只能对有序容器进行查找&lt;/strong&gt;，所以说使用前要对容器进行排序&lt;/p&gt;
&lt;p&gt;返回值：指向该元素的&lt;strong&gt;迭代器&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;排序&#34;&gt;排序&lt;/h2&gt;
&lt;h3 id=&#34;sort&#34;&gt;sort&lt;/h3&gt;
&lt;p&gt;头文件：&lt;code&gt;&amp;lt;algorithm&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;功能：对容器进行排序&lt;/p&gt;
&lt;p&gt;复杂度：&lt;em&gt;O(N·log(N))&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;定义：sort(起始迭代器, 结束迭代器)&lt;/p&gt;
&lt;p&gt;描述：默认进行升序排序&lt;/p&gt;
&lt;p&gt;返回值：&lt;/p&gt;
&lt;h1 id=&#34;其他函数&#34;&gt;其他函数&lt;/h1&gt;
&lt;h2 id=&#34;程序终止&#34;&gt;程序终止&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://en.cppreference.com/w/cpp/utility/program/_Exit&#34;&gt;&lt;code&gt;std::_Exit&lt;/code&gt; &lt;/a&gt;导致正常程序终止，仅此而已。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.cppreference.com/w/cpp/utility/program/quick_exit&#34;&gt;&lt;code&gt;std::quick_exit&lt;/code&gt; &lt;/a&gt;导致正常程序终止并调用&lt;a href=&#34;http://en.cppreference.com/w/cpp/utility/program/at_quick_exit&#34;&gt; &lt;code&gt;std::at_quick_exit&lt;/code&gt; &lt;/a&gt;处理程序，不执行其他任何清除操作。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.cppreference.com/w/cpp/utility/program/exit&#34;&gt;&lt;code&gt;std::exit&lt;/code&gt; &lt;/a&gt;导致正常程序终止，然后调用&lt;a href=&#34;http://en.cppreference.com/w/cpp/utility/program/atexit&#34;&gt; &lt;code&gt;std::atexit&lt;/code&gt; &lt;/a&gt;处理程序。执行其他类型的清除，例如调用静态对象析构函数。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.cppreference.com/w/cpp/utility/program/abort&#34;&gt;&lt;code&gt;std::abort&lt;/code&gt; &lt;/a&gt;导致程序异常终止，不执行任何清理。如果程序以非常非常意外的方式终止，则应调用此方法。它只会通知操作系统有关异常终止的任何信息。在这种情况下，某些系统会执行核心转储。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://en.cppreference.com/w/cpp/error/terminate&#34;&gt;&lt;code&gt;std::terminate&lt;/code&gt; &lt;/a&gt;调用&lt;a href=&#34;http://en.cppreference.com/w/cpp/error/terminate_handler&#34;&gt; &lt;code&gt;std::terminate_handler&lt;/code&gt; &lt;/a&gt;，默认情况下调用&lt;a href=&#34;http://en.cppreference.com/w/cpp/utility/program/abort&#34;&gt; &lt;code&gt;std::abort&lt;/code&gt; &lt;/a&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;stdabort&#34;&gt;std::abort&lt;/h3&gt;
&lt;p&gt;定义于头文件 &lt;code&gt;&amp;lt;cstdlib&amp;gt; &lt;/code&gt; - void abort();&lt;/p&gt;
&lt;p&gt;导致不正常程序终止，除非传递给 &lt;a href=&#34;https://zh.cppreference.com/w/cpp/utility/program/signal&#34;&gt;std::signal&lt;/a&gt; 的信号处理函数正在捕捉 &lt;a href=&#34;https://zh.cppreference.com/w/cpp/utility/program/SIG_types&#34;&gt;SIGABRT&lt;/a&gt; ，且该处理函数不返回。&lt;/p&gt;
&lt;p&gt;不调用拥有自动、线程局域 (C++11 起)和静态&lt;a href=&#34;https://zh.cppreference.com/w/cpp/language/storage_duration&#34;&gt;存储期&lt;/a&gt;的对象的析构函数。亦不调用以 &lt;a href=&#34;https://zh.cppreference.com/w/cpp/utility/program/atexit&#34;&gt;std::atexit()&lt;/a&gt; 和 &lt;a href=&#34;https://zh.cppreference.com/w/cpp/utility/program/at_quick_exit&#34;&gt;std::at_quick_exit&lt;/a&gt; (C++11 起) 注册的函数。是否关闭打开的资源，例如文件是实现定义的。返回给宿主环境指示不成功执行的实现定义状态。&lt;/p&gt;
">CPP相关</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/linux-gong-ju/"" data-c="
          &lt;h1 id=&#34;linux工具&#34;&gt;&lt;a href=&#34;http://man.linuxde.net/par/2&#34;&gt;Linux工具&lt;/a&gt;&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux下还是有很多超棒的开发工具的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Linux日常使用中，最常用的命令自然是sudo, ls, cp, mv, cat等，但作为后台开发者，上述命令远远不够。从我的理解来看，合格的C/C++开发者至少需要从开发及调试工具、文件处理、性能分析、网络工具四个方面针对性使用一些开发工具。这里我罗列了一些，大部分都是开发中经常需要使用的命令，有些功能比较简单的命令我会给出一些基本用法，有些本身自带体系（比如vim, gdb等）的命令只能附上链接了。&lt;/p&gt;
&lt;p&gt;开发及调试工具介绍了从“编辑 -&amp;gt; 编译 -&amp;gt; 分析目标文件 -&amp;gt; 追踪调用过程”的全套命令，文件处理部分介绍了查找、统计、替换等基本文本操作命令，性能分析介绍了查看进程信息、CPU负载、I/O负载、内存使用情况等基本命令，网络工具介绍了可以查看“链路层 -&amp;gt; 网络层 -&amp;gt; 传输层 -&amp;gt; 应用层”信息的工具。除此以外，其他命令中也列出了开发者经常会用到的一些命令，基本可以满足日常开发需要。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&#34;目录&#34;&gt;目录&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 4&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 5&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;#pro&#34;&gt;开发及调试&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;#file&#34;&gt;文件处理&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;#sysinfo&#34;&gt;性能分析&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;#net&#34;&gt;网络工具&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;#other&#34;&gt;其他&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;开发及调试&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编辑器：vim&lt;/li&gt;
&lt;li&gt;编译器：gcc/g++&lt;/li&gt;
&lt;li&gt;调试工具：gdb&lt;/li&gt;
&lt;li&gt;查看依赖库：ldd&lt;/li&gt;
&lt;li&gt;二进制文件分析：objdump&lt;/li&gt;
&lt;li&gt;ELF文件格式分析：readelf&lt;/li&gt;
&lt;li&gt;跟踪进程中系统调用：strace&lt;/li&gt;
&lt;li&gt;跟踪进程栈：pstack&lt;/li&gt;
&lt;li&gt;进程内存映射：pmap&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件处理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件查找：find&lt;/li&gt;
&lt;li&gt;文本搜索：grep&lt;/li&gt;
&lt;li&gt;排序：sort&lt;/li&gt;
&lt;li&gt;转换：tr&lt;/li&gt;
&lt;li&gt;按列切分文本：cut&lt;/li&gt;
&lt;li&gt;按列拼接文本：paste&lt;/li&gt;
&lt;li&gt;统计行和字符：wc&lt;/li&gt;
&lt;li&gt;文本替换：sed&lt;/li&gt;
&lt;li&gt;数据流处理：awk&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;性能分析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程查询：ps&lt;/li&gt;
&lt;li&gt;进程监控：top&lt;/li&gt;
&lt;li&gt;打开文件查询：lsof&lt;/li&gt;
&lt;li&gt;内存使用量：free&lt;/li&gt;
&lt;li&gt;监控性能指标：sar&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网络工具&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网卡配置：ifconfig&lt;/li&gt;
&lt;li&gt;查看当前网络连接：netstat&lt;/li&gt;
&lt;li&gt;查看路由表：route&lt;/li&gt;
&lt;li&gt;检查网络连通性：ping&lt;/li&gt;
&lt;li&gt;转发路径：traceroute&lt;/li&gt;
&lt;li&gt;网络Debug分析：nc&lt;/li&gt;
&lt;li&gt;命令行抓包：tcpdump&lt;/li&gt;
&lt;li&gt;域名解析工具：dig&lt;/li&gt;
&lt;li&gt;网络请求：curl&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;终止进程：kill&lt;/li&gt;
&lt;li&gt;修改文件权限：chmod&lt;/li&gt;
&lt;li&gt;创建链接：ln&lt;/li&gt;
&lt;li&gt;显示文件尾：tail&lt;/li&gt;
&lt;li&gt;版本控制：git&lt;/li&gt;
&lt;li&gt;设置别名：alias&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&#34;内容&#34;&gt;内容&lt;/h1&gt;
&lt;h3 id=&#34;span-id-pro开发及调试span&#34;&gt;&lt;span id = &#34;pro&#34;&gt;开发及调试&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;开发工具大部分都提供了完善的功能，所以这里不一一列举用法。从技术层面来说，调试工具比开发工具更考验一个人的工程能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;编辑器：vim&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器端开发必知必会，功能强大，这里不一一列举，但基本的打开文件、保存退出要会。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://coolshell.cn/articles/5426.html&#34;&gt;详见&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译器：gcc/g++&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C/C++编译器，必知必会，除此以外需要了解预处理-&amp;gt; 编译 -&amp;gt; 汇编 -&amp;gt; 链接等一系列流程。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/lidan/archive/2011/05/25/2239517.html&#34;&gt;详见&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调试工具：gdb&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务器端调试必备。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/gdb.html&#34;&gt;详见&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看依赖库：ldd&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序依赖库查询&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# ldd后接可执行文件
# 第一列为程序依赖什么库，第二列为系统提供的与程序需要的库所对应的库，第三列为库加载的开始地址
# 前两列可以判断系统提供的库和需要的库是否匹配，第三列可以知道当前库在进程地址空间中对应的开始位置

ldd a.out
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二进制文件分析：objdump&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;反汇编，需要理解汇编语言&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://man.linuxde.net/objdump&#34;&gt;详见&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ELF文件格式分析：readelf&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以得到ELF文件各段内容，分析链接、符号表等需要用到&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/readelf.html&#34;&gt;详见&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跟踪进程中系统调用：strace&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/strace.html&#34;&gt;详见&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跟踪进程栈：pstack&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/pstack.html#&#34;&gt;详见&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程内存映射：pmap&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显示进程内存映射&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# -x显示扩展信息，后接进程pid
# Address: 内存开始地址
# 显示信息：
    Kbytes: 占用内存的字节数
    RSS: 保留内存的字节数
    Dirty: 脏页的字节数（包括共享和私有的）
    Mode: 内存的权限：read、write、execute、shared、private
    Mapping: 占用内存的文件、或[anon]（分配的内存）、或[stack]（堆栈）
    Device: 设备名 (major:minor)

pmap -x 12345
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;span-id-file文件处理span&#34;&gt;&lt;span id = &#34;file&#34;&gt;文件处理&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Everything is file. 在Linux环境下，对文本处理相当频繁，所以有些命令的参数还是需要记忆的。另外其他很多命令的输出信息都需要通过文件处理命令来筛选有用信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;文件查找：find&lt;/p&gt;
&lt;p&gt;按名查找：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查找具体文件（一般方式）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;find . -name *.cpp
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查找具体文件（正则方式）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# -regex为正则查找，-iregex为忽略大小写的正则查找 

find -regex &amp;quot;.*.cpp$&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;定制查找：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按类型查找&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# f(file)为文件，d(dictionary)为目录，l(link)为链接

find . -type f
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;按时间查找&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# atime为访问时间，x天内加参数&amp;quot;-atime -x&amp;quot;，超过x天加&amp;quot;-atime -x&amp;quot;
# mtime为修改时间

find . -type f -atime -7
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;按大小查找&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# -size后接文件大小，单位可以为k(kb)，m(MB)，g(GB)

find . -type f -size -1k
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;按权限查询&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# -perm后接权限

find . -type -perm 644
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文本搜索：grep&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;模式匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 匹配test.cpp文件中含有&amp;quot;iostream&amp;quot;串的内容

grep &amp;quot;iostream&amp;quot; test.cpp  
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;多个模式匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 匹配test.cpp文件中含有&amp;quot;iostream&amp;quot;和&amp;quot;using&amp;quot;串的内容

grep -e &amp;quot;using&amp;quot; -e &amp;quot;iostream&amp;quot; test.cpp  
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;输出信息&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# -n为打印匹配的行号；-i搜索时忽略大小写；-c统计包含文本次数

grep -n &amp;quot;iostream&amp;quot; test.cpp  
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;排序：sort&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件内容行排序&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 排序在内存进行，不改变文件
# -n(number)表示按数字排序，-d(dictionary)表示按字典序
# -k N表示按各行第N列进行排序
# -r(reverse)为逆序排序

sort -n -k 1 test
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;转换：tr&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符替换&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 转换在内存进行，不改变文件
# 将打开文件中所有目标字符替换

cat test | tr &#39;1&#39; &#39;2&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;字符删除&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 转换在内存进行，不改变文件
# -d删除(delete)

cat test | tr -d &#39;1&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;字符压缩&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 转换在内存进行，不改变文件
# -s位于后部

cat test | tr &#39; &#39; -s
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按列切分文本：cut&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;截取特定列&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 截取的内存进行，不改变文件
# -b(byte)以字节为单位，-c(character)以字符为单位，-f以字段为单位
# 数字为具体列范围

cut -f 1,2 test
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;指定界定符&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 截取的内存进行，不改变文件
# -d后接界定符

cut -f 2 -d &#39;,&#39; new
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按列拼接文本：paste&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按列拼接&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 在内存中拼接，不改变文件
# 将两个文件按对应列拼接
# 最后加上-d &amp;quot;x&amp;quot;会将x作为指定分隔符（paste test1 test2 -d &amp;quot;,&amp;quot;）
# 两文件列数可以不同 

paste test1 test2
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;指定界定符拼接&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 在内存中拼接，不改变文件
# 按照-d之后给出的界定符拼接

paste test1 test2 -d &amp;quot;,&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统计行和字符：wc&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本统计&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# -l统计行数(line)，-w统计单词数(word)，-c统计字符数(character)

wc -l test
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文本替换：sed&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;区别于上面的命令，sed是可以直接改变被编辑文件内容的。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://coolshell.cn/articles/9104.html&#34;&gt;详见&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据流处理：awk&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;区别于上面的命令，awk是可以直接改变被编辑文件内容的。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://coolshell.cn/articles/9070.html&#34;&gt;详见&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;span-id-sysinfo系统信息span&#34;&gt;&lt;span id = &#34;sysinfo&#34;&gt;系统信息&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;性能监视工具对于程序员的作用就像是听诊器对于医生的作用一样。系统信息主要针对于服务器性能较低时的排查工作，主要包括CPU信息，文件I/O和内存使用情况，通过进程为纽带得到系统运行的瓶颈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;进程查询：ps&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看正在运行进程&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 常结合grep筛选信息(e.g, ps -ef | grep xxx)

ps -ef
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;以完整格式显示所有进程&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 常结合grep筛选信息

ps -ajx
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程监控：top&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显示实时进程信息&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 这是个大招，都不带参数的，具体信息通过grep筛选
# 交互模式下键入M进程列表按内存使用大小降序排列，键入P进程列表按CPU使用大小降序排列
# %id表示CPU空闲率，过低表示可能存在CPU存在瓶颈
# %wa表示等待I/O的CPU时间百分比，过高则I/O存在瓶颈 &amp;gt; 用iostat进一步分析

top
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打开文件查询：lsof&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看占用某端口的进程&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 最常见的就是mysql端口被占用使用(lsof i:3307)
# 周知端口(ftp:20/21, ssh:22, telnet:23, smtp:25, dns:53, http:80, pop3:110, https:443)

lsof -i:53
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看某用户打开的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# -u(user)为用户，后接用户名

lsof -u inx
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看指定进程打开的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# -p(process)为进程，后接进程PID

lsof -p 12345
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查看指定目录下被进程打开的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 这里是&amp;quot;+d&amp;quot;，需要注意，使用&amp;quot;+D&amp;quot;递归目录

lsof +d /test
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存使用量：free&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存使用量&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 可获得内存及交换区的总量，已使用量，空闲量等信息

free
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;监控性能指标：sar&lt;/p&gt;
&lt;p&gt;监控CPU&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;监控CPU负载&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 加上-q可以查看运行队列中进程数，系统上进程大小，平均负载等
# 这里&amp;quot;1&amp;quot;表示采样时间间隔是1秒，这里&amp;quot;2&amp;quot;表示采样次数为2

sar -q 1 2
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;监控CPU使用率&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 可以显示CPU使用情况
# 参数意义同上

sar -u 1 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;监控内存&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查询内存&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 可以显示内存使用情况
# 参数意义同上 

sar -r 1 2
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;页面交换查询&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 可以查看是否发生大量页面交换，吞吐率大幅下降时可用
# 参数意义同上

sar -W 1 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;span-id-net网络工具span&#34;&gt;&lt;span id = &#34;net&#34;&gt;网络工具&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;网络工具部分只介绍基本功能，参数部分一笔带过。这部分重点不在于工具的使用而是对反馈的数据进行解读，并且这部分命令功能的重合度还是比较高的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;网卡配置（链路层）：ifconfig&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;显示设备信息&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 可以显示已激活的网络设备信息

ifconfig
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;启动关闭指定网卡&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 前一个参数为具体网卡，后一个为开关信息
# up为打开，down为关闭

ifconfig eth0 up
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;配置IP地址&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 前一个参数为具体网卡，后一个为配置的IP地址

ifconfig eth0 192.168.1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;设置最大传输单元&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;前一个参数为具体网卡，后面为MTU的大小
# 设置链路层MTU值，通常为1500

ifconfig eth0 mtu 1500
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;启用和关闭ARP协议&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# 开启arp如下，若关闭则-arp

ifconfig eth0 arp
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看当前网络连接（链路层/网络层/传输层）：netstat&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络接口信息&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 显示网卡信息，可结合ifconfig学习

netstat -i
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;列出端口&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# -a(all)表示所有端口，-t(tcp)表示所有使用中的TCP端口
# -l(listening)表示正在监听的端口

netstat -at
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;显示端口统计信息&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# -s(status)显示各协议信息
# -加上-t(tcp)显示tcp协议信息，加上-u(udp)显示udp协议信息

netstat -s
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;显示使用某协议的应用名&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# -p(progress)表示程序，可以显示使用tcp/udp协议的应用的名称

netstat -pt
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;查找指定进程、端口&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 互逆操作第一个显示某程序使用的端口号，第二个显示某端口号的使用进程
# 第二个操作可以用lsof替代

netstat -ap | grep ssh
netstat -an | grep &#39;:80&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看路由表（网络层IP协议）：route&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看路由信息&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 得到路由表信息，具体分析路由表工作需要网络知识
# 可以通过netstat -r(route)得到同样的路由表

route
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查网络连通性（网络层ICMP协议）：ping&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查是否连通&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 主要功能是检测网络连通性
# 可以额外得到网站的ip地址和连接最大/最小/平均耗时。

ping baidu.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;转发路径（网络层ICMP协议）：traceroute&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件包途径的IP&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 
# 可以打印从沿途经过的路由器IP地址

traceroute baidu.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网络Debug分析（网络层/传输层）：nc&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;端口扫描&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 黑客很喜欢
# 扫描某服务器端口使用情况
# -v(view)显示指令执行过程，-w(wait)设置超时时长
# -z使用输入输出模式（只在端口扫描时使用）
# 数字为扫描的端口范围 

nc -v -w 1 baidu.com  -z 75-1000
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://www.oschina.net/translate/linux-netcat-command&#34;&gt;其他详见&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命令行抓包（网络层/传输层）：tcpdump&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抓包利器，没有什么比数据更值得信赖。可以跟踪整个传输过程。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html&#34;&gt;详见&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;域名解析工具（应用层DNS协议）：dig&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 应用层，DNS
# 打印域名解析结果
# 打印域名解析过程中涉及的各级DNS服务器地址

dig baidu.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网络请求（应用层）：curl&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/gbyukg/p/3326825.html&#34;&gt;详见&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;span-id-other其他span&#34;&gt;&lt;span id = &#34;other&#34;&gt;其他&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;这里都是日常开发中高频命令。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;终止进程：kill&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;杀死具体进程&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 加具体进程PID

kill 12345
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;杀死某进程相关进程&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 加上&amp;quot;-9&amp;quot;杀死某进程相关进程

kill -9 12345
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改文件权限：chmod&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更改文件权限&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 可以对三种使用者设置权限，u(user, owner)，g(group)，o(other)
# 文件可以有三种权限，r(read)，w(write)，x(execute)
# 这里u+r表示文件所有者在原有基础上增加文件读取权限
# 这里777分别对应，u=7，g=7，o=7，具体数字含义自行google

chmod u+r file
chmod 777 file
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建链接：ln&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建硬链接&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# 文件inode中链接数会增加，只有链接数减为0时文件才真正被删除

ln file1 file2
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;创建软（符号链接）链接&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# -s(symbol)为符号链接，仅仅是引用路径
# 相比于硬链接最大特点是可以跨文件系统
# 类似于Windows创建快捷方式，实际文件删除则链接失效

ln -s file1 file2
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;显示文件尾：tail&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;查看文件尾部&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# -f参数可以不立即回传结束信号，当文件有新写入数据时会及时更新
# 查看日志时常用

tail -f test
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;版本控制：git&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;版本控制最好用的软件，没有之一。至少要知道&amp;quot;git init&amp;quot;，&amp;quot;git add&amp;quot;，&amp;quot;git commit&amp;quot;，&amp;quot;git pull&amp;quot;，&amp;quot;git push&amp;quot;几个命令。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/&#34;&gt;详见&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置别名：alias&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;常用命令添加别名&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;# &amp;quot;.bashrc&amp;quot;文件中配置常用命令别名，生效后在命令行只需要使用别名即可代替原先很长的命令

alias rm=&#39;rm -i&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;实战&#34;&gt;实战&lt;/h3&gt;
&lt;p&gt;假设已经通过vim编辑，gcc编译得到可执行文件server，这时就可以使用一些开发者常用的工具来进行后期调试。这里都是给出最简单的用法，意在快速掌握一些基本开发工具。&lt;/p&gt;
&lt;p&gt;先clone这个项目，然后使用src_code下代码编译通过后通过下面命令调试。&lt;a href=&#34;https://github.com/linw7/TKeed&#34;&gt;代码&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单步调试：gdb&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;运行得不到正确结果可以通过gdb设置断点来查看每个中间变量值，以此来确定哪里出了问题。因为gdb调试内容较多，这里不详细说明。另外，gdb出了可以单步查看变量值，还可以分析coredump文件来排查错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;动态库依赖：ldd&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;命令：ldd ./server&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以查看可执行文件server所需的所有动态库，动态库所在目录及其被映射到的虚拟地址空间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;性能分析：top&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;top可以查看当前系统很多信息，比如1,5,15分钟内负载，运行、休眠、僵尸进程数，用户、内核程序占CPU百分比，存储信息等。top可以定位具体哪个进程CPU占用率高和内存使用率高。我们可以以此定位性能问题出在什么程序上（比如你后台执行TKeed server之后，可以看到CPU占用率为99%，这时候我们就需要从这个程序入手了）。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;系统调用：strace&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;命令：strace ./server&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上面已经提到TKeed server的CPU占用率为99%，那么问题通常一定是出在了死循环上。我们接下来在代码中找到死循环位置。因为程序中epoll_wait需要阻塞进程，我们怀疑是不是这里没有阻塞，这时就可以通过上面的方式运行server程序。此时可以打印出没次系统调用及其参数等，我们也可以加-o filename将系统调用信息保存下来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;打印进程：ps&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;命令：ps -ejH&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们在命令行下打开的程序的父进程是shell程序，之前用strace打开server程序，strace也是server的父进程。我们有时候需要知道进程间的层级关系就需要打印进程树，上面的ps命令可以做到。当出现僵尸进程时就可以通过进程树定位具体是哪个进程出了问题。另外当想要知道进程pid时，ps -el | grep XXX也是很常用的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;打开文件：lsof&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;lsof -i:3000&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比如在运行server时发现端口被占用了，可以通过lsof -i:port来查看对应端口号正在被哪个进程所占用。端口占用是非常常见的问题，比如3306被占用我遇到过好几次，要么是某个程序正好占用了要么是之前没能结束进程，这些都可以借助lsof帮助查看端口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;修改权限：chmod&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;chmod 000 ./index.html&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以修改文件权限，这里设为000，这样任何人都无法访问，重新在浏览器请求127.0.0.1:3000/index.html就会因为文件权限不够而无法展示，服务器返回状态码为403，符合我们预期。修改权限后再请求一次可得到状态码200。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;网卡信息：ifconfig&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ifconfig&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果想看一下整个传输过程，可以使用tcpdump来抓包，但是抓包时参数需要加上网卡信息，这时候可以通过ifconfig来获得网卡信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;抓包分析：tcpdump&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;tcpdump -i eth0 port 3000&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以用tcpdump来抓包分析三次握手及数据传输过程，-i之后加上上一步得到的网卡地址，port可以指定监听的端口号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">Linux工具</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/zhen-ti-mu-lu/"" data-c="
          &lt;h1 id=&#34;目录&#34;&gt;目录&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;#t&#34;&gt;Tencent&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;#n&#34;&gt;NetEase&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;360&#34;&gt;360&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;span-id-ttencentspan&#34;&gt;&lt;span id = &#34;t&#34;&gt;Tencent&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&#34;模拟1&#34;&gt;模拟1&lt;/h3&gt;
&lt;p&gt;Q1 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    随着IP网络的发展，为了节省可分配的注册IP地址，有一些地址被拿出来用于私有IP地址，以下不属于私有IP地址范围的是：
    A. 10.6.207.84
    B. 172.23.30.28
    C. 172.32.50.80
    D. 192.168.1.100

答案：
    C

解答：
    1. 私有IP地址共有三个范围段：
        A: 10.0.0.0~10.255.255.255，即10.0.0.0/8。
        B: 172.16.0.0~172.31.255.255，即172.16.0.0/12。
        C: 192.168.0.0~192.168.255.255，即192.168.0.0/16。
    2. 私有IP在公网上不能使用，但在内网内可以通过NAT技术分配给具体设备，节省IP地址。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q2 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    下列关于一个类的静态成员的描述中，不正确的是：
    A. 该类的对象共享其静态成员变量的值
    B. 静态成员变量可被该类的所有方法访问
    C. 该类的静态方法能访问该类的静态成员变量
    D. 该类的静态数据成员变量的值不可修改

答案：
    D

解答：
    1. 类的静态成员和对象无关，和类相关，一个类的所有实例共享同一个静态成员。
    2. 静态成员函数不能调用非静态成员。
    3. 非静态成员函数可以调用静态成员。
    4. 静态成员变量必须初始化，且可以修改。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q3 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    C++将父类的析构函数定义为虚函数，下列正确的是哪个：
    A. 释放父类指针时能正确释放子类对象
    B. 释放子类指针时能正确释放父类对象
    C. 这样做是错误的
    D. 以上全错

答案：
    A

解答：
    1. 基类通常应定义一个虚析构函数，以确保能正确执行析构函数。
    2. 基类指针指向派生类对象，若基类析构函数未声明为虚函数，则只会调用基类析构函数。
    3. 基类声明为虚函数，释放指向派生类对象的基类指针时会先调用派生类析构函数，之后调用基类析构函数。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q4 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    下列哪一个不属于关系数据库的特点：
    A. 数据冗余度小
    B. 数据独立性高
    C. 数据共享性好
    D. 多用户访问

答案：
    D

解答：
    1. 数据库存在的一个目的就是统一管理数据，减少数据冗余度。
    2. 数据独立性，指数据和其管理软件独立，以及数据及其结构的独立。
    3. 数据库就是为了方便用户之间共享数据。
    4. 数据库中存在锁机制，如果多用户访问可能导致数据不一致等。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q5 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    typedef char *String_t和#define String_d char *这两句在使用上有什么区别？

答案：
    1. typedef char *String_t定义了一个新的类型别名，有类型检查，更安全。发生在编译阶段。
    2. #define String_d char *仅仅是做字符串替换，无类型检查。发生在预编译阶段。
    3. 用法区别：String_t a, b;
                String_d c, d; -&amp;gt; char *c, d;
                a, b ,c是char*类型，而d为char类型。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q6 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    void Func(char str_arg[2]){
        int m = sizeof(str_arg);
        int n = strlen(str_arg);
        printf(&amp;quot;%d\n&amp;quot;, m);
        printf(&amp;quot;%d\n&amp;quot;, n);
    }
    int main(void){
        char str[]=&amp;quot;Hello&amp;quot;;
        Func(str);
    }
    输出结果为：

答案：
    4，5
    1. str为定义在main函数中的数组。
    2. 数组作为参数传递给函数会退化为指针。
    3. sizeof(指针变量) = 指针变量大小，strlen(指针变量) = 指针所指向的字符串长（遇&#39;\0&#39;停止）。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q7 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    给定一个字符串,求出其最长的重复子串。

答案：
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;模拟2&#34;&gt;模拟2&lt;/h3&gt;
&lt;p&gt;Q1 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    Internet物理地址和IP地址转换采用什么协议？

答案：
    1. MAC地址 -&amp;gt; IP地址：ARP协议。
    2. IP地址 -&amp;gt; MAC地址：RARP协议。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;http://blog.csdn.net/lanchengxiaoxiao/article/details/7880276&#34;&gt;Q2&lt;/a&gt; :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    static有什么用途？

答案：
    1. 修饰变量：
        静态局部变量：只定义一次，程序运行期间一直存在，作用于局限于定义的函数内。多线程中需要加锁保护。
        静态全局变量：程序运行期间一直存在，作用域为定义它的源文件。
    2. 修饰函数：
        一个被声明为静态的函数只可被这一模块内的其它函数调用。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q3 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    引用与指针有什么区别？

答案：
    1. 指针是个实体，指针的内容是变量地址。引用只是变量别名。
    2. 指针可以指向新的变量地址。引用只能在定义时被初始化一次，之后不可变。
    3. 指针可以为空。引用不能为空。
    4. 指针可以用const修饰，引用不能用const修饰。
    5. 获取变量值指针需要解引用。引用不需要解引用。
    6. 指针变量需要分配实际内存空间。引用不需要分配内存空间，本身不是变量。
    7. 指针的sizeof得到的是指针变量的大小。引用得到的是实际变量的大小。
    8. 指针变量++是地址值的增加。引用的++是实际变量值得增加。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q4 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    全局变量和局部变量在内存中是否有区别？如果有，是什么区别？

答案：
    1. 作用域：
        全局变量：具有全局作用域，只需要定义在一个源文件中就可以在所有源文件中使用。不包含变量定义的文件引用时要用extern声明。
        局部变量：具有局部作用域，只在函数运行期间存在，函数结束后就被销毁。
    2. 生存周期：
        全局变量：定义在静态区，与静态变量存储在一起，伴随程序整个生命周期。
        局部变量：定义在栈上，函数结束后释放。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q5 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    什么是平衡二叉树？

答案：
    1. 空树或者左右两棵子树高度差绝对值小于1，且子树递归满足此定义。
    2. 最小平衡二叉树节点公式：F(n) = F(n - 1) + F(n - 2) + 1。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q6 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    堆栈溢出一般是由什么原因导致的？

答案：
    1. 循环的递归调用（每次递归都需要压栈）。
    2. 大数据结构的局部变量。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q7 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    什么函数不能声明为虚函数？

答案：
    1. 构造函数。虚函数主要针对对象而言，而构造函数是在对象创建之前。
    2. 内联函数。不能再运行中动态确定其位置。
    3. 静态成员函数。全局通用，不受限于具体对象。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q8 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
   写出floatx与“零值”比较的if语句。

答案：
    1. if (fabs(x) &amp;lt; 0.00001f)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q9 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    不能做switch()的参数类型是？

答案：
    1. 只能是char，int，enum。
    2. 不能是bool，long，string，float，double。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q10 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    用户输入M、N值，从1至N开始顺序循环数数，每数到M输出该数值，直至全部输出。写出C程序。

答案：
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;模拟3&#34;&gt;模拟3&lt;/h3&gt;
&lt;p&gt;Q1 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    写出下列代码的输出内容：
    int inc(int a){
        return(++a);
    }
    int multi(int*a, int*b, int*c){
        return(*c = *a**b);
    }
    typedef int(FUNC1)(int in);
    typedef int(FUNC2)(int*, int*, int*);
    void show(FUNC2 fun, int arg1, int*arg2){
        FUNC1 *p = &amp;amp;inc;
        int temp = p(arg1);
        fun(&amp;amp;temp, &amp;amp;arg1, arg2);
        printf(&amp;quot;%d\n&amp;quot;, *arg2);
    }
    int main(){
        int a;
        show(multi, 10, &amp;amp;a);
        return 0;
    }

答案：
    110
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q2 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    如何引用一个已经定义过的全局变量?

答案：
    1. 用extern重新声明已经在别的模块中定义的全局变量，如果写错变量名将会在链接阶段报错。
    2. 引用定义了该全局变量的头文件，如果拼写错误会在编译阶段报错。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q3 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    语句for(; 1; )有什么问题？它是什么意思？

答案：
    1. 一直循环执行。
    2. 此处如果中间是0，则一次不执行。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q4 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？

答案：
    1. static全局变量仅能在定义的源文件中使用，全局变量可以在所有源文件中使用。
    2. static局部变量定义于静态区，生命周期为程序整个运行阶段，多次调用函数只定义一次。局部变量定义于栈，调用函数退出即销毁，多次调用多次分配。
    3. static函数只能在定义的源文件中使用。普通函数可以在头文件中声明，包含该头文件的源文件均可调用该函数。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q5 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    请找出下面代码中的所有错误：
    #include&amp;lt;string.h&amp;gt;
    int main(){
        char*src = &amp;quot;hello,world&amp;quot;;
        char* dest = NULL;
        int len = strlen(src);
        dest = (char*)malloc(len); (1)
        char* d = dest;
        char* s = src[len]; (2)
        while(len-- != 0) (3)
            d++ = s--; (4)
        printf(&amp;quot;%s&amp;quot;, dest);
        return 0;
    }

答案：
    1. 分配的空间要为len + 1，用于存放&#39;\0&#39;。
    2. s = &amp;amp;src[len]这里是取地址。
    3. 改为while(len-- &amp;gt;= 0)。
    4. 改为*d++ = *s--。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q6 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    搜索引擎的日志要记录所有查询串，有一千万条查询，不重复的不超过三百万，要统计最热门的10条查询。
    条件：串内存&amp;lt;1G，字符串长0-255。
    给出主要解决思路，算法及其复杂度分析。

答案：
    1. 面对的问题有：
        (1)1G内存不够一次性装入所有数据？
        (2)如何去统计每个记录出现次数？
        (3)如何快速得到前十的记录？
    2. 解决方式：
        (1)255约2^8，一百万约2^20，即一百万记录约256MB，一千万约2.6GB。分多次处理。
        (2)利用hash统计，定义map，key为string类型日志，value为日志出现次数。
        (3)利用大根堆，取top 10，复杂度O(nlogn)。
    3. 新问题：
        如何划分数据？如何归并结果？
    4. 方案：
        (1)哈希表常驻内存，大小(255 +4) * 3 * 1000000，约800MB。
        (2)分13（200MB * 13 = 2.6GB）次调入日志数据，每次取200MB数据进行hash。
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;模拟4&#34;&gt;模拟4&lt;/h3&gt;
&lt;p&gt;Q1 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    考虑函数原型void hello(int a, int b = 7, char* pszC = &amp;quot;*&amp;quot;)，下面的函数调用中，属于不合法调用的是：
    A. hello(5);
    B. hello(5, 8);
    C. hello(6, &amp;quot;#&amp;quot;);
    D. hello(0, 0, &amp;quot;#&amp;quot;);

答案：
    C 

解答：
    1. 参数从左往右依次赋值。
    2. 有默认值时，调用函数参数缺失时使用默认值。
    3. 参数中字符串会转为指向字符串的指针。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q2 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    下列程序的运行结果为：
    #include&amp;lt;iostream&amp;gt;
    using namespace std;
    void main(){
        int a = 2;
        int b = ++a;
        cout &amp;lt;&amp;lt; a / 6 &amp;lt;&amp;lt; endl;
    }
    A. 0.5
    B. 0
    C. 0.7
    D. 0.666666

答案：
    B

解答：
    1. 这里的6仅仅是整型数，所以和a进行操作时不存在精度提升。
    2. a的值进过++a之后变为3，3 / 6 = 0。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q3 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    #define ADD(x, y) x + y
    int m = 3;
    m += m * ADD(m, m);
    m的值为多少：
    A. 15
    B. 12
    C. 18
    D. 58

答案：
    A

解答：
    1. 原式 = m + [m * m + m] = 3 + [3 * 3 + 3] = 15
    2. 有+=时先算右边部分。
    3. 除非出现++m，否则在同一条语句内，变量值不会改变。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q4 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    下面哪种情况下，B不能隐式转换为A?
    A. class B:public A{}
    B. class A:public B{}
    C. class B{operator A();}
    D. class A{A(const B&amp;amp;);}

答案：
    B

解答：
    1. 派生类 -&amp;gt; 基类，向上级转换是隐式的，只需要丢弃多余的部分即可，反之基类没有多余的空间存放B独有的变量。
    2. C是隐式类型转换操作符。
    3. D是拷贝构造函数进行隐式转化。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q5 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    假设你在编写一个使用多线程技术的程序，当程序中止运行时，需要怎样一个机制来安全有效的中止所有的线程?

答案：
    1. 主线程检查是否有子线程在运行。
    2. 若有则发起线程退出操作(quit)。
    3. wait线程完全停止，delete线程对象。
    4. 等待所有线程结束(发出finish信号)，才退出程序。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q6 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    从程序健壮性进行分析，下面的FillUserInfo函数和main函数分别存在什么问题?
    #define MAX_NAME_LEN 20
    struct USERINFO{
        int nAge;
        char szName[MAX_NAME_LEN];
    };
    void FillUserInfo(USERINFO *parUserInfo){
        stu::cout &amp;lt;&amp;lt; &amp;quot;请输入用户的个数:&amp;quot;;
        int nCount = 0;
        std::cin &amp;gt;&amp;gt; nCount;
        for (int i = 0; i &amp;lt; nCount; i++){
            std::cout &amp;lt;&amp;lt; &amp;quot;请输入年龄:&amp;quot;;
            std::cin &amp;gt;&amp;gt; parUserInfo[i]-&amp;gt;nAge;
            std::string strName;
            std::cout &amp;lt;&amp;lt; &amp;quot;请输入姓名:&amp;quot;;
            std::cin &amp;gt;&amp;gt; strName;
            strcpy(parUserInfo[i].szName, strName.c_str());
        }
    }
    int main(int argc, char *argv[]){
        USERINFO arUserInfos[100] = {0};
        FillUserInfo(arUserInfos);
        printf(&amp;quot;The first name is:&amp;quot;);
        printf(arUserInfos[0].szName);
        printf(&amp;quot;\n&amp;quot;);
        return 0;
    }

答案：
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;模拟5&#34;&gt;模拟5&lt;/h3&gt;
&lt;p&gt;Q1 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    设某种二叉树有如下特点：每个结点要么是叶子结点，要么有2棵子树。假如一棵这样的二叉树中有m（m &amp;gt; 0）个叶子结点，那么该二叉树上的结点总数为：
    A. 2m + 1
    B. 2m - 1
    C. 2(m - 1)
    D. 2m

答案：
    B

解答：
    1. 关键考点： 
        (1)叶子节点数 = 度为2的节点数 + 1
        (2)树的度 = 所有节点度的和
        (3)树的节点数 = 树的度 + 1
    2. 计算步骤：
        (1)度为2的节点数 = m - 1
        (2)树的度 = m * 0 + 0 * 0 + (m - 1) * 2 = 2m - 2
        (3)树的节点数 = (2m - 2) + 1 = 2m - 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q2 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    中断响应时间是指：
    A. 从中断处理开始到中断处理结束所用的时间
    B. 从发出中断请求到中断处理结束所用的时间
    C. 从发出中断请求到进入中断处理所用的时间
    D. 从中断处理结束到再次中断请求的时间

答案：
    C

解答：
    见答案。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q3 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    试写出“背包题目”的非递归解法。

答案：
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;模拟6&#34;&gt;模拟6&lt;/h3&gt;
&lt;p&gt;Q1 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    下推自动识别机的语言是：
    A. 0型语言
    B. 1型语言
    C. 2型语言
    D. 3型语言

答案：
    C 

解答：
    1. 0型文法产生的语言称为0型语言。
    2. 1型文法产生的语言称为1型语言，也称作上下文有关语言。
    3. 2型文法产生的语言称为2型语言，也称作上下文无关语言。
    4. 3型文法产生的语言称为3型语言，也称作正规语言。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q2 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    浏览器访问某页面，HTTP协议返回状态码为403时表示：
    A. 找不到该页面
    B. 禁止访问
    C. 内部服务器访问
    D. 服务器繁忙

答案：
    B 

解答：
    1. 100-199，指定客服端相应的某些动作
    2. 200-299，表示请求成功
    3. 300-399，用于已经移动的文件并且包含在定位头信息中指定
    4. 400-499，客服端错误
    5. 500-599，服务端错误
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q3 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    递归函数最终会结束，那么这个函数一定：
    A. 使用了局部变量
    B. 有一个分支不调用自身
    C. 使用了全局变量或者使用了一个或多个参数
    D. 没有循环调用

答案：
    B

解答：
    1. 分支不调用自身即函数出口。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q4 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    编译过程中，语法分析器的任务是：
    A. 分析单词是怎样构成的
    B. 分析单词串是如何构成语言和说明的
    C. 分析语句和说明是如何构成程序的
    D. 分析程序的结构

答案：
    B, C, D

解答：
    1. 词法分析：词法分析是编译过程的第一个阶段。这个阶段的任务是从左到右的读取每个字符，然后根据构词规则识别单词。词法分析可以用lex等工具自动生成。
    2. 语法分析：语法分析是编译过程的一个逻辑阶段。语法分析在词法分析的基础上，将单词序列组合成各类语法短语，如“程序”，“语句”，“表达式”等等。语法分析程序判断程序在结构上是否正确。
    3. 语义分析：属于逻辑阶段。对源程序进行上下文有关性质的审查，类型检查。如赋值语句左右端类型匹配问题。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q5 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    进程进入等待状态有哪几种方式:
    A. CPU调度给优先级更高的线程
    B. 阻塞的线程获得资源或者信号
    C. 在时间片轮转的情况下，如果时间片到了
    D. 获得spinlock未果

答案：
    D

解答：
    1. A和C均是由从运行态转为就绪状态。
    2. B是由阻塞状态转为就绪状态。
    3. 自旋锁（spinlock）是一种保护临界区最常见的技术。在同一时刻只能有一个进程获得自旋锁，其他企图获得自旋锁的任何进程将一直进行尝试。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q6 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    同一进程下的线程可以共享以下：
    A. stack
    B. data section
    C. register set
    D. file fd

答案：
    B, D

解答：
    1. 线程共享的内容包括：
        进程代码段
        进程的公有数据
        进程打开的文件描述符
        信号的处理器
        进程的当前目录
        进程用户ID与进程组ID
    2. 线程独有的内容包括：
        线程ID
        寄存器组的值
        线程的堆栈
        错误返回码
        线程的信号屏蔽码
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q7 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    设计模式中，属于结构型模式的有哪些：
    A. 状态模式
    B. 装饰模式
    C. 代理模式
    D. 观察者模式

答案：
    B, C

解答：
    1. 创建型模式：
        单例模式
        抽象工厂模式
        建造者模式
        工厂模式
        原型模式
    2. 结构型模式：
        适配器模式
        桥接模式
        装饰模式
        组合模式
        外观模式
        享元模式
        代理模式
    3. 行为型模式：
        模版方法模式
        命令模式
        迭代器模式
        观察者模式
        中介者模式
        备忘录模式
        解释器模式
        状态模式
        策略模式
        职责链模式
        访问者模式
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q8 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    Unix系统中，哪些可以用于进程间的通信：
    A. Socket
    B. 共享内存
    C. 消息队列
    D. 信号量

答案：
    A, B，C，D

解答：
    1. Linux进程间通信：管道、信号、消息队列、共享内存、信号量、套接字。
    2. Linux线程间通信：互斥量、信号量、条件变量。
    3. Windows进程间通信：管道、消息队列、共享内存、信号量、套接字。
    3. Windows线程间通信：互斥量、信号量、临界区、事件。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q9 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    设t是给定的一棵二叉树，下面的递归程序count(t)用于求得：
    typedef struct node{
        int data;
        struct node *lchild, *rchild;
    }node;
    int N2, NL, NR, N0;
    void count(node *t){
        if (t-&amp;gt;lchild != NULL)
            if (t-&amp;gt;rchild != NULL) N2++;
            else NL++;
        else if(t-&amp;gt;rchild != NULL)
            NR++;
        else N0++;
        if(t-&amp;gt;lchild != NULL)
            count(t-&amp;gt;lchild);
        if(t-&amp;gt;rchild != NULL)
            count(t-&amp;gt;rchild);
    }
答案：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q10 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    请设计一个排队系统，能够让每个进入队伍的用户都能看到自己在队列中所处的位置和变化，队伍可能随时有人加入和退出；当有人退出影响到用户的位置排名时需要及时反馈到用户。

答案：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q11 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    A、B两个整数集合，设计一个算法求他们的交集，尽可能的高效。

答案：
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;模拟6-2&#34;&gt;模拟6&lt;/h3&gt;
&lt;p&gt;Q1 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    如何减少换页错误：
    A. 进程倾向于占用CPU
    B. 访问局部性（locality of reference）满足进程要求
    C. 进程倾向于占用I/O
    D. 使用基于最短剩余时间（shortest remaining time）的调度机制

答案：
    B

解答：
    1. 换页错误又称缺页错误，当一个程序试图访问没有映射到物理内存的地方时，就会出现缺页错误。
    2. 减少缺页发生的方法：
        增加作业分配的内存块数。
        增加页面大小。
        页面替换算法。
        程序满足局部性原理。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q2 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    有1000亿条记录，每条记录由url,ip,时间组成，设计一个系统能够快速查询以下内容。
    1. 给定url和时间段（精确到分钟）统计url的访问次数。
    2. 给定ip和时间段（精确到分钟）统计ip的访问次数。

答案：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q3 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：

    给定一个包含了用户query的日志文件，对于输入的任意一个字符串s，输出以s为前缀的在日志中出现频率最高的前10条query。
    至少有26台机器，每个机器存储以26个字母开头的query日志文件（机器1以a字母开头的，机器2以b字母开头……）。
    各机器维护一张哈希表，每条query在哈希表中存放其地址（哈希地址为链式的），并对其进行排序，按频率由高到低进行排序。
    当用户进行搜索时，可以很快定位到某台机器，并根据哈希表，返回出现频率最高的前10条query。

    提示：
    1. 可以预处理日志。
    2. 假设query超过10亿条，每个query不超过50字节。
    3. 考虑在大查询量的情况下如何实现分布式服务。

答案：
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;模拟7&#34;&gt;模拟7&lt;/h3&gt;
&lt;p&gt;Q1 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    下列哪些http方法对于服务端和用户端一定是安全的？
    A. GET
    B. HEAD
    C. TRACE
    D. OPTION
    E. POST

答案：
    C 

解答：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q2 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    一个系统，提供多个http协议的接口，返回的结果Y有json格式和jsonp格式。Json的格式为{&amp;quot;code&amp;quot;:100,&amp;quot;msg&amp;quot;:&amp;quot;aaa&amp;quot;}，为了保证该协议变更之后更好的应用到多个接口，为了保证修改协议不影响到原先逻辑的代码，以下哪些设计模式是需要的?协议的变更指的是日后可能返回xml格式，或者是根据需求统一对返回的消息进行过滤。
    A. Aadapter
    B. factory method
    C. proxy
    D. decorator
    E. composite

答案：
    A, B, D

解答：
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;模拟8&#34;&gt;模拟8&lt;/h3&gt;
&lt;p&gt;Q1 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    在数据库系统中，产生不一致的根本原因是：
    A. 数据存储量太大
    B. 没有严格保护数据
    C. 未对数据进行完整性控制
    D. .数据冗余

答案：


解答：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q2 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    请问下面的程序一共输出多少个“-”？
    int main(void){
        int i;
        for(i = 0; i &amp;lt; 2; i++){
            fork();
            printf(&amp;quot;-&amp;quot;);
        }
        return 0;
    }
    A. 2
    B. 4
    C. 6
    D. 8

答案：


解答：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q3 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：
    请问下面的程序一共输出多少个“-”？为什么？
    #include &amp;lt;stdio.h&amp;gt;
    #include &amp;lt;sys/types.h&amp;gt;
    #include &amp;lt;unistd.h&amp;gt; 
    int main(void){
        int i;
        for (i = 0; i &amp;lt; 2; i++){
            fork();
            printf(&amp;quot;-\n&amp;quot;);
        }
        return 0;
    }
    A. 4
    B. 5
    C. 6
    D. 8

答案：


解答：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q4 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：

    A.
    B.
    C.
    D.

答案：


解答：
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Q5 :&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;题目：

    A.
    B.
    C.
    D.

答案：


解答：
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;span-id-nneteasespan&#34;&gt;&lt;span id = &#34;n&#34;&gt;NetEase&lt;/span&gt;&lt;/h2&gt;
&lt;hr&gt;
&lt;h2 id=&#34;span-id-360360span&#34;&gt;&lt;span id = &#34;360&#34;&gt;360&lt;/span&gt;&lt;/h2&gt;
">真题目录</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/wang-luo-bian-cheng/"" data-c="
          &lt;h1 id=&#34;网络编程基础&#34;&gt;网络编程基础&lt;/h1&gt;
&lt;h2 id=&#34;常见问题&#34;&gt;常见问题&lt;/h2&gt;
&lt;h3 id=&#34;socket-api&#34;&gt;Socket API&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;网络编程一般步骤？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;服务端：socket -&amp;gt; bind -&amp;gt; listen -&amp;gt; accept -&amp;gt; recv/send -&amp;gt; close。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端：socket -&amp;gt; connect -&amp;gt; send/recv -&amp;gt; close。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UDP：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;服务端：socket -&amp;gt; bind -&amp;gt; recvfrom/sendto -&amp;gt; close。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端：socket -&amp;gt; sendto/recvfrom -&amp;gt; close。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;send、sendto区别，recv、recvfrom区别？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;tcpudp&#34;&gt;TCP/UDP&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;TCP和UDP区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP面向连接（三次握手），通信前需要先建立连接；UDP面向无连接，通信前不需要连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP通过序号、重传、流量控制、拥塞控制实现可靠传输；UDP不保障可靠传输，尽最大努力交付。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP面向字节流传输，因此可以被分割并在接收端重组；UDP面向数据报传输。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP为什么不是两次握手而是三次？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果仅两次连接可能出现一种情况：客户端发送完连接报文（第一次握手）后由于网络不好，延时很久后报文到达服务端，服务端接收到报文后向客户端发起连接（第二次握手）。此时客户端会认定此报文为失效报文，但在两次握手情况下服务端会认为已经建立起了连接，服务端会一直等待客户端发送数据，但因为客户端会认为服务端第二次握手的回复是对失效请求的回复，不会去处理。这就造成了服务端一直等待客户端数据的情况，浪费资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP为什么挥手是四次而不是三次？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP是全双工的，它允许两个方向的数据传输被独立关闭。当主动发起关闭的一方关闭连接之后，TCP进入半关闭状态，此时主动方可以只关闭输出流。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;之所以不是三次而是四次主要是因为被动关闭方将&amp;quot;对主动关闭报文的确认&amp;quot;和&amp;quot;关闭连接&amp;quot;两个操作分两次进行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;quot;对主动关闭报文的确认&amp;quot;是为了快速告知主动关闭方，此关闭连接报文已经收到。此时被动方不立即关闭连接是为了将缓冲中剩下的数据从输出流发回主动关闭方（主动方接收到数据后同样要进行确认），因此要把&amp;quot;确认关闭&amp;quot;和&amp;quot;关闭连接&amp;quot;分两次进行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Linux的close实际上是同时关闭输入流和输出流，并不是我们常说的四次握手。半关闭函数为shutdown，它可以用来断开某个具体描述符的TCP输入流或输出流。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么要有TIME_WAIT状态，TIME_WAIT状态过多怎么解决？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主动关闭连接一方在发送对被动关闭方关闭连接的确认报文时，有可能因为网络状况不佳，被动关闭方超时未能收到此报文而重发断开连接（FIN）报文，此时如果主动方不等待而是直接进入CLOSED状态，则接收到被动关闭方重发的断开连接的报文会触发RST分组而非ACK分组，当被动关闭一方接收到RST后会认为出错了。所以说处于TIME_WAIT状态就是为了在重新收到断开连接分组情况下进行确认。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以通过修改sysctl中TIME_WAIT时间来减少此情况（HTTP 1.1也可以减少此状态）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用SO_LINGER选项的强制关闭方式，发RST而不是FIN，来越过TIMEWAIT状态，直接进入CLOSED状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP建立连接及断开连接是状态转换？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;客户端：SYN_SENT -&amp;gt; ESTABLISHED -&amp;gt; FIN_WAIT_1 -&amp;gt; FIN_WAIT_2 -&amp;gt; TIME_WAIT。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务端：LISTEN -&amp;gt; SYN_RCVD -&amp;gt; ESTABLISHED -&amp;gt; CLOSE_WAIT -&amp;gt; LAST_ACK -&amp;gt; CLOSED。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP流量控制和拥塞控制的实现？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;流量控制：TCP采用大小可变的滑动窗口进行流量控制。窗口大小的单位是字节，在TCP报文段首部的窗口字段写入的数值就是当前给对方设置的发送窗口数值的上限，发送窗口在连接建立时由双方商定。但在通信的过程中，接收端可根据自己的资源情况，随时动态地调整对方的发送窗口上限值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拥塞控制：网络拥塞现象是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象。严重时甚至会导致网络通信业务陷入停顿，即出现死锁现象。拥塞控制是处理网络拥塞现象的一种机制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP重传机制？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;滑动窗口机制，确立收发的边界，能让发送方知道已经发送了多少、尚未确认的字节数、尚待发送的字节数；让接收方知道已经确认收到的字节数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;选择重传，用于对传输出错的序列进行重传。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三次握手过程？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主动建立连接方A的TCP向主机B发出连接请求报文段，其首部中的SYN(同步)标志位应置为1，表示想与目标主机B进行通信，并发送一个同步序列号x进行同步，表明在后面传送数据时的第一个数据字节的序号是x + 1。SYN同步报文会指明客户端使用的端口以及TCP连接的初始序号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接收连接方B的TCP收到连接请求报文段后，如同意则发回确认。在确认报中应将ACK位和SYN位置1，表示客户端的请求被接受。确认号应为x + 1，同时也为自己选择一个序号y。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主动方A的TCP收到目标主机B的确认后要向目标主机B给出确认，其ACK置1，确认号为y + 1，而自己的序号为x + 1。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;四次挥手过程？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主动关闭主机A的应用进程先向其TCP发出连接释放请求，并且不再发送数据。TCP通知对方要释放从A到B这个方向的连接，将发往主机B的TCP报文段首部的终止比特FIN置1，其序号x等于前面已传送过的数据的最后一个字节的序号加1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;被动关闭主机B的TCP收到释放连接通知后即发出确认，其序号为y，确认号为x + 1，同时通知高层应用进程，这样，从A到B的连接就释放了，连接处于半关闭状态。但若主机B还有一些数据要发送主机A，则可以继续发送。主机A只要正确收到数据，仍应向主机B发送确认。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若主机B不再向主机A发送数据，其应用进程就通知TCP释放连接。主机B发出的连接释放报文段必须将终止比特FIN和确认比特ACK置1，并使其序号仍为y，但还必须重复上次已发送过的ACK = x + 1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主机A必须对此发出确认，将ACK置1，ACK = y + 1，而自己的序号是x + 1。这样才把从B到A的反方向的连接释放掉。主机A的TCP再向其应用进程报告，整个连接已经全部释放。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;io模型&#34;&gt;I/O模型&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;阻塞和非阻塞I/O区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果内核缓冲没有数据可读时，read()系统调用会一直等待有数据到来后才从阻塞态中返回，这就是阻塞I/O。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非阻塞I/O在遇到上述情况时会立即返回给用户态进程一个返回值，并设置errno为EAGAIN。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于往缓冲区写的操作同理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步和异步区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;同步I/O指处理I/O操作的进程和处理I/O操作的进程是同一个。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步I/O中I/O操作由操作系统完成，并不由产生I/O的用户进程执行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Reactor和Proactor区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Reactor模式已经是同步I/O，处理I/O操作的依旧是产生I/O的程序；Proactor是异步I/O，产生I/O调用的用户进程不会等待I/O发生，具体I/O操作由操作系统完成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步I/O需要操作系统支持，Linux异步I/O为AIO，Windows为IOCP。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;epoll和select及poll区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;文件描述符数量限制：select文件描述符数量受到限制，最大为2048（FD_SETSIZE），可重编内核修改但治标不治本；poll没有最大文件描述符数量限制；epoll没有最大文件描述符数量限制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查机制：select和poll会以遍历方式（轮询机制）检查每一个文件描述符以确定是否有I/O就绪，每次执行时间会随着连接数量的增加而线性增长；epoll则每次返回后只对活跃的文件描述符队列进行操作（每个描述符都通过回调函数实现，只有活跃的描述符会调用回调函数并添加至队列中）。&lt;strong&gt;当大量连接是非活跃连接时epoll相对于select和poll优势比较大，若大多为活跃连接则效率未必高（设计队列维护及红黑树创建）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据传递方式：select和poll需要将FD_SET在内核空间和用户空间来回拷贝；epoll则避免了不必要的数据拷贝。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;epoll中ET和LT模式的区别与实现原理？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;LT：默认工作方式，同时支持阻塞I/O和非阻塞I/O，LT模式下，内核告知某一文件描述符读、写是否就绪了，然后你可以对这个就绪的文件描述符进行I/O操作。如果不作任何操作，内核还是会继续通知。这种模式编程出错误可能性较小但由于重复提醒，效率相对较低。传统的select、poll都是这种模型的代表。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ET：高速工作方式（因为减少了epoll_wait触发次数），适合高并发，只支持非阻塞I/O，ET模式下，内核告知某一文件描述符读、写是否就绪了，然后他假设已经知道该文件描述符是否已经就绪，内核不会再为这个文件描述符发更多的就绪通知（epoll_wait不会返回），直到某些操作导致文件描述符状态不再就绪。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ET模式下要注意什么（如何使用ET模式）？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于读操作，如果read没有一次读完buff数据，下一次将得不到就绪通知（ET特性），造成buff中数据无法读出，除非有新数据到达。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决方法：将套接字设置为非阻塞，用while循环包住read，只要buff中有数据，就一直读。一直读到产生EAGIN错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于写操作主要因为ET模式下非阻塞需要我们考虑如何将用户要求写的数据写完。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;解决方法：只要buff还有空间且用户请求写的数据还未写完，就一直写。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;操作系统&#34;&gt;操作系统&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Linux下进程间通信方式？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;管道：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无名管道（内存文件）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程之间使用。进程的亲缘关系通常是指父子进程关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有名管道（FIFO文件，借助文件系统）：有名管道也是半双工的通信方式，但是允许在没有亲缘关系的进程之间使用，管道是先进先出的通信方式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的IPC方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与信号量，配合使用来实现进程间的同步和通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息队列：消息队列是有消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;套接字：适用于不同机器间进程通信，在本地也可作为两个进程通信的方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号：用于通知接收进程某个事件已经发生，比如按下ctrl + C就是信号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，实现进程、线程的对临界区的同步及互斥访问。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linux下同步机制？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;POSIX信号量：可用于进程同步，也可用于线程同步。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;POSIX互斥锁 + 条件变量：只能用于线程同步。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程和进程的区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;调度：线程是调度的基本单位（PC，状态码，通用寄存器，线程栈及栈指针）；进程是拥有资源的基本单位（打开文件，堆，静态区，代码段等）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发性：一个进程内多个线程可以并发（最好和CPU核数相等）；多个进程可以并发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属进程的资源；进程是拥有资源的独立单位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统开销：线程创建销毁只需要处理PC值，状态码，通用寄存器值，线程栈及栈指针即可；进程创建和销毁需要重新分配及销毁task_struct结构。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;介绍虚拟内存？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存分配及碎片管理？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有很多小的碎片文件怎么处理？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;linux&#34;&gt;Linux&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;fork系统调用？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;什么场景用共享内存，什么场景用匿名管道？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有没有用过开源的cgi框架？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;epoll和select比有什么优势有什么劣势，epoll有什么局限性？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;epoll优势：1. 没有描述符数量限制；2. 通过回调代替轮询；3. 内存映射代替数据在用户和内核空间来回拷贝。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;epoll劣势（局限性）：select可以跨平台，epoll只能在Linux上使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程（POSIX）锁有哪些？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;互斥锁（mutex）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥锁属于sleep-waiting类型的锁。例如在一个双核的机器上有两个线程A和B，它们分别运行在core 0和core 1上。假设线程A想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞，此时会通过上下文切换将线程A置于等待队列中，此时core 0就可以运行其他的任务（如线程C）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;条件变量(cond)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自旋锁(spin)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;自旋锁属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，如果自旋锁已经被线程B所持有，那么线程A就会一直在core 0上进行忙等待并不停的进行锁请求，检查该自旋锁是否已经被线程B释放，直到得到这个锁为止。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虽然它的效率比互斥锁高，但是它也有些不足之处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自旋锁只有在内核可抢占式或SMP的情况下才真正需要，在单CPU且不可抢占式的内核下，自旋锁的操作为空操作。自旋锁适用于锁使用者保持锁时间比较短的情况下。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读写锁（rwlock）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;tkeed&#34;&gt;TKeed&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;项目整体架构是什么？请求怎么进来？处理完怎么出去？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;整体架构为：I/O多路复用 + 非阻塞I/O + 线程池，即Reactor反应堆模型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建监听描述符并在epoll中注册。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;监听到新请求，epoll从阻塞中返回并建立新连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将新建的连接描述符在epoll中注册。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当某个连接接收到用户请求数据时，将任务投放到线程池任务队列中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工作线程被条件变量（任务队列不为空）唤醒，并互斥访问线程池。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;得到任务的线程完成解析及响应。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;工作线程执行函数为do_request，参数即为task结构。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个task结构在建立连接是被初始化，包含描述符、缓冲区等信息是，并在do_request执行时记录解析结果及状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在做压测时，机器配置是什么样的？数据如何？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;本地测试。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;四核i5处理器 + 128G固态硬盘。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了QPS（Query per second, 1秒内完成的请求数量）更高可以做哪些改进？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对请求结果做缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多次搜索请求采用异步I/O，改串行为并行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调整并发线程数量（通常和CPU核心数相同）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有没有注意到压测时内存，CPU，I/O指标？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;压测同时打开top -H -p pid查看CPU，I/O，内存信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;压测时有没有见过TIME_WAIT？怎么样会见到？怎么解决？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当服务端关闭连接时会产生TIME_WAIT。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;HTTP 1.1在同一个TCP连接上尽量传输更多数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过修改sysctl配置减小TIME_WAIT时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;是会主动关闭还是会等待客户端关闭连接?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务端会在完成请求之后关闭连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写一个Server需要注意哪些问题？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;只支持request/response，除此之外是否需要支持cgi。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并发量，QPS，资源占用（内存，CPU，I/O，网络流量等）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CPU占用是否过高。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存是否泄露。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;项目中遇到什么困难，你是如何解决的？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CPU占用过高。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;压测时，每次最后会挂掉。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;做这个项目的目的是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定时器是如何实现的？里面放了有多少个连接（怎么确定大小）？谁去取超时的连接？检查超时之后还会继续检查吗，还是检查完之后就断了？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果发生超时，在关闭连接时同时又收到了新的数据怎么办？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用什么数据结构存放url，怎么解析的？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用tk_request_t结构中buff读取用户请求，buff为循环缓冲（8192 Bytes）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每次进入while循环时读取用户请求到buff中循环队列尾位置（plast），之后解析用户请求并响应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持HTTP 1.1，只要有数据就读取 -&amp;gt; 解析 -&amp;gt; 响应。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;实习经历&#34;&gt;实习经历&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;介绍一下上网行为管理这个系统？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;介绍一下格林威治云平台做哪些任务？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;改变数据获取方式及校验数据一致性？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;WTGGroup模块做什么用的？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;层序遍历二叉树？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;map和hashmap的区别是什么？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hash发生冲突时怎么处理？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hashmap的时间复杂度是多少？map的时间复杂度？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优先队列时间复杂度？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
">网络编程</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/shu-ju-jie-gou-yu-suan-fa/"" data-c="
          &lt;h1 id=&#34;数据结构及算法&#34;&gt;数据结构及算法&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;概念大家都清楚，多写代码是关键。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;目录&#34;&gt;目录&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;https://github.com/linw7/Paper-Code&#34;&gt;纸上代码&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;#dp&#34;&gt;动态规划专项&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;https://github.com/linw7/Skill-Tree/blob/master/%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86.md&#34;&gt;海量数据专项&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
">数据结构与算法</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/ji-wang/"" data-c="
          &lt;h1 id=&#34;计算机网络&#34;&gt;计算机网络&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;重点在TCP/IP协议和HTTP协议。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;目录&#34;&gt;目录&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;#net&#34;&gt;网络层(IP)&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;#trans&#34;&gt;传输层(TCP/UDP)&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;#app&#34;&gt;应用层(HTTP)&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h1 id=&#34;内容&#34;&gt;内容&lt;/h1&gt;
&lt;h3 id=&#34;span-id-net网络层ipspan&#34;&gt;&lt;span id = &#34;net&#34;&gt;网络层(IP)&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;待补充&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;span-id-trans传输层tcpudpspan&#34;&gt;&lt;span id = &#34;trans&#34;&gt;传输层(TCP/UDP)&lt;/span&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;ISO七层模型中表示层和会话层功能是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;表示层：图像、视频编码解，数据加密。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;会话层：建立会话，如session认证、断点续传。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;描述TCP头部？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;序号（32bit）：传输方向上字节流的字节编号。初始时序号会被设置一个随机的初始值（ISN），之后每次发送数据时，序号值 = ISN + 数据在整个字节流中的偏移。假设A -&amp;gt; B且ISN = 1024，第一段数据512字节已经到B，则第二段数据发送时序号为1024 + 512。用于解决网络包乱序问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;确认号（32bit）：接收方对发送方TCP报文段的响应，其值是收到的序号值 + 1。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;首部长（4bit）：标识首部有多少个4字节 * 首部长，最大为15，即60字节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标志位（6bit）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;URG：标志紧急指针是否有效。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ACK：标志确认号是否有效（确认报文段）。用于解决丢包问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PSH：提示接收端立即从缓冲读走数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RST：表示要求对方重新建立连接（复位报文段）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SYN：表示请求建立一个连接（连接报文段）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FIN：表示关闭连接（断开报文段）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;窗口（16bit）：接收窗口。用于告知对方（发送方）本方的缓冲还能接收多少字节数据。用于解决流控。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;校验和（16bit）：接收端用CRC检验整个报文段有无损坏。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三次握手过程？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一次：客户端发含SYN位，SEQ_NUM = S的包到服务器。（客 -&amp;gt; SYN_SEND）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二次：服务器发含ACK，SYN位且ACK_NUM = S + 1，SEQ_NUM = P的包到客户机。（服 -&amp;gt; SYN_RECV）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三次：客户机发送含ACK位，ACK_NUM = P + 1的包到服务器。（客 -&amp;gt; ESTABLISH，服 -&amp;gt; ESTABLISH）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;四次挥手过程？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一次：客户机发含FIN位，SEQ = Q的包到服务器。（客 -&amp;gt; FIN_WAIT_1）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二次：服务器发送含ACK且ACK_NUM = Q + 1的包到服务器。（服 -&amp;gt; CLOSE_WAIT，客 -&amp;gt; FIN_WAIT_2）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;此处有等待&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三次：服务器发送含FIN且SEQ_NUM = R的包到客户机。（服 -&amp;gt; LAST_ACK，客 -&amp;gt; TIME_WAIT）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;此处有等待&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第四次：客户机发送最后一个含有ACK位且ACK_NUM = R + 1的包到客户机。（服 -&amp;gt; CLOSED）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么握手是三次，挥手是四次？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于握手：握手只需要确认双方通信时的初始化序号，保证通信不会乱序。（第三次握手必要性：假设服务端的确认丢失，连接并未断开，客户机超时重发连接请求，这样服务器会对同一个客户机保持多个连接，造成资源浪费。）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于挥手：TCP是双工的，所以发送方和接收方都需要FIN和ACK。只不过有一方是被动的，所以看上去就成了4次挥手。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP连接状态？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CLOSED：初始状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LISTEN：服务器处于监听状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解释FIN_WAIT_2，CLOSE_WAIT状态和TIME_WAIT状态？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;FIN_WAIT_2：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;半关闭状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发送断开请求一方还有接收数据能力，但已经没有发送数据能力。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CLOSE_WAIT状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;被动关闭连接一方接收到FIN包会立即回应ACK包表示已接收到断开请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;被动关闭连接一方如果还有剩余数据要发送就会进入CLOSED_WAIT状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TIME_WAIT状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;又叫2MSL等待状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果客户端直接进入CLOSED状态，如果服务端没有接收到最后一次ACK包会在超时之后重新再发FIN包，此时因为客户端已经CLOSED，所以服务端就不会收到ACK而是收到RST。所以TIME_WAIT状态目的是防止最后一次握手数据没有到达对方而触发重传FIN准备的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在2MSL时间内，同一个socket不能再被使用，否则有可能会和旧连接数据混淆（如果新连接和旧连接的socket相同的话）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解释RTO，RTT和超时重传？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;发送的数据没能到达接收端，所以对方没有响应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接收端接收到数据，但是ACK报文在返回过程中丢失。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接收端拒绝或丢弃数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RTO：从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间。就是重传间隔。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT......&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重传次数到达上限之后停止重传。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RTT：数据从发送到接收到对方响应之间的时间间隔，即数据报在网络中一个往返用时。大小不稳定。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;流量控制原理？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;目的是接收方通过TCP头窗口字段告知发送方本方可接收的最大数据量，用以解决发送速率过快导致接收方不能接收的问题。所以流量控制是点对点控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP是双工协议，双方可以同时通信，所以发送方接收方各自维护一个发送窗和接收窗。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;发送窗：用来限制发送方可以发送的数据大小，其中发送窗口的大小由接收端返回的TCP报文段中窗口字段来控制，接收方通过此字段告知发送方自己的缓冲（受系统、硬件等限制）大小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接收窗：用来标记可以接收的数据大小。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP是流数据，发送出去的数据流可以被分为以下四部分：已发送且被确认部分 | 已发送未被确认部分 | 未发送但可发送部分 | 不可发送部分，其中发送窗 = 已发送未确认部分 + 未发但可发送部分。接收到的数据流可分为：已接收 | 未接收但准备接收 | 未接收不准备接收。接收窗 = 未接收但准备接收部分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发送窗内数据只有当接收到接收端某段发送数据的ACK响应时才移动发送窗，左边缘紧贴刚被确认的数据。接收窗也只有接收到数据且最左侧连续时才移动接收窗口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拥塞控制原理？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;拥塞控制目的是防止数据被过多注网络中导致网络资源（路由器、交换机等）过载。因为拥塞控制涉及网络链路全局，所以属于全局控制。控制拥塞使用拥塞窗口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP拥塞控制算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;慢开始 &amp;amp; 拥塞避免：先试探网络拥塞程度再逐渐增大拥塞窗口。每次收到确认后拥塞窗口翻倍，直到达到阀值ssthresh，这部分是慢开始过程。达到阀值后每次以一个MSS为单位增长拥塞窗口大小，当发生拥塞（超时未收到确认），将阀值减为原先一半，继续执行线性增加，这个过程为拥塞避免。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快速重传 &amp;amp; 快速恢复：略。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最终拥塞窗口会收敛于稳定值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何区分流量控制和拥塞控制？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;流量控制属于通信双方协商；拥塞控制涉及通信链路全局。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由试探性发送一定数据量数据探查网络状况后而自适应调整。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实际最终发送窗口 = min{流控发送窗口，拥塞窗口}。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP如何提供可靠数据传输的？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;建立连接（标志位）：通信前确认通信实体存在。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;序号机制（序号、确认号）：确保了数据是按序、完整到达。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据校验（校验和）：CRC校验全部数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;窗口机制（窗口）：提供流量控制，避免过量发送。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拥塞控制：同上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TCP soctet交互流程？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;服务器：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建socket -&amp;gt; int socket(int domain, int type, int protocol);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;domain：协议域，决定了socket的地址类型，IPv4为AF_INET。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;type：指定socket类型，SOCK_STREAM为TCP连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;protocol：指定协议。IPPROTO_TCP表示TCP协议，为0时自动选择type默认协议。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;绑定socket和端口号 -&amp;gt; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;sockfd：socket返回的套接字描述符，类似于文件描述符fd。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;addr：有个sockaddr类型数据的指针，指向的是被绑定结构变量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;    // IPv4的sockaddr地址结构
    struct sockaddr_in {
        sa_family_t sin_family;    // 协议类型，AF_INET
        in_port_t sin_port;    // 端口号
        struct in_addr sin_addr;    // IP地址
    };
    struct in_addr {
        uint32_t s_addr;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;addrlen：地址长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;监听端口号 -&amp;gt; int listen(int sockfd, int backlog);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;sockfd：要监听的sock描述字。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;backlog：socket可以排队的最大连接数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接收用户请求 -&amp;gt; int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;sockfd：服务器socket描述字。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;addr：指向地址结构指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;addrlen：协议地址长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注：一旦accept某个客户机请求成功将返回一个全新的描述符用于标识具体客户的TCP连接。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从socket中读取字符 -&amp;gt; ssize_t read(int fd, void *buf, size_t count);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;fd：连接描述字。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;buf：缓冲区buf。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;count：缓冲区长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注：大于0表示读取的字节数，返回0表示文件读取结束，小于0表示发生错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭socket -&amp;gt; int close(int fd);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;fd：accept返回的连接描述字，每个连接有一个，生命周期为连接周期。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注：sockfd是监听描述字，一个服务器只有一个，用于监听是否有连接；fd是连接描述字，用于每个连接的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户机：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建socket -&amp;gt; int socket(int domain, int type, int protocol);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接指定计算机 -&amp;gt; int connect(int sockfd, struct sockaddr* addr, socklen_t addrlen);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;sockfd客户端的sock描述字。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;addr：服务器的地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;addrlen：socket地址长度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;向socket写入信息 -&amp;gt; ssize_t write(int fd, const void *buf, size_t count);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;fd、buf、count：同read中意义。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大于0表示写了部分或全部数据，小于0表示出错。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭oscket -&amp;gt; int close(int fd);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fd：同服务器端fd。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;span-id-app应用层httpspan&#34;&gt;&lt;span id = &#34;app&#34;&gt;应用层(HTTP)&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;HTTP协议工作在应用层，端口号是80。HTTP协议被用于网络中两台计算机间的通信，相比于TCP/IP这些底层协议，HTTP协议更像是高层标记型语言，浏览器根据从服务器得到的HTTP响应体中分别得到报文头，响应头和信息体（HTML正文等），之后将HTML文件解析并呈现在浏览器上。同样，我们在浏览器地址栏输入网址之后，浏览器相当于用户代理帮助我们组织好报文头，请求头和信息体（可选），之后通过网络发送到服务器，，服务器根据请求的内容准备数据。所以如果想要完全弄明白HTTP协议，你需要写一个浏览器 + 一个Web服务器，一侧来生成请求信息，一侧生成响应信息。&lt;/p&gt;
&lt;p&gt;从网络分层模型来看，HTTP工作在应用层，其在传输层由TCP协议为其提供服务。所以可以猜到，HTTP请求前，客户机和服务器之间一定已经通过三次握手建立起连接，其中套接字中服务器一侧的端口号为HTTP周知端口80。在请求和传输数据时也是有讲究的，通常一个页面上不只有文本数据，有时会内嵌很多图片，这时候有两种选择可以考虑。一种是对每一个文件都建立一个TCP连接，传送完数据后立马断开，通过多次这样的操作获取引用的所有数据，但是这样一个页面的打开需要建立多次连接，效率会低很多。另一种是对于有多个资源的页面，传送完一个数据后不立即断开连接，在同一次连接下多次传输数据直至传完，但这种情况有可能会长时间占用服务器资源，降低吞吐率。上述两种模式分别是HTTP 1.0和HTTP 1.1版本的默认方式，具体是什么含义会在后面详细解释。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP工作流程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一次完整的HTTP请求事务包含以下四个环节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;建立起客户机和服务器连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立连接后，客户机发送一个请求给服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器收到请求给予响应信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端浏览器将返回的内容解析并呈现，断开连接。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;HTTP协议结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请求报文&lt;/p&gt;
&lt;p&gt;对于HTTP请求报文我们可以通过以下两种方式比较直观的看到：一是在浏览器调试模式下（F12）看请求响应信息，二是通过wireshark或者tcpdump抓包实现。通过前者看到的数据更加清晰直观，通过后者抓到的数据更真实。但无论是用哪种方式查看，得到的请求报文主题体信息都是相同的，对于请求报文，主要包含以下四个部分，每一行数据必须通过&amp;quot;\r\n&amp;quot;分割，这里可以理解为行末标识符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;报文头（只有一行）&lt;/p&gt;
&lt;p&gt;结构：method  uri  version&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;method&lt;/p&gt;
&lt;p&gt;HTTP的请求方法，一共有9中，但GET和POST占了99%以上的使用频次。GET表示向特定资源发起请求，当然也能提交部分数据，不过提交的数据以明文方式出现在URL中。POST通常用于向指定资源提交数据进行处理，提交的数据被包含在请求体中，相对而言比较安全些。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;uri&lt;/p&gt;
&lt;p&gt;用来指代请求的文件，≠URL。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;version&lt;/p&gt;
&lt;p&gt;HTTP协议的版本，该字段有HTTP/1.0和HTTP/1.1两种。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求头（多行）&lt;/p&gt;
&lt;p&gt;在HTTP/1.1中，请求头除了Host都是可选的。包含的头五花八门，这里只介绍部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Host：指定请求资源的主机和端口号。端口号默认80。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Connection：值为keep-alive和close。keep-alive使客户端到服务器的连接持续有效，不需要每次重连，此功能为HTTP/1.1预设功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Accept：浏览器可接收的MIME类型。假设为text/html表示接收服务器回发的数据类型为text/html，如果服务器无法返回这种类型，返回406错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cache-control：缓存控制，Public内容可以被任何缓存所缓存，Private内容只能被缓存到私有缓存，non-cache指所有内容都不会被缓存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cookie：将存储在本地的Cookie值发送给服务器，实现无状态的HTTP协议的会话跟踪。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Content-Length：请求消息正文长度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另有User-Agent、Accept-Encoding、Accept-Language、Accept-Charset、Content-Type等请求头这里不一一罗列。由此可见，请求报文是告知服务器请求的内容，而请求头是为了提供服务器一些关于客户机浏览器的基本信息，包括编码、是否缓存等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空行（一行）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可选消息体（多行）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;响应报文&lt;/p&gt;
&lt;p&gt;响应报文是服务器对请求资源的响应，通过上面提到的方式同样可以看到，同样地，数据也是以&amp;quot;\r\n&amp;quot;来分割。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;报文头（一行）&lt;/p&gt;
&lt;p&gt;结构：version status_code status_message&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;version&lt;/p&gt;
&lt;p&gt;描述所遵循的HTTP版本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;status_code&lt;/p&gt;
&lt;p&gt;状态码，指明对请求处理的状态，常见的如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;200：成功。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;301：内容已经移动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;400：请求不能被服务器理解。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;403：无权访问该文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;404：不能找到请求文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;500：服务器内部错误。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;501：服务器不支持请求的方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;505：服务器不支持请求的版本。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;status_message&lt;/p&gt;
&lt;p&gt;显示和状态码等价英文描述。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;响应头（多行）&lt;/p&gt;
&lt;p&gt;这里只罗列部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Date：表示信息发送的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Server：Web服务器用来处理请求的软件信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Content-Encoding：Web服务器表明了自己用什么压缩方法压缩对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Content-Length：服务器告知浏览器自己响应的对象长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Content-Type：告知浏览器响应对象类型。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空行（一行）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信息体（多行）&lt;/p&gt;
&lt;p&gt;实际有效数据，通常是HTML格式的文件，该文件被浏览器获取到之后解析呈现在浏览器中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;CGI与环境变量&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CGI程序&lt;/p&gt;
&lt;p&gt;服务器为客户端提供动态服务首先需要解决的是得到用户提供的参数再根据参数信息返回。为了和客户端进行交互，服务器需要先创建子进程，之后子进程执行相应的程序去为客户服务。CGI正是帮助我们解决参数获取、输出结果的。&lt;/p&gt;
&lt;p&gt;动态内容获取其实请求报文的头部和请求静态数据时完全相同，但请求的资源从静态的HTML文件变成了后台程序。服务器收到请求后fork()一个子进程，子进程执行请求的程序，这样的程序称为CGI程序（Python、Perl、C++等均可）。通常在服务器中我们会预留一个单独的目录（cgi-bin）用来存放所有的CGI程序，请求报文头部中请求资源的前缀都是/cgi-bin，之后加上所请求调用的CGI程序即可。&lt;/p&gt;
&lt;p&gt;所以上述流程就是：客户端请求程序 -&amp;gt; 服务器fork()子进程 -&amp;gt; 执行被请求程序。接下来需要解决的问题就是如何获取客户端发送过来的参数和输出信息怎么传递回客户端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;环境变量&lt;/p&gt;
&lt;p&gt;对CGI程序来说，CGI环境变量在创建时被初始化，结束时被销毁。当CGI程序被HTTP服务器调用时，因为是被服务器fork()出来的子进程，所以其继承了其父进程的环境变量，这些环境变量包含了很多基本信息，请求头中和响应头中列出的内容（比如用户Cookie、客户机主机名、客户机IP地址、浏览器信息等），CGI程序所需要的参数也在其中。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GET方法下参数获取&lt;/p&gt;
&lt;p&gt;服务器把接收到的参数数据编码到环境变量QUERY_STRING中，在请求时只需要直接把参数写到URL最后即可，比如&amp;quot;http:127.0.0.1:80/cgi-bin/test?a=1&amp;amp;b=2&amp;amp;c=3&amp;quot;，表示请求cgi-bin目录下test程序，&#39;?&#39;之后部分为参数，多个参数用&#39;&amp;amp;&#39;分割开。服务器接收到请求后环境变量QUERY_STRING的值即为a=1&amp;amp;b=2&amp;amp;c=3。&lt;/p&gt;
&lt;p&gt;在CGI程序中获取环境变量值的方法是：getenv()，比如我们需要得到上述QUERY_STRING的值，只需要下面这行语句就可以了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  char *value = getenv(&amp;quot;QUERY_STRING&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后对获得的字符串处理一下提取出每个参数信息即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;POST方法下参数获取&lt;/p&gt;
&lt;p&gt;POST方法下，CGI可以直接从服务器标准输入获取数据，不过要先从CONTENT_LENGTH这个环境变量中得到POST参数长度，再获取对应长度内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;会话机制&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;HTTP作为无状态协议，必然需要在某种方式保持连接状态。这里简要介绍一下Cookie和Session。

- Cookie

    Cookie是客户端保持状态的方法。

    Cookie简单的理解就是存储由服务器发至客户端并由客户端保存的一段字符串。为了保持会话，服务器可以在响应客户端请求时将Cookie字符串放在Set-Cookie下，客户机收到Cookie之后保存这段字符串，之后再请求时候带上Cookie就可以被识别。

    除了上面提到的这些，Cookie在客户端的保存形式可以有两种，一种是会话Cookie一种是持久Cookie，会话Cookie就是将服务器返回的Cookie字符串保持在内存中，关闭浏览器之后自动销毁，持久Cookie则是存储在客户端磁盘上，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。需要说明的是，存储在磁盘中的Cookie是可以被多个浏览器代理所共享的。

- Session

    Session是服务器保持状态的方法。

    首先需要明确的是，Session保存在服务器上，可以保存在数据库、文件或内存中，每个用户有独立的Session用户在客户端上记录用户的操作。我们可以理解为每个用户有一个独一无二的Session ID作为Session文件的Hash键，通过这个值可以锁定具体的Session结构的数据，这个Session结构中存储了用户操作行为。

当服务器需要识别客户端时就需要结合Cookie了。每次HTTP请求的时候，客户端都会发送相应的Cookie信息到服务端。实际上大多数的应用都是用Cookie来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在Cookie里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。如果客户端的浏览器禁用了Cookie，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如sid=xxxxx这样的参数，服务端据此来识别用户，这样就可以帮用户完成诸如用户名等信息自动填入的操作了。
&lt;/code&gt;&lt;/pre&gt;
">计网</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/hai-liang-shu-ju-chu-li/"" data-c="
          &lt;h1 id=&#34;海量数据处理&#34;&gt;海量数据处理&lt;/h1&gt;
&lt;h2 id=&#34;top-n问题&#34;&gt;TOP N问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;如何在海量数据中找出重复最多一个。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过hash映射为小文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过hash_map统计各个小文件重读最多的并记录次数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对每个小文件重复最多的进行建立大根堆&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;上亿有重数据，统计最多前N个。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内存存不下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过hash映射为小文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过hash_map统计各个小文件重读最多的并记录次数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对每个小文件重复最多的进行建立大根堆并重复N次取走堆顶并重建堆操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存存得下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接内存通过hash_map统计并建大根堆&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重复N次取走堆顶并重建堆操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;海量日志数据，提取出某日访问百度次数最多的那个IP（同1）。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将IP % 1000映射到1000个小文件中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;相同IP会被映射到同一个文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不会出现累加和更大情况&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分1000次在内存处理小文件，得到频率最大IP（使用map统计）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对这1000个IP建立大根堆&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;1000w查询串统计最热门10个（同2）。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;同上&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;1G的文件，里面1行1个不超过16字节的词。内存限制1M，返回频数最高前100（同2）。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将单词 % 5000存入5000小文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;平均各文件约200K&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对超过1M的文件继续分割直到小于200K&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用map统计各个词出现的频率&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对5000词使用堆排序或归并排序&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分布式top-n问题&#34;&gt;分布式TOP N问题&lt;/h2&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;分布在100台电脑的海量数据，统计前十。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;各数据只出现在一台机器中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;先在独立机器得到前十&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;若可以放入内存直接堆排序&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若不可全放入内存：哈希分块 -&amp;gt; map统计 -&amp;gt; 归总堆排&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再将100台计算机的TOP10组合起来堆排序&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同一元素可同时出现在不同机器中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;遍历所有数据，重新hash取模，使同一个元素只出现在单独的一台电脑中，然后采用上面方法先统计每台电脑TOP10再汇总起来&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;快速外排序问题&#34;&gt;快速外排序问题&lt;/h2&gt;
&lt;ol start=&#34;7&#34;&gt;
&lt;li&gt;有10个1G文件，每行都是一个可重复用户query，按query频度排序。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;顺序读取十个文件并采取哈希，将query写入10个文件中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过hash_map(query, count)统计每个query出现次数，至少2G内存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过得到的hash_map中query和query_count，对query_count排序并将重新输出到文件中，得到已排序好的文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对十个文件进行归并排序（外排序）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;公共数据问题&#34;&gt;公共数据问题&lt;/h2&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;A,B两个文件各存放50亿url，每个为64Byte，限制内存4G找出公共url。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对A和B两个大文件，先通过url % 1000将数据映射到1000个文件中，单个文件大小约320M（我们只需要检查对应小文件A1 V B1......，不对应小文件不会有相同url）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过hash_set统计，把A1的url存储到hash_set中，再遍历对应的B1小文件，检查是否在hash_set中，若存在则写入外存。重复循环处理对应的1000个对。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;9&#34;&gt;
&lt;li&gt;1000w有重字符串，对字符串去重。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;先hash分为多个文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逐个文件检查并插入set中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多个set取交集&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内存内top-n问题&#34;&gt;内存内TOP N问题&lt;/h2&gt;
&lt;ol start=&#34;10&#34;&gt;
&lt;li&gt;100w个数字找出最大100个。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;堆排序法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建大根堆，取走堆顶并重建堆，重复100次&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;快排法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用快速排序划分，若某次枢纽元在后10000时（具体情况具体分析），对后10000数据排序后取前100&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;位图法&#34;&gt;位图法&lt;/h2&gt;
&lt;ol start=&#34;11&#34;&gt;
&lt;li&gt;在2.5亿数字中找出不重复的整数。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用2-Bit位图法，00表示不存在，01表示出现一次，10表示出现多次，11无意义。这样只需要1G内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;或者hash划分小文件，小文件使用hash_set检查各个元素，得到的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;12&#34;&gt;
&lt;li&gt;如何在40亿数字中快速判断是否有某个数？&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;位图法标记某个数字是否存在，check标记数组。&lt;/li&gt;
&lt;/ul&gt;
">海量数据处理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/cao-zuo-xi-tong/"" data-c="
          &lt;h1 id=&#34;操作系统&#34;&gt;操作系统&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;面向进程和线程学习操作系统。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;目录&#34;&gt;目录&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 4&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 5&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;#thread&#34;&gt;进程线程模型&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;#con&#34;&gt;进程间通信&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;#mutex&#34;&gt;同步互斥机制&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;#mem&#34;&gt;存储管理&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;#netio&#34;&gt;网络I/O模型&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h1 id=&#34;内容&#34;&gt;内容&lt;/h1&gt;
&lt;h3 id=&#34;span-id-thread进程线程模型span&#34;&gt;&lt;span id = &#34;thread&#34;&gt;进程线程模型&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;线程和进程的概念已经在操作系统书中被翻来覆去讲了很多遍。很多概念虽然都是套话，但没能理解透其中深意会导致很多内容理解不清晰。对于进程和线程的理解和把握可以说基本奠定了对系统的认知和把控能力。其核心意义绝不仅仅是“线程是调度的基本单位，进程是资源分配的基本单位”这么简单。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们这里讨论的是用户态的多线程模型，同一个进程内部有多个线程，所有的线程共享同一个进程的内存空间，进程中定义的全局变量会被所有的线程共享，比如有全局变量int i = 10，这一进程中所有并发运行的线程都可以读取和修改这个i的值，而多个线程被CPU调度的顺序又是不可控的，所以对临界资源的访问尤其需要注意安全。我们必须知道，做一次简单的i = i + 1在计算机中并不是原子操作，涉及内存取数，计算和写入内存几个环节，而线程的切换有可能发生在上述任何一个环节中间，所以不同的操作顺序很有可能带来意想不到的结果。&lt;/p&gt;
&lt;p&gt;但是，虽然线程在安全性方面会引入许多新挑战，但是线程带来的好处也是有目共睹的。首先，原先顺序执行的程序（暂时不考虑多进程）可以被拆分成几个独立的逻辑流，这些逻辑流可以独立完成一些任务（最好这些任务是不相关的）。比如QQ可以一个线程处理聊天一个线程处理上传文件，两个线程互不干涉，在用户看来是同步在执行两个任务，试想如果线性完成这个任务的话，在数据传输完成之前用户聊天被一直阻塞会是多么尴尬的情况。&lt;/p&gt;
&lt;p&gt;对于线程，我认为弄清以下两点非常重要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;线程之间有无先后访问顺序（线程依赖关系）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多个线程共享访问同一变量（同步互斥问题）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，我们通常只会去说同一进程的多个线程共享进程的资源，但是每个线程特有的部分却很少提及，除了标识线程的tid，每个线程还有自己独立的栈空间，线程彼此之间是无法访问其他线程栈上内容的。而作为处理机调度的最小单位，线程调度只需要保存线程栈、寄存器数据和PC即可，相比进程切换开销要小很多。&lt;/p&gt;
&lt;p&gt;线程相关接口不少，主要需要了解各个参数意义和返回值意义。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;线程创建和结束&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;背景知识：&lt;/p&gt;
&lt;p&gt;在一个文件内的多个函数通常都是按照main函数中出现的顺序来执行，但是在分时系统下，我们可以让每个函数都作为一个逻辑流并发执行，最简单的方式就是采用多线程策略。在main函数中调用多线程接口创建线程，每个线程对应特定的函数（操作），这样就可以不按照main函数中各个函数出现的顺序来执行，避免了忙等的情况。线程基本操作的接口如下。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相关接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建线程：int pthread_create(pthread_t *pthread, const pthread_attr_t *attr, void *(*start_routine)(void *), void *agr);&lt;/p&gt;
&lt;p&gt;创建一个新线程，pthread和start_routine不可或缺，分别用于标识线程和执行体入口，其他可以填NULL。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;pthread：用来返回线程的tid，*pthread值即为tid，类型pthread_t == unsigned long int。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;attr：指向线程属性结构体的指针，用于改变所创线程的属性，填NULL使用默认值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;start_routine：线程执行函数的首地址，传入函数指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;arg：通过地址传递来传递函数参数，这里是无符号类型指针，可以传任意类型变量的地址，在被传入函数中先强制类型转换成所需类型即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获得线程ID：pthread_t pthread_self();&lt;/p&gt;
&lt;p&gt;调用时，会打印线程ID。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待线程结束：int pthread_join(pthread_t tid, void** retval);&lt;/p&gt;
&lt;p&gt;主线程调用，等待子线程退出并回收其资源，类似于进程中wait/waitpid回收僵尸进程，调用pthread_join的线程会被阻塞。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;tid：创建线程时通过指针得到tid值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;retval：指向返回值的指针。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结束线程：pthread_exit(void *retval);&lt;/p&gt;
&lt;p&gt;子线程执行，用来结束当前线程并通过retval传递返回值，该返回值可通过pthread_join获得。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;retval：同上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分离线程：int pthread_detach(pthread_t tid);&lt;/p&gt;
&lt;p&gt;主线程、子线程均可调用。主线程中pthread_detach(tid)，子线程中pthread_detach(pthread_self())，调用后和主线程分离，子线程结束时自己立即回收资源。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tid：同上。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程属性值修改&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;背景知识：&lt;/p&gt;
&lt;p&gt;线程属性对象类型为pthread_attr_t，结构体定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;typedef struct{
    int etachstate;    // 线程分离的状态
    int schedpolicy;    // 线程调度策略
    struct sched_param schedparam;    // 线程的调度参数
    int inheritsched;    // 线程的继承性
    int scope;    // 线程的作用域
    // 以下为线程栈的设置
    size_t guardsize;    // 线程栈末尾警戒缓冲大小
    int stackaddr_set;    // 线程的栈设置
    void *    stackaddr;    // 线程栈的位置
    size_t stacksize;    // 线程栈大小
}pthread_arrt_t;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相关接口：&lt;/p&gt;
&lt;p&gt;对上述结构体中各参数大多有：pthread_attr_get***()和pthread_attr_set***()系统调用函数来设置和获取。这里不一一罗列。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程同步&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#mutex&#34;&gt;详见同步互斥专题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;多进程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;每一个进程是资源分配的基本单位。进程结构由以下几个部分组成：代码段、堆栈段、数据段。代码段是静态的二进制代码，多个程序可以共享。实际上在父进程创建子进程之后，父、子进程除了pid外，几乎所有的部分几乎一样，子进程创建时拷贝父进程PCB中大部分内容，而PCB的内容实际上是各种数据、代码的地址或索引表地址，所以复制了PCB中这些指针实际就等于获取了全部父进程可访问数据。所以简单来说，创建新进程需要复制整个PCB，之后操作系统将PCB添加到进程核心堆栈底部，这样就可以被操作系统感知和调度了。&lt;/p&gt;
&lt;p&gt;父、子进程共享全部数据，但并不是说他们就是对同一块数据进行操作，子进程在读写数据时会通过写时复制机制将公共的数据重新拷贝一份，之后在拷贝出的数据上进行操作。如果子进程想要运行自己的代码段，还可以通过调用execv()函数重新加载新的代码段，之后就和父进程独立开了。我们在shell中执行程序就是通过shell进程先fork()一个子进程再通过execv()重新加载新的代码段的过程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;进程创建与结束&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;背景知识：&lt;/p&gt;
&lt;p&gt;进程有两种创建方式，一种是操作系统创建的一种是父进程创建的。从计算机启动到终端执行程序的过程为：0号进程 -&amp;gt; 1号内核进程 -&amp;gt; 1号用户进程(init进程) -&amp;gt; getty进程 -&amp;gt; shell进程 -&amp;gt; 命令行执行进程。所以我们在命令行中通过 ./program执行可执行文件时，所有创建的进程都是shell进程的子进程，这也就是为什么shell一关闭，在shell中执行的进程都自动被关闭的原因。从shell进程到创建其他子进程需要通过以下接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相关接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建进程：pid_t fork(void);&lt;/p&gt;
&lt;p&gt;返回值：出错返回-1；父进程中返回pid &amp;gt; 0；子进程中pid == 0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结束进程：void exit(int status);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;status是退出状态，保存在全局变量中S?，通常0表示正常退出。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获得PID：pid_t getpid(void);&lt;/p&gt;
&lt;p&gt;返回调用者pid。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获得父进程PID：pid_t getppid(void);&lt;/p&gt;
&lt;p&gt;返回父进程pid。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他补充：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;正常退出方式：exit()、_exit()、return（在main中）。&lt;/p&gt;
&lt;p&gt;exit()和_exit()区别：exit()是对_exit()的封装，都会终止进程并做相关收尾工作，最主要的区别是_exit()函数关闭全部描述符和清理函数后不会刷新流，但是exit()会在调用_exit()函数前刷新数据流。&lt;/p&gt;
&lt;p&gt;return和exit()区别：exit()是函数，但有参数，执行完之后控制权交给系统。return若是在调用函数中，执行完之后控制权交给调用进程，若是在main函数中，控制权交给系统。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异常退出方式：abort()、终止信号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;僵尸进程、孤儿进程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;背景知识：&lt;/p&gt;
&lt;p&gt;父进程在调用fork接口之后和子进程已经可以独立开，之后父进程和子进程就以未知的顺序向下执行（异步过程）。所以父进程和子进程都有可能先执行完。当父进程先结束，子进程此时就会变成孤儿进程，不过这种情况问题不大，孤儿进程会自动向上被init进程收养，init进程完成对状态收集工作。而且这种过继的方式也是守护进程能够实现的因素。如果子进程先结束，父进程并未调用wait或者waitpid获取进程状态信息，那么子进程描述符就会一直保存在系统中，这种进程称为僵尸进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相关接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;回收进程（1）：pid_t wait(int *status);&lt;/p&gt;
&lt;p&gt;一旦调用wait()，就会立即阻塞自己，wait()自动分析某个子进程是否已经退出，如果找到僵尸进程就会负责收集和销毁，如果没有找到就一直阻塞在这里。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;status：指向子进程结束状态值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;回收进程（2）：pid_t waitpid(pid_t pid, int *status, int options);&lt;/p&gt;
&lt;p&gt;返回值：返回pid：返回收集的子进程id。返回-1：出错。返回0：没有被手机的子进程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;pid：子进程识别码，控制等待哪些子进程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;pid &amp;lt; -1，等待进程组识别码为pid绝对值的任何进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pid = -1，等待任何子进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pid = 0，等待进程组识别码与目前进程相同的任何子进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pid &amp;gt; 0，等待任何子进程识别码为pid的子进程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;status：指向返回码的指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;options：选项决定父进程调用waitpid后的状态。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;options = WNOHANG，即使没有子进程退出也会立即返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;options = WUNYRACED，子进程进入暂停马上返回，但结束状态不予理会。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;守护进程&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;背景知识：&lt;/p&gt;
&lt;p&gt;守护进程是脱离终端并在后台运行的进程，执行过程中信息不会显示在终端上并且也不会被终端发出的信号打断。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建子进程，父进程退出：fork() + if(pid &amp;gt; 0){exit(0);}，使子进程称为孤儿进程被init进程收养。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在子进程中创建新会话：setsid()。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;改变当前目录结构为根：chdir(&amp;quot;/&amp;quot;)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重设文件掩码：umask(0)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭文件描述符：for(int i = 0; i &amp;lt; 65535; ++i){close(i);}。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Linux进程控制&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;进程地址空间（地址空间）&lt;/p&gt;
&lt;p&gt;虚拟存储器为每个进程提供了独占系统地址空间的假象。尽管每个进程地址空间内容不尽相同，但是他们的都有相似的结构。X86 Linux进程的地址空间底部是保留给用户程序的，包括文本、数据、堆、栈等，其中文本区和数据区是通过存储器映射方式将磁盘中可执行文件的相应段映射至虚拟存储器地址空间中。有一些&amp;quot;敏感&amp;quot;的地址需要注意下，对于32位进程来说，代码段从0x08048000开始。从0xC0000000开始到0xFFFFFFFF是内核地址空间，通常情况下代码运行在用户态（使用0x00000000 ~ 0xC00000000的用户地址空间），当发生系统调用、进程切换等操作时CPU控制寄存器设置模式位，进入内和模式，在该状态（超级用户模式）下进程可以访问全部存储器位置和执行全部指令。也就说32位进程的地址空间都是4G，但用户态下只能访问低3G的地址空间，若要访问3G ~ 4G的地址空间则只有进入内核态才行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程控制块（处理机）&lt;/p&gt;
&lt;p&gt;进程的调度实际就是内核选择相应的进程控制块，被选择的进程控制块中包含了一个进程基本的信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上下文切换&lt;/p&gt;
&lt;p&gt;内核管理所有进程控制块，而进程控制块记录了进程全部状态信息。每一次进程调度就是一次上下文切换，所谓的上下文本质上就是当前运行状态，主要包括通用寄存器、浮点寄存器、状态寄存器、程序计数器、用户栈和内核数据结构（页表、进程表、文件表）等。进程执行时刻，内核可以决定抢占当前进程并开始新的进程，这个过程由内核调度器完成，当调度器选择了某个进程时称为该进程被调度，该过程通过上下文切换来改变当前状态。一次完整的上下文切换通常是进程原先运行于用户态，之后因系统调用或时间片到切换到内核态执行内核指令，完成上下文切换后回到用户态，此时已经切换到进程B。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;线程、进程比较&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于进程和线程的区别这里就不一一罗列了，主要对比下线程和进程操作中主要的接口。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;fork()和pthread_create()&lt;/p&gt;
&lt;p&gt;负责创建。调用fork()后返回两次，一次标识主进程一次标识子进程；调用pthread_create()后得到一个可以独立执行的线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wait()和pthread_join()&lt;/p&gt;
&lt;p&gt;负责回收。调用wait()后父进程阻塞；调用pthread_join()后主线程阻塞。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;exit()和pthread_exit()&lt;/p&gt;
&lt;p&gt;负责退出。调用exit()后调用进程退出，控制权交给系统；调用pthread_exit()后线程退出，控制权交给主线程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;span-id-con进程间通信span&#34;&gt;&lt;span id = &#34;con&#34;&gt;进程间通信&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;Linux几乎支持全部UNIX进程间通信方法，包括管道（有名管道和无名管道）、消息队列、共享内存、信号量和套接字。其中前四个属于同一台机器下进程间的通信，套接字则是用于网络通信。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;管道&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无名管道&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无名管道特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;无名管道是一种特殊的文件，这种文件只存在于内存中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无名管道只能用于父子进程或兄弟进程之间，必须用于具有亲缘关系的进程间的通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无名管道只能由一端向另一端发送数据，是半双工方式，如果双方需要同时收发数据需要两个管道。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相关接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;int pipe(int fd[2]);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fd[2]：管道两端用fd[0]和fd[1]来描述，读的一端用fd[0]表示，写的一端用fd[1]表示。通信双方的进程中写数据的一方需要把fd[0]先close掉，读的一方需要先把fd[1]给close掉。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有名管道：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有名管道特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有名管道是FIFO文件，存在于文件系统中，可以通过文件路径名来指出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无名管道可以在不具有亲缘关系的进程间进行通信。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相关接口：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;int mkfifo(const char *pathname, mode_t mode);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;pathname：即将创建的FIFO文件路径，如果文件存在需要先删除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mode：和open()中的参数相同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;消息队列&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;共享内存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程可以将同一段共享内存连接到它们自己的地址空间，所有进程都可以访问共享内存中的地址，如果某个进程向共享内存内写入数据，所做的改动将立即影响到可以访问该共享内存的其他所有进程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;相关接口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建共享内存：int shmget(key_t key, int size, int flag);&lt;/p&gt;
&lt;p&gt;成功时返回一个和key相关的共享内存标识符，失败范湖范围-1。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;key：为共享内存段命名，多个共享同一片内存的进程使用同一个key。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;size：共享内存容量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;flag：权限标志位，和open的mode参数一样。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接到共享内存地址空间：void *shmat(int shmid, void *addr, int flag);&lt;/p&gt;
&lt;p&gt;返回值即共享内存实际地址。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;shmid：shmget()返回的标识。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;addr：决定以什么方式连接地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;flag：访问模式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从共享内存分离：int shmdt(const void *shmaddr);&lt;/p&gt;
&lt;p&gt;调用成功返回0，失败返回-1。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;shmaddr：是shmat()返回的地址指针。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他补充&lt;/p&gt;
&lt;p&gt;共享内存的方式像极了多线程中线程对全局变量的访问，大家都对等地有权去修改这块内存的值，这就导致在多进程并发下，最终结果是不可预期的。所以对这块临界区的访问需要通过信号量来进行进程同步。&lt;/p&gt;
&lt;p&gt;但共享内存的优势也很明显，首先可以通过共享内存进行通信的进程不需要像无名管道一样需要通信的进程间有亲缘关系。其次内存共享的速度也比较快，不存在读取文件、消息传递等过程，只需要到相应映射到的内存地址直接读写数据即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;信号量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在提到共享内存方式时也提到，进程共享内存和多线程共享全局变量非常相似。所以在使用内存共享的方式是也需要通过信号量来完成进程间同步。多线程同步的信号量是POSIX信号量，&lt;br&gt;
而在进程里使用SYSTEM  V信号量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;相关接口&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建信号量：int semget(key_t key, int nsems, int semflag);&lt;/p&gt;
&lt;p&gt;创建成功返回信号量标识符，失败返回-1。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;key：进程pid。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nsems：创建信号量的个数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;semflag：指定信号量读写权限。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;改变信号量值：int semop(int semid, struct sembuf *sops, unsigned nsops);&lt;/p&gt;
&lt;p&gt;我们所需要做的主要工作就是串讲sembuf变量并设置其值，然后调用semop，把设置好的sembuf变量传递进去。&lt;/p&gt;
&lt;p&gt;struct sembuf结构体定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;struct sembuf{
    short sem_num;
    short sem_op;
    short sem_flg;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功返回信号量标识符，失败返回-1。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;semid：信号量集标识符，由semget()函数返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sops：指向struct sembuf结构的指针，先设置好sembuf值再通过指针传递。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nsops：进行操作信号量的个数，即sops结构变量的个数，需大于或等于1。最常见设置此值等于1，只完成对一个信号量的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接控制信号量信息：int semctl(int semid, int semnum, int cmd, union semun arg);&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;semid：信号量集标识符。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;semnum：信号量集数组上的下标，表示某一个信号量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;arg：union semun类型。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;辅助命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ipcs命令用于报告共享内存、信号量和消息队列信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ipcs -a：列出共享内存、信号量和消息队列信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ipcs -l：列出系统限额。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ipcs -u：列出当前使用情况。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;套接字&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/linw7/Skill-Tree/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md&#34;&gt;详见socket交互流程&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;#netio&#34;&gt;详见网络I/O模型&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;span-id-mutex同步互斥机制span&#34;&gt;&lt;span id = &#34;mutex&#34;&gt;同步互斥机制&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;待补充&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;span-id-netio网络io模型span&#34;&gt;&lt;span id = &#34;netio&#34;&gt;网络I/O模型&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在描述这块内容的诸多书籍中，很多都只说笼统的概念，我们将问题具体化，暂时只考虑服务器端的网络I/O情形。我们假定目前的情形是服务器已经在监听用户请求，建立连接后服务器调用read()函数等待读取用户发送过来的数据流，之后将接收到的数据打印出来。&lt;/p&gt;
&lt;p&gt;所以服务器端简单是这样的流程：建立连接 -&amp;gt; 监听请求 -&amp;gt; 等待用户数据 -&amp;gt; 打印数据。我们总结网络通信中的等待：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;建立连接时等待对方的ACK包（TCP）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待客户端请求（HTTP）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输入等待：服务器用户数据到达内核缓冲区（read函数等待）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出等待：用户端等待缓冲区有足够空间可以输入（write函数等待）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外为了能够解释清楚网络I/O模型，还需要了解一些基础。对服务器而言，打印出用户输入的字符串（printf函数）和从网络中获取数据（read函数）需要单独来看。服务器首先accept用户连接请求后首先调用read函数等待数据，这里的read函数是系统调用，运行于内核态，使用的也是内核地址空间，并且从网络中取得的数据需要先写入到内核缓冲区。当read系统调用获取到数据后将这些数据再复制到用户地址空间的用户缓冲区中，之后返回到用户态执行printf函数打印字符串。我们需要明确两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;read执行在内核态且数据流先读入内核缓冲区；printf运行于用户态，打印的数据会先从内核缓冲区复制到进程的用户缓冲区，之后打印出来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;printf函数一定是在read函数已经准备好数据之后才能执行，但read函数作为I/O操作通常需要等待而触发阻塞。调用read函数的是服务器进程，一旦被read调用阻塞，整个服务器在获取到用户数据前都不能接受任何其他用户的请求（单进程/线程）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了上面的基础，我们就可以介绍下面四种网路I/O模型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阻塞式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;阻塞表示一旦调用I/O函数必须等整个I/O完成才返回。正如上面提到的那种情形，当服务器调用了read函数之后，如果不是立即接收到数据，服务器进程会被阻塞，之后一直在等待用户数据到达，用户数据到达后首先会写进内核缓冲区，之后内核缓冲区数据复制到用户进程（服务器进程）缓冲区。完成了上述所有的工作后，才会把执行权限返回给用户（从内核态 -&amp;gt; 用户态）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;很显然，阻塞式I/O的效率实在太低，如果用户输入数据迟迟不到的话，整个服务器就会一直被阻塞（单进程/线程）。为了不影响服务器接收其他进程的连接，我们可以考虑多进程模型，这样当服务器建立连接后为连接的用户创建新线程，新线程即使是使用阻塞式I/O也仅仅是这一个线程被阻塞，不会影响服务器等待接收新的连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多线程模型下，主线程等待用户请求，用户有请求到达时创建新线程。新线程负责具体的工作，即使是因为调用了read函数被阻塞也不会影响服务器。我们还可以进一步优化创建连接池和线程池以减小频繁调用I/O接口的开销。但新问题随之产生，每个新线程或者进程（加入使用对进程模型）都会占用大量系统资源，除此之外过多的线程和进程在调度方面开销也会大很对，所以这种模型并不适合大并发量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;非阻塞I/O&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;阻塞和非阻塞最大的区别在于调用I/O系统调用后，是等整个I/O过程完成再把操作权限返回给用户还是会立即返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以使用以下语句将句柄fd设置为非阻塞I/O：fcntl(fd, F_SETFL, O_NONBLOCK);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非阻塞I/O在调用后会立即返回，用户进程对返回的返回值判断以区分是否完成了I/O。如果返回大于0表示完成了数据读取，返回值即读取的字节数；返回0表示连接已经正常断开；返回-1表示错误，接下来用户进程会不停地询问kernel是否准备完毕。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非阻塞I/O虽然不再会完全阻塞用户进程，但实际上由于用户进程需要不停地询问kernel是否准备完数据，所以整体效率依旧非常低，不适合做并发。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;I/O多路复用（事件驱动模型）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面已经论述了多进程、多进程模型会因为开销巨大和调度困难而导致并不能承受高并发量。但不适用这种模型的话，无论是阻塞还是非阻塞方式都会导致整个服务器停滞。&lt;/p&gt;
&lt;p&gt;所以对于大并发量，我们需要一种代理模型可以帮助我们集中去管理所有的socket连接，一旦某个socket数据到达了就执行其对应的用户进程，I/O多路复用就是这么一种模型。Linux下I/O多路复用的系统调用有select，poll和epoll，但从本质上来讲他们都是同步I/O范畴。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;select&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;相关接口：&lt;/p&gt;
&lt;p&gt;int select (int maxfd, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout);&lt;/p&gt;
&lt;p&gt;FD_ZERO(int fd, fd_set* fds)    //清空集合&lt;/p&gt;
&lt;p&gt;FD_SET(int fd, fd_set* fds)    //将给定的描述符加入集合&lt;/p&gt;
&lt;p&gt;FD_ISSET(int fd, fd_set* fds)    //将给定的描述符从文件中删除&lt;/p&gt;
&lt;p&gt;FD_CLR(int fd, fd_set* fds)    //判断指定描述符是否在集合中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数：&lt;br&gt;
maxfd：当前最大文件描述符的值+1（≠ MAX_CONN）。&lt;/p&gt;
&lt;p&gt;readfds：指向读文件队列集合（fd_set）的指针。&lt;/p&gt;
&lt;p&gt;writefds：同上，指向读集合的指针。&lt;/p&gt;
&lt;p&gt;writefds：同上，指向错误集合的指针。&lt;/p&gt;
&lt;p&gt;timeout：指向timeval结构指针，用于设置超时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他：&lt;/p&gt;
&lt;p&gt;判断和操作对象为set_fd集合，集合大小为单个进程可打开的最大文件数1024或2048（可重新编译内核修改但不建议）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;poll&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;相关接口：&lt;br&gt;
int poll(struct pollfd *fds, unsigned int nfds, int timeout);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结构体定义：&lt;br&gt;
struct pollfd{&lt;br&gt;
int fd;    // 文件描述符&lt;br&gt;
short events;    // 等到的事件&lt;br&gt;
short revents;    // 实际发生的事件&lt;br&gt;
}&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数：&lt;br&gt;
fds：指向pollfd结构体数组的指针。&lt;/p&gt;
&lt;p&gt;nfds：pollfd数组当前已被使用的最大下标。&lt;/p&gt;
&lt;p&gt;timeout：等待毫秒数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他：&lt;/p&gt;
&lt;p&gt;判断和操作对象是元素为pollfd类型的数组，数组大小自己设定，即为最大连接数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;epoll&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;相关接口：&lt;br&gt;
int epoll_create(int size);    // 创建epoll句柄&lt;br&gt;
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);    // 事件注册函数&lt;br&gt;
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结构体定义：&lt;br&gt;
struct epoll_event{&lt;br&gt;
__uint32_t events;&lt;br&gt;
epoll_data_t data;&lt;br&gt;
};&lt;br&gt;
typedef union epoll_data{&lt;br&gt;
void *ptr;&lt;br&gt;
int fd;&lt;br&gt;
__uint32_t u32;&lt;br&gt;
__uint64_t u64;&lt;br&gt;
}epoll_data_t;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数：&lt;/p&gt;
&lt;p&gt;size：用来告诉内核要监听的数目。&lt;/p&gt;
&lt;p&gt;epfd：epoll函数的返回值。&lt;/p&gt;
&lt;p&gt;op：表示动作（EPOLL_CTL_ADD/EPOLL_CTL_FD/EPOLL_CTL_DEL）。&lt;/p&gt;
&lt;p&gt;fd：需要监听的fd。&lt;/p&gt;
&lt;p&gt;events：指向epoll_event的指针，该结构记录监听的事件。&lt;/p&gt;
&lt;p&gt;maxevents：告诉内核events的大小。&lt;/p&gt;
&lt;p&gt;timeout：超时时间（ms为单位，0表示立即返回，-1将不确定）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;select、poll和epoll区别&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;操作方式及效率：&lt;/p&gt;
&lt;p&gt;select是遍历，需要遍历fd_set每一个比特位（= MAX_CONN），O(n)；poll是遍历，但只遍历到pollfd数组当前已使用的最大下标（≠ MAX_CONN），O(n)；epoll是回调，O(1)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最大连接数：&lt;/p&gt;
&lt;p&gt;select为1024/2048（一个进程打开的文件数是有限制的）；poll无上限；epoll无上限。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;fd拷贝：&lt;/p&gt;
&lt;p&gt;select每次都需要把fd集合从用户态拷贝到内核态；poll每次都需要把fd集合从用户态拷贝到内核态；epoll调用epoll_ctl时拷贝进内核并放到事件表中，但用户进程和内核通过mmap映射共享同一块存储，避免了fd从内核赋值到用户空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他：&lt;/p&gt;
&lt;p&gt;select每次内核仅仅是通知有消息到了需要处理，具体是哪一个需要遍历所有的描述符才能找到。epoll不仅通知有I/O到来还可通过callback函数具体定位到活跃的socket，实现伪AIO。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;异步I/O模型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;上面三种I/O方式均属于同步I/O。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从阻塞式I/O到非阻塞I/O，我们已经做到了调用I/O请求后立即返回，但不停轮询的操作效率又很低，如果能够既像非阻塞I/O能够立即返回又能不一直轮询的话会更符合我们的预期。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;之所以用户进程会不停轮询就是因为在数据准备完毕后内核不会回调用户进程，只能通过用户进程一次又一次轮询来查询I/O结果。如果内核能够在完成I/O后通过消息告知用户进程来处理已经得到的数据自然是最好的，异步I/O就是这么回事。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步I/O就是当用户进程发起I/O请求后立即返回，直到内核发送一个信号，告知进程I/O已完成，在整个过程中，都没有进程被阻塞。看上去异步I/O和非阻塞I/O的区别在于：判断数据是否准备完毕的任务从用户进程本身被委托给内核来完成。这里所谓的异步只是操作系统提供的一直机制罢了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">操作系统</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/bian-cheng-yu-yan-cczhai-zi-linw7/"" data-c="
          &lt;h1 id=&#34;编程语言cc&#34;&gt;编程语言(C/C++)&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;都是语言，为什么英语比C++难这么多呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h1 id=&#34;目录&#34;&gt;目录&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 1&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 2&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 3&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Chapter 4&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;base&#34;&gt;编程基础&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;#oop&#34;&gt;面向对象基础&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;#stl&#34;&gt;标准模板库&lt;/a&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;a href=&#34;#other&#34;&gt;编译及调试&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h1 id=&#34;内容&#34;&gt;内容&lt;/h1&gt;
&lt;h3 id=&#34;span-id-base编程基础span&#34;&gt;&lt;span id = &#34;base&#34;&gt;编程基础&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;C/C++的内容又多又杂，常常看到有人罗列相关书单，觉得毫无意义，我不相信他们真的完全掌握了其中任何一本。学习任何东西，首先要掌握基本概念，基础不牢地动山摇，因为高级的内容都是通过低级的概念来描述的。当基本概念都没理解透，学习再多都是空中楼阁。这里罗列了一些听基本的问题，虽然看着不难，但是精确理解每句话中的每个词真的并不容易。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;变量声明和定义区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;声明仅仅是把变量的声明的位置及类型提供给编译器，并不分配内存空间；定义要在定义的地方为其分配存储空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相同变量可以再多处声明（外部变量extern），但只能在一处定义。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;quot;零值比较&amp;quot;？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;bool类型：if(flag)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;int类型：if(flag == 0)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指针类型：if(flag == null)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;float类型：if((flag &amp;gt;= -0.000001) &amp;amp;&amp;amp; (flag &amp;lt;= 0. 000001))&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;strlen和sizeof区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是&#39;\0&#39;的字符串。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同一不同对象可以互相赋值吗？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以，但含有指针成员时需要注意。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对比类的对象赋值时深拷贝和浅拷贝。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结构体内存对齐问题？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;未特殊说明时，按结构体中size最大的成员对齐（若有double成员），按8字节对齐。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;static作用是什么？在C和C++中有何区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;static可以修饰局部变量（静态局部变量）、全局变量（静态全局变量）和函数，被修饰的变量存储位置在静态区。对于静态局部变量，相对于一般局部变量其生命周期长，直到程序运行结束而非函数调用结束，且只在第一次被调用时定义；对于静态全局变量，相对于全局变量其可见范围被缩小，只能在本文件中可见；修饰函数时作用和修饰全局变量相同，都是为了限定访问域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C++的static除了上述两种用途，还可以修饰类成员（静态成员变量和静态成员函数），静态成员变量和静态成员函数不属于任何一个对象，是所有类实例所共有。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;static的数据记忆性可以满足函数在不同调用期的通信，也可以满足同一个类的多个实例间的通信。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;未初始化时，static变量默认值为0。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结构体和类的区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;结构体的默认限定符是public；类是private。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;- &lt;s&gt;结构体不可以继承，类可以。&lt;/s&gt; C++中结构体也可以继承。&lt;/p&gt;
&lt;ol start=&#34;8&#34;&gt;
&lt;li&gt;
&lt;p&gt;malloc和new的区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;malloc和free是标准库函数，支持覆盖；new和delete是运算符，并且支持重载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指针和引用区别？&lt;br&gt;
   - 引用只是别名，不占用具体存储空间，只有声明没有定义；指针是具体变量，需要占用存储空间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &amp;amp;varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;引用一旦初始化之后就不可以再改变（变量可以被引用为多次，但引用只能作为一个变量引用）；指针变量可以重新指向别的变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不存在指向空值的引用，必须有具体实体；但是存在指向空值的指针。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宏定义和函数有何区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;宏在编译时完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宏函数属于在结构中插入代码，没有返回值；函数调用具有返回值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宏函数参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宏函数不要在最后加分号。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宏定义和const区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;宏替换发生在编译阶段之前，属于文本插入替换；const作用发生于编译过程中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宏不检查类型；const会检查数据类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宏定义的数据没有分配内存空间，只是插入替换掉；const定义的变量只是值不能改变，但要分配内存空间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宏定义和typedef区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宏不检查类型；typedef会检查数据类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;宏定义和内联函数(inline)区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在使用时，宏只做简单字符串替换（编译前）。而内联函数可以进行参数类型检查（编译时），且具有返回值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内联函数本身是函数，强调函数特性，具有重载等功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;条件编译#ifdef, #else, #endif作用？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以通过加#define，并通过#ifdef来判断，将某些具体模块包括进要编译的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用于子程序前加#define DEBUG用于程序调试。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应对硬件的设置（机器类型等）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;条件编译功能if也可实现，但条件编译可以减少被编译语句，从而减少目标程序大小。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;区别以下几种变量？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const int a;
int const a;
const int *a;
int *const a;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;int const a和const int a均表示定义常量类型a。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;const int *a，其中a为指向int型变量的指针，const在 * 左侧，表示a指向不可变常量。(看成const (*a)，对引用加const)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;int *const a，依旧是指针类型，表示a为指向整型数据的常指针。(看成const(a)，对指针const)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;volatile有什么作用？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;volatile定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，而不是读寄存器内的备份。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多线程中被几个任务共享的变量需要定义为volatile类型。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;什么是常引用？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;常引用可以理解为常量指针，形式为const typename &amp;amp; refname = varname。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常引用下，原变量值不会被别名所修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原变量的值可以通过原名修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常引用通常用作只读变量别名或是形参传递。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;区别以下指针类型？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int *p[10]
int (*p)[10]
int *p(int)
int (*p)(int)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;常量指针和指针常量区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;常量指针是一个指针，读成常量的指针，指向一个只读变量。如int const *p或const int *p。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指针常量是一个不能给改变指向的指针。如int *const p。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a和&amp;amp;a有什么区别？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;假设数组int a[10];
int (*p)[10] = &amp;amp;a;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;a是数组名，是数组首元素地址，+1表示地址值加上一个int类型的大小，如果a的值是0x00000001，加1操作后变为0x00000005。*(a + 1) = a[1]。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;amp;a是数组的指针，其类型为int (*)[10]（就是前面提到的数组指针），其加1时，系统会认为是数组首地址加上整个数组的偏移（10个int型变量），值为数组a尾元素后一个元素的地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若(int *)p ，此时输出 *p时，其值为a[0]的值，因为被转为int *类型，解引用时按照int类型大小来读取。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组名和指针（这里为指向数组首元素的指针）区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;二者均可通过增减偏移量来访问数组中的元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增、自减等操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当数组名当做形参传递给调用函数后，就失去了原有特性，退化成一般指针，多了自增、自减操作，但sizeof运算符不能再得到原数组的大小了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;野指针是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;也叫空悬指针，不是指向null的指针，是指向垃圾内存的指针。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;产生原因及解决办法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指针变量未及时初始化 =&amp;gt; 定义指针变量及时初始化，要么置空。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指针free或delete之后没有及时置空 =&amp;gt; 释放操作后立即置空。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;堆和栈的区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;申请方式不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;栈由系统自动分配。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;堆由程序员手动分配。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;申请大小限制不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;栈顶和栈底是之前预设好的，大小固定，可以通过ulimit -a查看，由ulimit -s修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;申请效率不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;栈由系统分配，速度快，不会有碎片。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;堆由程序员分配，速度慢，且会有碎片。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;delete和delete[]区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;delete只会调用一次析构函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;delete[]会调用数组中每个元素的析构函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;span-id-oop面向对象基础span&#34;&gt;&lt;span id = &#34;oop&#34;&gt;面向对象基础&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;能够准确理解下面这些问题是从C程序员向C++程序员进阶的基础。当然了，这只是一部分。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;面向对象三大特性？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;继承性：让某种类型对象获得另一个类型对象的属性和方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;public/protected/private的区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;public的变量和函数在类的内部外部都可以访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;protected的变量和函数只能在类的内部和其派生类中访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;private修饰的元素只能在类内访问。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对象存储空间？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;非静态成员的数据类型大小之和。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译器加入的额外成员变量（如指向虚函数表的指针）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了边缘对齐优化加入的padding。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C++空类有哪些成员函数?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先，空类大小为1字节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认函数有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;构造函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;析构函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拷贝构造函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;赋值运算符&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构造函数能否为虚函数，析构函数呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;析构函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构造函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构造函数不能定义为虚函数。在构造函数中可以调用虚函数，不过此时调用的是正在构造的类中的虚函数，而不是子类的虚函数，因为此时子类尚未构造好。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构造函数调用顺序，析构函数呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;调用所有虚基类的构造函数，顺序为从左到右，从最深到最浅&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基类的构造函数：如果有多个基类，先调用纵向上最上层基类构造函数，如果横向继承了多个类，调用顺序为派生表从左到右顺序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果该对象需要虚函数指针(vptr)，则该指针会被设置从而指向对应的虚函数表(vtbl)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;成员类对象的构造函数：如果类的变量中包含其他类（类的组合），需要在调用本类构造函数前先调用成员类对象的构造函数，调用顺序遵照在类中被声明的顺序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;派生类的构造函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;析构函数与之相反。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拷贝构造函数中深拷贝和浅拷贝区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;深拷贝时，当被拷贝对象存在动态分配的存储空间时，需要先动态申请一块存储空间，然后逐字节拷贝内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浅拷贝仅仅是拷贝指针字面值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当使用浅拷贝时，如果原来的对象调用析构函数释放掉指针所指向的数据，则会产生空悬指针。因为所指向的内存空间已经被释放了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拷贝构造函数和赋值运算符重载的区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;拷贝构造函数是函数，赋值运算符是运算符重载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拷贝构造函数会生成新的类对象，赋值运算符不能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现&amp;quot;=&amp;quot;的地方都是使用赋值运算符，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Student s;
  Student s1 = s;    // 调用拷贝构造函数
  Student s2;
  s2 = s;    // 赋值运算符操作
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚函数和纯虚函数区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;覆盖、重载和隐藏的区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;覆盖是派生类中重新定义的函数，其函数名、参数列表（个数、类型和顺序）、返回值类型和父类完全相同，只有函数体有区别。派生类虽然继承了基类的同名函数，但用派生类对象调用该函数时会根据对象类型调用相应的函数。覆盖只能发生在类的成员函数中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隐藏是指派生类函数屏蔽了与其同名的函数，这里仅要求基类和派生类函数同名即可。其他状态同覆盖。可以说隐藏比覆盖涵盖的范围更宽泛，毕竟参数不加限定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重载是具有相同函数名但参数列表不同（个数、类型或顺序）的两个函数（不关心返回值），当调用函数时根据传递的参数列表来确定具体调用哪个函数。重载可以是同一个类的成员函数也可以是类外函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在main执行之前执行的代码可能是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局对象的构造函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哪几种情况必须用到初始化成员列表？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;初始化一个const成员。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化一个reference成员。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用一个基类的构造函数，而该函数有一组参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用一个数据成员对象的构造函数，而该函数有一组参数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;什么是虚指针？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;虚指针或虚函数指针是虚函数的实现细节。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚指针指向虚表结构。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重载和函数模板的区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;重载需要多个函数，这些函数彼此之间函数名相同，但参数列表中参数数量和类型不同。在区分各个重载函数时我们并不关心函数体。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模板函数是一个通用函数，函数的类型和形参不直接指定而用虚拟类型来代表。但只适用于参个数相同而类型不同的函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;this指针是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;this指针是类的指针，指向对象的首地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;this指针只能在成员函数中使用，在全局函数、静态成员函数中都不能用this。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;this指针只有在成员函数中才有定义，且存储位置会因编译器不同有不同存储位置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类模板是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用于解决多个功能相同、数据类型不同的类需要重复定义的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在建立类时候使用template及任意类型标识符T，之后在建立类对象时，会指定实际的类型，这样才会是一个实际的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类模板是对一批仅数据成员类型不同的类的抽象，只要为这一批类创建一个类模板，即给出一套程序代码，就可以用来生成具体的类。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构造函数和析构函数调用时机？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;全局范围中的对象：构造函数在所有函数调用之前执行，在主函数执行完调用析构函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;局部自动对象：建立对象时调用构造函数，离开作用域时调用析构函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态分配的对象：建立对象时调用构造函数，调用释放时调用析构函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;静态局部变量对象：建立时调用一次构造函数，主函数结束时调用析构函数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;span-id-stl标准模板库span&#34;&gt;&lt;span id = &#34;stl&#34;&gt;标准模板库&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;STL内容虽然看起来很多，单独成书都不是问题（《STL源码剖析》），但从实际使用状况来看，我认为只需要知道以下几点就可以了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;怎么用？&lt;/p&gt;
&lt;p&gt;各种STL基本的增删改查怎么使用。每种容器都提供了很多操作，但实际增删改查我们通常只需要掌握透彻一种方式即可。有些功能只是出于通用性考虑才存在的，但对于相应的STL这些操作完全可以忽略。所以我对STL使用的看法是，不需要花太多时间去了解所有功能，只要掌握最基本的即可，要把精力放在对需求的了解并选择适合的数据结构。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;怎么实现？&lt;/p&gt;
&lt;p&gt;本身STL就是封装了我们常用的数据结构，所以最先需要了解每种数据结构的特性。而且了解实现方式对我们能够准确、高效使用STL打下了基础。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何避免错误？&lt;/p&gt;
&lt;p&gt;在第二阶段了解了STL的实现之后，我们已经可以很清楚地知道他们底层使用的是什么数据结构以及该数据结构做什么操作比较高效。但还有一点需要注意的就是怎么才能用对他们，避免一些未知的错误，比如迭代器失效问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;string&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;vector&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    定义：
        vector&amp;lt;T&amp;gt; vec;

    插入元素：
        vec.push_back(element);
        vec.insert(iterator, element);

    删除元素：
        vec.pop_back();
        vec.erase(iterator);

    修改元素：
        vec[position] = element;

    遍历容器：
        for(auto it = vec.begin(); it != vec.end(); ++it) {......}

    其他：
        vec.empty();    //判断是否空
        vec.size();    // 实际元素
        vec.capacity();    // 容器容量
        vec.begin();    // 获得首迭代器
        vec.end();    // 获得尾迭代器
        vec.clear();    // 清空
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/linw7/Skill-Tree/blob/master/code/my_vector.cpp&#34;&gt;模拟Vector实现&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;线性表，数组实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;支持随机访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;插入删除操作需要大量移动数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要连续的物理存储空间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每当大小不够时，重新分配内存（*2），并复制原内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;错误避免：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/linw7/Skill-Tree/blob/master/code/vector_iterator.cpp&#34;&gt;迭代器失效&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;插入元素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;尾后插入：size &amp;lt; capacity时，首迭代器不失效尾迭代实现（未重新分配空间），size == capacity时，所有迭代器均失效（需要重新分配空间）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中间插入：size &amp;lt; capacity时，首迭代器不失效但插入元素之后所有迭代器失效，size == capacity时，所有迭代器均失效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除元素&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;尾后删除：只有尾迭代失效。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中间删除：删除位置之后所有迭代失效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;map&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    定义：
        map&amp;lt;T_key, T_value&amp;gt; mymap;

    插入元素：
        mymap.insert(pair&amp;lt;T_key, T_value&amp;gt;(key, value));    // 同key不插入
        mymap.insert(map&amp;lt;T_key, T_value&amp;gt;::value_type(key, value));    // 同key不插入
        mymap[key] = value;    // 同key覆盖

    删除元素：
        mymap.erase(key);    // 按值删
        mymap.erase(iterator);    // 按迭代器删

    修改元素：
        mymap[key] = new_value;

    遍历容器：
          for(auto it = mymap.begin(); it != mymap.end(); ++it) {
            cout &amp;lt;&amp;lt; it-&amp;gt;first &amp;lt;&amp;lt; &amp;quot; =&amp;gt; &amp;quot; &amp;lt;&amp;lt; it-&amp;gt;second &amp;lt;&amp;lt; &#39;\n&#39;;
          }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现：&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/linw7/Skill-Tree/tree/master/code/RBTree&#34;&gt;RBTree实现&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;树状结构，RBTree实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;插入删除不需要数据复制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作复杂度仅跟树高有关。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RBTree本身也是二叉排序树的一种，key值有序，且唯一。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;必须保证key可排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于红黑树实现的map结构（实际上是map, set, multimap，multiset底层均是红黑树），不仅增删数据时不需要移动数据，其所有操作都可以在O(logn)时间范围内完成。另外，基于红黑树的map在通过迭代器遍历时，得到的是key按序排列后的结果，这点特性在很多操作中非常方便。&lt;/p&gt;
&lt;p&gt;面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;它是二叉排序树（继承二叉排序树特显）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;左、右子树也分别为二叉排序树。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它满足如下几点要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;树中所有节点非红即黑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根节点必为黑节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;红节点的子节点必为黑（黑节点子节点可为黑）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从根到NULL的任何路径上黑结点数相同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查找时间一定可以控制在O(logn)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;红黑树的节点定义如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;enum Color {
    RED = 0,
    BLACK = 1
};
struct RBTreeNode {
    struct RBTreeNode*left, *right, *parent;
    int key;
    int data;
    Color color;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以对红黑树的操作需要满足两点：1.满足二叉排序树的要求；2.满足红黑树自身要求。通常在找到节点通过和根节点比较找到插入位置之后，还需要结合红黑树自身限制条件对子树进行左旋和右旋。&lt;/p&gt;
&lt;p&gt;相比于AVL树，红黑树平衡性要稍微差一些，不过创建红黑树时所需的旋转操作也会少很多。相比于最简单的BST，BST最差情况下查找的时间复杂度会上升至O(n)，而红黑树最坏情况下查找效率依旧是O(logn)。所以说红黑树之所以能够在STL及Linux内核中被广泛应用就是因为其折中了两种方案，既减少了树高，又减少了建树时旋转的次数。&lt;/p&gt;
&lt;p&gt;从红黑树的定义来看，红黑树从根到NULL的每条路径拥有相同的黑节点数（假设为n），所以最短的路径长度为n（全为黑节点情况）。因为红节点不能连续出现，所以路径最长的情况就是插入最多的红色节点，在黑节点数一致的情况下，最可观的情况就是黑红黑红排列......最长路径不会大于2n，这里路径长就是树高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;set&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;span-id-other编译及调试span&#34;&gt;&lt;span id = &#34;other&#34;&gt;编译及调试&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;编译&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;预处理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;展开所有的宏定义，完成字符常量替换。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理条件编译语句，通过是否具有某个宏来决定过滤掉哪些代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;处理#include指令，将被包含的文件插入到该指令所在位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;过滤掉所有注释语句。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;添加行号和文件名标识。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保留所有#pragma编译器指令。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;编译&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;词法分析。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;语法分析。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;语义分析。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中间语言生成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目标代码生成与优化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;链接&lt;/p&gt;
&lt;p&gt;各个源代码模块独立的被编译，然后将他们组装起来成为一个整体，组装的过程就是链接。被链接的各个部分本本身就是二进制文件，所以在被链接时需要将所有目标文件的代码段拼接在一起，然后将所有对符号地址的引用加以修正。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;静态链接&lt;/p&gt;
&lt;p&gt;静态链接最简单的情况就是在编译时和静态库链接在一起成为完整的可执行程序。这里所说的静态库就是对多个目标文件（.o）文件的打包，通常静态链接的包名为lib****.a，静态链接所有被用到的目标文件都会复制到最终生成的可执行目标文件中。这种方式的好处是在运行时，可执行目标文件已经完全装载完毕，只要按指令序执行即可，速度比较快，但缺点也有很多，在讲动态链接时会比较一下。&lt;/p&gt;
&lt;p&gt;既然静态链接是对目标文件的打包，这里介绍些打包命令。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  gcc -c test1.c    // 生成test1.o
  gcc -c test2.c    // 生成test2.c
  ar cr libtest.a test1.o test2.o
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先编译得到test1.o和test2.o两个目标文件，之后通过ar命令将这两个文件打包为.a文件，文件名格式为lib + 静态库名 + .a后缀。在生成可执行文件需要使用到它的时候只需要在编译时加上即可。需要注意的是，使用静态库时加在最后的名字不是libtest.a，而是l + 静态库名。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  gcc -o main main.c -ltest
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态链接&lt;/p&gt;
&lt;p&gt;静态链接发生于编译阶段，加载至内存前已经完整，但缺点是如果多个程序都需要使用某个静态库，则该静态库会在每个程序中都拷贝一份，非常浪费内存资源，所以出现了动态链接的方式来解决这个问题。&lt;/p&gt;
&lt;p&gt;动态链接在形式上倒是和静态链接非常相似，首先也是需要打包，打包成动态库，不过文件名格式为lib + 动态库名 + .so后缀。不过动态库的打包不需要使用ar命令，gcc就可以完成，但要注意在编译时要加上-fPIC选项，打包时加上-shared选项。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  gcc -fPIC -c test1.c 
  gcc -fPIC -c test2.c
  gcc -shared test1.o test2.o -o libtest.so
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用动态链接的用法也和静态链接相同。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  gcc -o main main.c -ltest
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果仅仅像上面的步骤是没有办法正常使用库的，我们可以通过加-Lpath指定搜索库文件的目录（-L.表示当前目录），默认情况下会到环境变量LD_LIBRARY_PATH指定的目录下搜索库文件，默认情况是/usr/lib，我们可以将库文件拷贝到那个目录下再链接。&lt;/p&gt;
&lt;p&gt;比较静态库和动态库我们可以得到二者的优缺点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;动态库运行时会先检查内存中是否已经有该库的拷贝，若有则共享拷贝，否则重新加载动态库（C语言的标准库就是动态库）。静态库则是每次在编译阶段都将静态库文件打包进去，当某个库被多次引用到时，内存中会有多份副本，浪费资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态库另一个有点就是更新很容易，当库发生变化时，如果接口没变只需要用新的动态库替换掉就可以了。但是如果是静态库的话就需要重新被编译。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不过静态库也有优点，主要就是静态库一次性完成了所有内容的绑定，运行时就不必再去考虑链接的问题了，执行效率会稍微高一些。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;makefile编写&lt;/p&gt;
&lt;p&gt;对于大的工程通常涉及很多头文件和源文件，编译起来很很麻烦，makefile正是为了自动化编译产生的，makefile像是编译说明书，指示编译的步骤和条件，之后被make命令解释。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基本规则&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  A:B
  (tab)&amp;lt;command&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中A是语句最后生成的文件，B是生成A所依赖的文件，比如生成test.o依赖于test.c和test.h，则写成test.o:test.c test.h。接下来一行的开头必须是tab，再往下就是实际的命令了，比如gcc -c test.c -o test.o。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;变量&lt;/p&gt;
&lt;p&gt;makefile的书写非常像shell脚本，可以在文件中定义&amp;quot;变量名 = 变量值&amp;quot;的形式，之后需要使用这个变量时只需要写一个$符号加上变量名即可，当然，和shell一样，最好用()包裹起语句来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;链接&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;符号解析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可重定位目标文件&lt;/p&gt;
&lt;p&gt;对于独立编译的可重定位目标文件，其ELF文件格式包括ELF头（指定文件大小及字节序）、.text（代码段）、.rodata（只读数据区）、.data（已初始化数据区）、.bss（未初始化全局变量）、.symtab（符号表）等，其中链接时最需要关注的就是符号表。每个可重定位目标文件都有一张符号表，它包含该模块定义和引用的符号的信息，简而言之就是我们在每个模块中定义和引用的全局变量（包括定义在本模块的全局变量、静态全局变量和引用自定义在其他模块的全局变量）需要通过一张表来记录，在链接时通过查表将各个独立的目标文件合并成一个完整的可执行文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解析符号表&lt;/p&gt;
&lt;p&gt;解析符号引用的目的是将每个引用与可重定位目标文件的符号表中的一个符号定义联系起来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重定位&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;合并节&lt;/p&gt;
&lt;p&gt;多个可重定位目标文件中相同的节合并成一个完整的聚合节，比如多个目标文件的.data节合并成可执行文件的.data节。链接器将运行时存储地址赋予每个节，完成这步每条指令和全局变量都有运行时地址了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重定位符号引用&lt;/p&gt;
&lt;p&gt;这步修改全部代码节和数据节对每个符号的符号引用，使其指向正确的运行时地址。局部变量可以通过进栈、出栈临时分配，但全局变量（&amp;quot;符号&amp;quot;）的位置则是在各个可重定位目标文件中预留好的。通过上一步合并节操作后，指令中所有涉及符号的引用都会通过一定的寻址方式来定位该符号，比如相对寻址、绝对寻址等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可执行目标文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;ELF头部&lt;/p&gt;
&lt;p&gt;描述文件总体格式，并且包括程序的入口点（entry point），也就是程序运行时执行的第一条指令地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;段头部表&lt;/p&gt;
&lt;p&gt;描述了可执行文件数据段、代码段等各段的大小、虚拟地址、段对齐、执行权限等。实际上通过段头部表描绘了虚拟存储器运行时存储映像，比如每个UNIX程序的代码段总是从虚拟地址Ox0804800开始的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他段&lt;/p&gt;
&lt;p&gt;和可重定位目标文件各段基本相同，但完成了多个节的合并和重定位工作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;加载&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;克隆&lt;/p&gt;
&lt;p&gt;新程序的执行首先需要通过父进程外壳通过fork得到一个子进程，该子进程除了pid等标识和父进程不同外其他基本均与父进程相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重新映射&lt;/p&gt;
&lt;p&gt;当子进程执行execve系统调用时会先清空子进程现有的虚拟存储器段（简而言之就是不再映射到父进程的各个段），之后重新创建子进程虚拟存储器各段和可执行目标文件各段的映射。这个阶段我们可以理解为对复制来的父进程页表进程重写，映射到外存中可执行文件的各个段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚页调入&lt;/p&gt;
&lt;p&gt;加载过程并没有实际将磁盘中可执行文件调入内存，所做的工作紧紧是复制父进程页表、清空旧页表、建立新页表映射工作。之后加载器跳转到入口地址_start开始执行程序，接下来的过程需要配合虚拟存储器来完成。CPU获得指令的虚拟地址后，若包含该指令或数据的页尚未调入内存则将其从外存中调入，调入内存后修改页表得到虚拟页号和物理页号的对应关系。之后重新取同一条指令或数据时因该页已经被调入内存，所以通过虚拟地址得到虚拟页号，虚拟页号通过查页表可以得到物理页号，通过物理页号 + 页内偏移得到具体的物理地址，此时可以通过物理地址取得想要的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
">编程语言C/C++（摘自linw7）</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/pytorch-nnmodule/"" data-c="
          &lt;h2 id=&#34;1-embed-current-layers&#34;&gt;1 embed current layers&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Linear(用于全连接层)&lt;/li&gt;
&lt;li&gt;ReLU,sigmoid等&lt;/li&gt;
&lt;li&gt;Conv2d&lt;/li&gt;
&lt;li&gt;ConvTransposed2d&lt;/li&gt;
&lt;li&gt;Dropout&lt;/li&gt;
&lt;li&gt;etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-container&#34;&gt;2 Container&lt;/h2&gt;
&lt;p&gt;net(x)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;self.net=nn.Sequential(
    nn.Conv2d(1,32,5,1,1),
    nn.MaxPool2d(2,2),
    nn.ReLU(True),
    nn.BatchNorm2d(32),
    
    .
    .
    .
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-parameters&#34;&gt;3 Parameters&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;a href=&#34;https://imgtu.com/i/HfPpUx&#34;&gt;&lt;img src=&#34;https://s4.ax1x.com/2022/02/16/HfPpUx.png&#34; alt=&#34;HfPpUx.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h2 id=&#34;4-modules&#34;&gt;4 modules&lt;/h2&gt;
&lt;p&gt;modules：所有的结点&lt;br&gt;
children：直接的孩子结点&lt;br&gt;
&lt;a href=&#34;https://imgtu.com/i/HfPEKH&#34;&gt;&lt;img src=&#34;https://s4.ax1x.com/2022/02/16/HfPEKH.png&#34; alt=&#34;HfPEKH.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-todevice&#34;&gt;5 to(device)&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;device=torch.device(&#39;cuda&#39;)
net=Net()
net.to(device) #实际上没有改变，但是别的tensor.to(device)是改变了的，不是一个东西
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;6-save-and-load&#34;&gt;6 save and load&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;a href=&#34;https://imgtu.com/i/HfiEWT&#34;&gt;&lt;img src=&#34;https://s4.ax1x.com/2022/02/16/HfiEWT.png&#34; alt=&#34;HfiEWT.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h2 id=&#34;7-traintest状态切换&#34;&gt;7 train，test状态切换&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;a href=&#34;https://imgtu.com/i/HfiwTI&#34;&gt;&lt;img src=&#34;https://s4.ax1x.com/2022/02/16/HfiwTI.png&#34; alt=&#34;HfiwTI.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h2 id=&#34;8-implement-own-layer&#34;&gt;8 implement own layer&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://imgtu.com/i/HfiLnJ&#34;&gt;&lt;img src=&#34;https://s4.ax1x.com/2022/02/16/HfiLnJ.png&#34; alt=&#34;HfiLnJ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://imgtu.com/i/Hfixtx&#34;&gt;&lt;img src=&#34;https://s4.ax1x.com/2022/02/16/Hfixtx.png&#34; alt=&#34;Hfixtx.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
">Pytorch——nn.Module</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/pytorch-juan-ji-shen-jing-wang-luo/"" data-c="
          &lt;h2 id=&#34;操作&#34;&gt;操作&lt;/h2&gt;
&lt;h3 id=&#34;nnconv2d&#34;&gt;nn.Conv2d&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;layer=nn.Conv2d(1,3,kernel_size=3,stride=1,padding=1)#输入是(b,1,28,28),kernel有3个
out=layer.forward(x)# 不推荐使用，
out=layer(x) #用这个可以调用一些hooks函数
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;fconv2d&#34;&gt;F.conv2d&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;w=torch.rand(16,3,5,5)
b=torch.rand(16)
x=torch.randn(1,3,28,28)

out=F.conv2d(x,w,b,stride=1,padding=1)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;池化层&#34;&gt;池化层&lt;/h2&gt;
&lt;h3 id=&#34;max-pooling&#34;&gt;Max pooling&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://imgtu.com/i/HRXEy6&#34;&gt;&lt;img src=&#34;https://s4.ax1x.com/2022/02/15/HRXEy6.png&#34; alt=&#34;HRXEy6.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
average pooling:不取最大值，取几个数的平均值&lt;/p&gt;
&lt;h3 id=&#34;操作-2&#34;&gt;操作&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-pyhton&#34;&gt;layer=nn.MaxPool2d(2,stride=2)#第一个2是window的大小
out=layer(x)

out=F.avg_pool2d(x,2,stride=2)
&lt;/code&gt;&lt;/pre&gt;
">Pytorch——卷积神经网络</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/pytorch-early-stopdropout/"" data-c="
          &lt;p&gt;dropout在test时要将状态切换过来&lt;br&gt;
net_dropped.eval()&lt;/p&gt;
">Pytorch——Early stop,Dropout</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/pytorch-jiao-cha-shang/"" data-c="
          &lt;h2 id=&#34;&#34;&gt;&lt;/h2&gt;
">Pytorch——交叉熵</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/pytorch-gan-zhi-ji-ti-du-tui-dao/"" data-c="
          &lt;h2 id=&#34;单层感知机&#34;&gt;单层感知机&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x=torch.randn(1,10)
w=torch.randn(1,10,requires_grad=True)

o=torch.sigmoid(x@w.t())
o.shape

loss=F.mse_loss(torch.ones(1,1),o)
loss.shape

loss.backward()

w.grad
51
tensor([[-0.0007, -0.0001, -0.0038,  0.0019,  0.0002, -0.0032,  0.0047, -0.0029,
         -0.0018,  0.0030]])

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;mlp及梯度&#34;&gt;MLP及梯度&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x=torch.randn(1,10)
w=torch.randn(2,10,requires_grad=True)

o=torch.sigmoid(x@w.t())
o.shape

loss=F.mse_loss(torch.ones(1,1),o)
loss.shape

loss.backward()

w.grad
D:\Software\anaconda3\envs\pytorch\lib\site-packages\ipykernel_launcher.py:7: UserWarning: Using a target size (torch.Size([1, 2])) that is different to the input size (torch.Size([1, 1])). This will likely lead to incorrect results due to broadcasting. Please ensure they have the same size.
  import sys
52
tensor([[-2.2506e-04,  5.8902e-05,  2.8970e-04, -1.0290e-04, -2.3394e-04,
          6.1625e-05,  7.8519e-05,  2.3708e-04,  1.4745e-05,  1.7960e-05],
        [-3.2697e-02,  8.5576e-03,  4.2089e-02, -1.4950e-02, -3.3987e-02,
          8.9532e-03,  1.1408e-02,  3.4444e-02,  2.1422e-03,  2.6092e-03]])

&lt;/code&gt;&lt;/pre&gt;
">Pytorch——感知机梯度推导</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/pytorch-ti-du/"" data-c="
          &lt;h2 id=&#34;梯度&#34;&gt;梯度&lt;/h2&gt;
&lt;p&gt;上次说的resnet为啥要两个精度，是让损失平面变的光滑，课p35讲了&lt;/p&gt;
&lt;h2 id=&#34;常见函数的梯度&#34;&gt;常见函数的梯度&lt;/h2&gt;
&lt;h2 id=&#34;激活函数&#34;&gt;激活函数&lt;/h2&gt;
&lt;h3 id=&#34;mean-squared-error均方差&#34;&gt;Mean Squared Error均方差&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;使用grad()&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x=torch.ones(1)
w=torch.full([1],2).float()
w.requires_grad_()
mse=F.mse_loss(torch.ones(1),x*w)
 # 更新需要计算梯度，或者初始化时设置requires_grad=True
torch.autograd.grad(mse,[w])
43
(tensor([2.]),)

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;使用backward()&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;x=torch.ones(1)
w=torch.full([1],2).float()
w.requires_grad_()
mse=F.mse_loss(torch.ones(1),x*w)
 # 更新需要计算梯度，或者初始化时设置requires_grad=True
# torch.autograd.grad(mse,[w])
mse.backward()
w.grad
44
tensor([2.])
使用backward后，grad会存储在w里
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;cross-entropy-loss&#34;&gt;Cross Entropy Loss&lt;/h3&gt;
&lt;h4 id=&#34;softmaxsoft-version-of-max&#34;&gt;softmax(soft version of max)&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;a href=&#34;https://imgtu.com/i/Ha4pBn&#34;&gt;&lt;img src=&#34;https://s4.ax1x.com/2022/02/11/Ha4pBn.png&#34; alt=&#34;Ha4pBn.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a=torch.rand(3)
a.requires_grad_()
p=F.softmax(a,dim=0)
print(p)
# p.backward()
torch.autograd.grad(p[1],[a],retain_graph=True)
tensor([0.2106, 0.5013, 0.2881], grad_fn=&amp;lt;SoftmaxBackward0&amp;gt;)
47
(tensor([-0.1056,  0.2500, -0.1444]),)
&lt;/code&gt;&lt;/pre&gt;
">Pytorch——梯度，激活函数与Loss的梯度</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/pytorch-shu-xing-tong-ji-gao-ji-cao-zuo/"" data-c="
          &lt;h2 id=&#34;norm范数&#34;&gt;norm范数&lt;/h2&gt;
&lt;p&gt;与normalize(batch_norm）不同&lt;br&gt;
Vector Norm与Matrix Norm计算的不同&lt;br&gt;
&lt;a href=&#34;https://imgtu.com/i/HUeO9P&#34;&gt;&lt;img src=&#34;https://s4.ax1x.com/2022/02/11/HUeO9P.jpg&#34; alt=&#34;HUeO9P.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;计算没太看懂，后面算的时候再看&lt;/p&gt;
&lt;h2 id=&#34;minmaxprodmean等&#34;&gt;min,max,prod,mean等&lt;/h2&gt;
&lt;p&gt;prod()是累乘&lt;br&gt;
mean()是均值&lt;br&gt;
min最小值&lt;/p&gt;
&lt;h3 id=&#34;argminargmax索引&#34;&gt;argmin，argmax索引&lt;/h3&gt;
&lt;p&gt;没有指定纬度，就打平求&lt;br&gt;
argmin(dim=):在dim纬度上求最小值，得到index&lt;/p&gt;
&lt;h3 id=&#34;dimkeepdim&#34;&gt;dim，keepdim&lt;/h3&gt;
&lt;p&gt;max(dim=):返回最大值和索引&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a=torch.randn(4,10)
print(a)
a.argmax(dim=1)
b,c=a.max(dim=1)
print(b,c)
tensor([[-1.0555e+00, -4.7406e-01, -1.7884e+00,  4.7256e-01,  1.2359e-01,
         -1.1320e-02,  8.9937e-01, -3.7503e-01,  4.4091e-01, -1.0220e+00],
        [-4.5359e-01,  2.1482e-01, -1.1953e+00,  9.0963e-03, -7.7804e-01,
          8.5170e-01, -9.5218e-01,  7.8373e-01, -5.0498e-01,  2.7409e-01],
        [ 1.0214e+00,  1.0886e+00, -1.1839e+00,  2.0071e+00,  7.4919e-01,
          3.9205e-01, -5.6472e-01, -1.3950e+00, -1.6764e+00,  2.4113e+00],
        [ 8.6189e-01,  1.6097e-03, -2.1737e-01,  9.0528e-01, -1.4958e+00,
         -1.1681e-01,  7.7766e-01,  1.0796e+00,  4.0260e-02, -1.3723e+00]])
tensor([0.8994, 0.8517, 2.4113, 1.0796]) tensor([6, 5, 9, 7])

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;max(dim=,keepdim=true):就会保留纬度，本来是[4],true之后是[4,1]&lt;/p&gt;
&lt;h2 id=&#34;topkkthvalue&#34;&gt;topk，kthvalue&lt;/h2&gt;
&lt;p&gt;topk(k,dim):返回dim上前k大的数和索引&lt;br&gt;
topk(k,dim,largest=False):前k小&lt;/p&gt;
&lt;p&gt;kthvalue(k,dim):dim纬度上第k大的值和索引&lt;/p&gt;
&lt;h2 id=&#34;比较&#34;&gt;比较&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;符号&lt;/li&gt;
&lt;li&gt;torch.eq(a,b):对应位置比较，返回tensor&lt;/li&gt;
&lt;li&gt;torch.equal(a,b):返回true，false，全比较&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;where&#34;&gt;where&lt;/h2&gt;
&lt;p&gt;where(condition,a,b)&lt;br&gt;
if condition, ai&lt;br&gt;
else              bi&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;ond=torch.rand(2,2)
print(cond)
a=torch.full([2,2],0)
b=torch.full([2,2],1)
a,b
torch.where(cond&amp;gt;0.5,a,b)
tensor([[0.4939, 0.6974],
        [0.8966, 0.9464]])
20
tensor([[1, 0],
        [0, 0]])
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;gather&#34;&gt;gather&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;a href=&#34;https://imgtu.com/i/HU2Rcn&#34;&gt;&lt;img src=&#34;https://s4.ax1x.com/2022/02/11/HU2Rcn.png&#34; alt=&#34;HU2Rcn.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
">Pytorch——属性统计，高级操作</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/pytorch-shu-xing-tong-ji/"" data-c="
          &lt;h2 id=&#34;norm范数&#34;&gt;norm范数&lt;/h2&gt;
&lt;p&gt;与normalize(batch_norm）不同&lt;br&gt;
Vector Norm与Matrix Norm计算的不同&lt;br&gt;
&lt;a href=&#34;https://imgtu.com/i/HUeO9P&#34;&gt;&lt;img src=&#34;https://s4.ax1x.com/2022/02/11/HUeO9P.jpg&#34; alt=&#34;HUeO9P.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;计算没太看懂，后面算的时候再看&lt;/p&gt;
&lt;h2 id=&#34;minmaxprodmean等&#34;&gt;min,max,prod,mean等&lt;/h2&gt;
&lt;p&gt;prod()是累乘&lt;br&gt;
mean()是均值&lt;br&gt;
min最小值&lt;/p&gt;
&lt;h3 id=&#34;argminargmax索引&#34;&gt;argmin，argmax索引&lt;/h3&gt;
&lt;p&gt;没有指定纬度，就打平求&lt;br&gt;
argmin(dim=):在dim纬度上求最小值，得到index&lt;/p&gt;
&lt;h3 id=&#34;dimkeepdim&#34;&gt;dim，keepdim&lt;/h3&gt;
&lt;p&gt;max(dim=):返回最大值和索引&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a=torch.randn(4,10)
print(a)
a.argmax(dim=1)
b,c=a.max(dim=1)
print(b,c)
tensor([[-1.0555e+00, -4.7406e-01, -1.7884e+00,  4.7256e-01,  1.2359e-01,
         -1.1320e-02,  8.9937e-01, -3.7503e-01,  4.4091e-01, -1.0220e+00],
        [-4.5359e-01,  2.1482e-01, -1.1953e+00,  9.0963e-03, -7.7804e-01,
          8.5170e-01, -9.5218e-01,  7.8373e-01, -5.0498e-01,  2.7409e-01],
        [ 1.0214e+00,  1.0886e+00, -1.1839e+00,  2.0071e+00,  7.4919e-01,
          3.9205e-01, -5.6472e-01, -1.3950e+00, -1.6764e+00,  2.4113e+00],
        [ 8.6189e-01,  1.6097e-03, -2.1737e-01,  9.0528e-01, -1.4958e+00,
         -1.1681e-01,  7.7766e-01,  1.0796e+00,  4.0260e-02, -1.3723e+00]])
tensor([0.8994, 0.8517, 2.4113, 1.0796]) tensor([6, 5, 9, 7])

&lt;/code&gt;&lt;/pre&gt;
">Pytorch——属性统计</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/pytorch-shu-xue-yun-suan/"" data-c="
          &lt;h2 id=&#34;加减乘除&#34;&gt;加减乘除&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;/以外：&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;torch.add(a,b)
sub
mul
div
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;matmul&#34;&gt;matmul&lt;/h2&gt;
&lt;p&gt;*号只是矩阵对应位置元素相乘&lt;br&gt;
matmul是matrix mull&lt;br&gt;
三种方法实现&lt;/p&gt;
&lt;h3 id=&#34;torchmm&#34;&gt;Torch.mm&lt;/h3&gt;
&lt;p&gt;only for 2d&lt;/p&gt;
&lt;h3 id=&#34;torchmatmul&#34;&gt;Torch.matmul&lt;/h3&gt;
&lt;p&gt;torch.matmul(a,b)&lt;br&gt;
还是只有最后两维进行运算，前面的使用broadcasting进行扩展，但是size大小得一样&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a=torch.rand(4,3,28,64)
b=torch.rand(4,1,64,32)
torch.matmul(a,b).shape

c=torch.rand(4,64,32)
torch.matmul(a,c).shape
---------------------------------------------------------------------------

RuntimeError                              Traceback (most recent call last)

~\AppData\Local\Temp/ipykernel_27688/2168653215.py in &amp;lt;module&amp;gt;
      4 
      5 c=torch.rand(4,64,32)
----&amp;gt; 6 torch.matmul(a,c).shape

RuntimeError: The size of tensor a (3) must match the size of tensor
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;&#34;&gt;@&lt;/h3&gt;
&lt;p&gt;a@b&lt;/p&gt;
&lt;h2 id=&#34;次方运算&#34;&gt;次方运算&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a=torch.full([2,2],3)
a.pow(n)
a**(n) # n次方

sqrt() # 平方根
rsqrt() # 平方根的倒数

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;exp-log&#34;&gt;exp log&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a=torch.exp(torch.ones(2,2))
print(a)

torch.log(a)  
tensor([[2.7183, 2.7183],
        [2.7183, 2.7183]])

tensor([[1., 1.],
        [1., 1.]])

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;log2():以2为底&lt;br&gt;
log10()&lt;/p&gt;
&lt;h2 id=&#34;近似值&#34;&gt;近似值&lt;/h2&gt;
&lt;p&gt;floor():下取整&lt;br&gt;
ceil():上取整&lt;br&gt;
trunc():取整数&lt;br&gt;
frac()：取小数&lt;/p&gt;
&lt;p&gt;round():四舍五入&lt;/p&gt;
&lt;h3 id=&#34;clamp&#34;&gt;clamp&lt;/h3&gt;
&lt;p&gt;clamp(n):小于n的都取n&lt;br&gt;
clamp(n,m):取n~m之间的，小于n取n，大于m取m&lt;/p&gt;
">Pytorch——数学运算</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/pytorch-he-bing-yu-fen-ge/"" data-c="
          &lt;h2 id=&#34;cat&#34;&gt;cat&lt;/h2&gt;
&lt;p&gt;torch.cat([a,b],dim=)&lt;br&gt;
dim以外的纬度相同&lt;/p&gt;
&lt;h2 id=&#34;stack&#34;&gt;stack&lt;/h2&gt;
&lt;p&gt;torch.stack([a,b],dim=)&lt;br&gt;
a,b纬度必须完全一样，在dim前添加纬度合并&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;a=torch.rand(32,8)
b=torch.rand(32,8)
torch.stack([a,b].dim=0).shape
#形状是[2,32,8]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;split&#34;&gt;split&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;参数1
a1,a2,a3...an=a.split([m1,m2,m3...mn],dim=)    m1+m2+m3+...+mn=dim的size
参数2
a1,a2,a3...an=a.split(n,dim=)    n为均分的步长
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;chunk&#34;&gt;chunk&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;c.chunk(num,dim=) # 按要拆分出的tensor的数量拆分
&lt;/code&gt;&lt;/pre&gt;
">Pytorch——合并与分割</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/pytorch-wei-du-bian-hua/"" data-c="
          &lt;ol&gt;
&lt;li&gt;view和reshape，一样的&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;squeeze和unsqueeze&#34;&gt;squeeze和unsqueeze&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;unsqueeze(dim): dim范围[-a.dim()-1,a.dim()+1]&lt;br&gt;
dim=4,则范围是[-5,5)&lt;br&gt;
dim为负数则在索引后插入，为正数则在索引前插入&lt;/li&gt;
&lt;li&gt;squeeze()不给参数时，默认将所有size=1的纬度删除，给的dim的size不等于1时不会变&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;expand与repeat&#34;&gt;expand与repeat&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;区别&lt;br&gt;
expand需要的时候才扩展，repeat实实在在的复制数据&lt;/li&gt;
&lt;li&gt;expand使用&lt;br&gt;
1-&amp;gt;N可以&lt;br&gt;
3-&amp;gt;M不可以扩展&lt;br&gt;
如[1,32,1,1]-&amp;gt;[4,32,14,14]可以&lt;br&gt;
[2,32,1,1]-&amp;gt;[4,32,14,14]报错&lt;br&gt;
参数为-1时表示这个纬度不变&lt;br&gt;
参数的意义是希望得到的纬度&lt;/li&gt;
&lt;li&gt;repeat的使用&lt;br&gt;
参数的意义是该纬度需要拷贝的次数&lt;br&gt;
不建议使用&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;转置操作&#34;&gt;转置操作&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;.t()只适用于2D的&lt;/li&gt;
&lt;li&gt;transpose(dim1,dim2)&lt;br&gt;
交换dim1和dim2，此时存储顺序已经变了&lt;br&gt;
cantiguous()使数据变得连续&lt;/li&gt;
&lt;li&gt;[b,h,w,c]是numpy的图片存储格式&lt;/li&gt;
&lt;li&gt;permute()使用&lt;br&gt;
参数是希望得到的纬度顺序&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;broadcasting&#34;&gt;broadcasting&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;[ 高-&amp;gt;低]&lt;br&gt;
低维的纬度相同的，再往高维匹配&lt;br&gt;
[4    32     8]+一维的或标量可以，+[4]就不可以&lt;/p&gt;
&lt;/blockquote&gt;
">Pytorch——维度变化</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/pytorch-suo-yin-yu-qie-pian/"" data-c="
          &lt;ol&gt;
&lt;li&gt;索引号的&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;[0 1 2]
正数索引
0 1 2
负数索引
-3 -2 -1
a[-1:]指-1元素往后
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;隔行采样&lt;br&gt;
a[: , : , 0:28:2 , 0:28:2 ]  :   2的意思是0~28隔一个采样,0和28可以省去&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;index_select(dim, index)&lt;br&gt;
第二个参数得是tensor类型，不能是list类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ge( x):大于等于x的数置为1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;masked_select(x,mask)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;x=torch.randn(3,4)
mask=x.ge(0.5) #将大于0.5的置1，其他置0
torch.masked_select(x,mask)  #就可以得到x中大于0.5的元素
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;take(src,index):先把src打平，再按index取数&lt;/li&gt;
&lt;/ol&gt;
">Pytorch——索引与切片</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/leetcode-shua-ti-bi-ji-shuang-zhan/"" data-c="
          &lt;h2 id=&#34;双栈实现队列操作&#34;&gt;双栈实现队列操作&lt;/h2&gt;
&lt;h3 id=&#34;剑指offer09&#34;&gt;剑指offer09&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完
成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )
示例 1：
输入：
[&amp;quot;CQueue&amp;quot;,&amp;quot;appendTail&amp;quot;,&amp;quot;deleteHead&amp;quot;,&amp;quot;deleteHead&amp;quot;]
[[],[3],[],[]]
输出：[null,null,3,-1]
示例 2：
输入：
[&amp;quot;CQueue&amp;quot;,&amp;quot;deleteHead&amp;quot;,&amp;quot;appendTail&amp;quot;,&amp;quot;appendTail&amp;quot;,&amp;quot;deleteHead&amp;quot;,&amp;quot;deleteHead&amp;quot;]
[[],[],[5],[2],[],[]]
输出：[null,-1,null,null,5,2]
提示：
1 &amp;lt;= values &amp;lt;= 10000
最多会对 appendTail、deleteHead 进行 10000 次调用
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;思路&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;一个in_stack，一个out_stack模拟队列，进入队列时，直接压入in_stack，出队列时，如果out_stack非空，则直接out_stack直接pop，如果空，则将in_stack所有元素压入out_stack，再pop&lt;/p&gt;
&lt;h3 id=&#34;代码实现&#34;&gt;代码实现&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;class CQueue {
public:
    stack&amp;lt;int&amp;gt; stack_in;
    stack&amp;lt;int&amp;gt; stack_out;
    CQueue() {

    }
    void appendTail(int value) {
        stack_in.push(value);

    }
    
    int deleteHead() {
        int x=-1;
        if(stack_out.empty())//出栈空，则入栈转入出栈再出
        {
            if(stack_in.empty())//均空则返回-1
            {
                return x;
            }
            while(!stack_in.empty())//入栈非空，则转入出栈
            {
                x=stack_in.top();
                stack_in.pop();
                stack_out.push(x);
            }
        }
        x=stack_out.top();
        stack_out.pop();
        return x;
    }
};

/**
 * Your CQueue object will be instantiated and called as such:
 * CQueue* obj = new CQueue();
 * obj-&amp;gt;appendTail(value);
 * int param_2 = obj-&amp;gt;deleteHead();
 */
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;实现包含查询最小值min的栈&#34;&gt;实现包含查询最小值min的栈&lt;/h2&gt;
&lt;h3 id=&#34;剑指offer-30&#34;&gt;剑指offer 30&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。

示例:
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.min();   --&amp;gt; 返回 -3.
minStack.pop();
minStack.top();      --&amp;gt; 返回 0.
minStack.min();   --&amp;gt; 返回 -2.

提示：
各函数的调用总次数不超过 20000 次

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;思路-2&#34;&gt;思路&lt;/h3&gt;
&lt;p&gt;两个栈，一个正常存储comstack，一个用于存放最小值minstack，每次有入栈元素时，正常压入comstack，再与minstack栈顶元素对比，如果小于等于其，则压入minstack，因此保证了minstack是非严格递减的；出栈时，comstack正常pop，minstack如果栈顶元素和comstack一样，则也pop；min操作则直接minstack的top即可&lt;/p&gt;
&lt;h3 id=&#34;代码实现-2&#34;&gt;代码实现&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;/*暴力土方法
class MinStack {
public:
    // initialize your data structure here. 
    MinStack() {

    }
    vector&amp;lt;int&amp;gt; minstack;
    int min_num;
    int min_i=-1;
    void push(int x) {
        if(min_i==-1)//第一个压栈元素设为最小
        {
            min_num=x;
            min_i=0;
        }
        else
        {
            if(x&amp;lt;min_num)
            {
                min_num=x;
                min_i=minstack.size();//this line can delete
            }
        }
        minstack.push_back(x);
    }
    
    void pop() {
        minstack.pop_back();

    }
    
    int top() {
        return minstack.back();

    }
    
    int min() {
        vector&amp;lt;int&amp;gt;::iterator it=minstack.begin();
        for(min_num=minstack.front();it!=minstack.end();it++)
        {
            if(*it&amp;lt;min_num)
            {
                min_num=*it;
                min_i=it-minstack.begin();
            }
        }
        return min_num;

    }
};
*/
class MinStack{
public:
    stack&amp;lt;int&amp;gt; comstack;//用于正常存储
    stack&amp;lt;int&amp;gt; minstack;//用于存放最小值，非严格递减
    MinStack(){

    }
    void push(int x){
        comstack.push(x);
        if(minstack.empty()||x&amp;lt;=minstack.top())//minstack空或者x比栈顶元素小，则压入minstack
        {
            minstack.push(x);
        }

    }

    void pop() {
        if(comstack.top()==minstack.top())
        {
            comstack.pop();
            minstack.pop();
        }
        else
        {
            comstack.pop();
        }

    }

    int top() {
        return comstack.top();
    }

    int min() {
        return minstack.top();
    }

};
/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj-&amp;gt;push(x);
 * obj-&amp;gt;pop();
 * int param_3 = obj-&amp;gt;top();
 * int param_4 = obj-&amp;gt;min();
 */
&lt;/code&gt;&lt;/pre&gt;
">LeetCode刷题笔记——双栈</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/leetcode-shua-ti-bi-ji-hua-dong-chuang-kou/"" data-c="
          &lt;h2 id=&#34;t3无重复字符的最长子串&#34;&gt;T3无重复字符的最长子串&lt;/h2&gt;
&lt;h3 id=&#34;错误思路&#34;&gt;错误思路&lt;/h3&gt;
&lt;p&gt;自己写的垃圾，最后一个贼长的用例通过不了，给该用例特殊判断了一下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;class Solution {
public:
    int copyvector(vector&amp;lt;char&amp;gt; &amp;amp;a,vector&amp;lt;char&amp;gt; &amp;amp;b)//把a向量复制到b内
    {
        vector&amp;lt;char&amp;gt;::iterator it_a;
        for(it_a=a.begin();it_a!=a.end();it_a++)
        {
            b.push_back(*it_a);
        }
        return 0;
    }
    int lengthOfLongestSubstring(string s) {
        int lengthmax=1;//s为空直接返回0，最小为1
        int lengthtmp=0;
        //int flag=0;
        vector&amp;lt;char&amp;gt; substring,tmp;
        vector&amp;lt;char&amp;gt;::iterator it_substring;
        if(s.length()==0) return 0;
        for(int i=0;i&amp;lt;s.length();i++)
        {
            for(int j=i;j&amp;lt;s.length();j++)
            {
                if(!substring.empty())//如果子串非空
                {
                    //flag=1;
                    for(it_substring=substring.begin();it_substring!=substring.end();it_substring++)
                    {
                        if(*it_substring==s[j]) break;
                    }
                    if(it_substring==substring.end())//遍历完一遍没找到重复元素
                    {
                        substring.push_back(s[j]);
                        lengthtmp++;
                    }
                    else//有重复元素,清空vector,记录此时长度
                    {
                        if(!tmp.empty())
                        {
                            if(tmp==substring&amp;amp;&amp;amp;tmp.size()&amp;gt;65) return tmp.size();
                        }
                        else
                        {
                            copyvector(substring,tmp);
                        }
                        if(lengthtmp&amp;gt;=lengthmax) lengthmax=lengthtmp;
                        substring.clear();
                        substring.push_back(s[j]);
                        lengthtmp=1;
                    }
                }
                else//子串空
                {
                    substring.push_back(s[j]);
                    lengthtmp=1;
                }
                if(lengthmax==s.length()) return lengthmax;//如果某遍历等于s长度，直接返回了
            }
            if(lengthtmp&amp;gt;=lengthmax) lengthmax=lengthtmp;
            substring.clear();
            lengthtmp=0;
        }        
        return lengthmax;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;正确思路滑动窗口&#34;&gt;正确思路——滑动窗口&lt;/h3&gt;
">LeetCode刷题笔记——滑动窗口</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/shu-ju-ku-xue-xi-bi-ji/"" data-c="
          &lt;h2 id=&#34;查找重复元素&#34;&gt;查找重复元素&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;编写一个 SQL 查询，查找 Person 表中所有重复的电子邮箱。

示例：

+----+---------+
| Id | Email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
根据以上输入，你的查询应返回以下结果：

+---------+
| Email   |
+---------+
| a@b.com |
+---------+
说明：所有电子邮箱都是小写字母。
来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/duplicate-emails
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;答案：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;select distinct Email from Person where Email in (select Email from Person group by Email having count(Email) &amp;gt; 1)
&lt;/code&gt;&lt;/pre&gt;
">数据库学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/shu-ju-ku-zuo-lian-jie-he-you-lian-jie/"" data-c="
          &lt;p&gt;左（外）连接：left join，左边有的，右边没有的为null，左边都保留&lt;br&gt;
右（外）连接：right join，左边没有的，右边有的为null，右边都保留&lt;br&gt;
内部连接：两边都有的留下来&lt;/p&gt;
">数据库左连接和右连接</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/conda-cha-kan-ji-tian-jia-jing-xiang-yuan/"" data-c="
          &lt;p&gt;查看源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conda config --show-sources
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加仓库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
conda config --set show_channel_urls yes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第三方源&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/bioconda/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/menpo/
conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/
&lt;/code&gt;&lt;/pre&gt;
">conda查看及添加镜像源</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/sudo-conda-command-not-found/"" data-c="
          &lt;p&gt;修改.bashrc文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$alias sudo=&#39;sudo env PATH=$PATH&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$source ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;
">sudo: conda: command not found</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/stroke-constrained-attention-network-for-online-handwritten-mathematical-expression-recognition-bi-ji/"" data-c="
          &lt;h2 id=&#34;1-introduction部分&#34;&gt;1 Introduction部分&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;关于解决符号识别和结构分析&lt;br&gt;
sequential methods：首先将表达式分段输入到数学符号中，并分别识别它们。然后根据符号识别结果进行结构分析，找出表达式的结构&lt;br&gt;
global methods：处理 hmer 作为一个全局优化的符号识别和结构分析。符号分割是隐式执行的。&lt;/li&gt;
&lt;li&gt;直观地利用动态轨迹和静态图像建立一个更强大的识别系统，称为多模态 hmer （multi-modal HMER）
&lt;ul&gt;
&lt;li&gt;随着深度学习的兴起，基于注意力的编解码方法被广泛应用于 hmer，这种方法可以分为在线和离线情况&lt;/li&gt;
&lt;li&gt;对于在线 hmer，[9,10]将手写数学表达式(hme)视为一个点序列，并从输入轨迹中提取点级特征
&lt;ul&gt;
&lt;li&gt;利用丰富的动态(空间和时间)信息对手写识别有着极大的帮助，在线手写体识别往往会遇到较少的手写模糊所带来的困难&lt;/li&gt;
&lt;li&gt;缺乏全局信息可能会导致延迟笔画或插入笔画造成错误识别&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;对于离线 hmer，[11,12]将 hme 作为静态图像，并从输入图像中提取像素级特征&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;本文提出了一种基于笔画约束的在线 hmer 注意网络(stroke constrained attention network，scan) ，该网络将笔画作为编解码模型的基本单元。它既可以用于单模态，也可以用于多模态。
&lt;ol&gt;
&lt;li&gt;(i) It greatly improves the alignment generated by attention;&lt;/li&gt;
&lt;li&gt;(ii) The number of strokes is much smaller than the number of points or pixels, which helps accelerate the decoding process;&lt;/li&gt;
&lt;li&gt;(iii) For multi-modal recognition, SCAN provides oracle alignments between online traces and offline images, which enables to fuse features from different modalities in encoder and significantly improves the performance.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;特征提取&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;对于在线模态，我们采用了一个基于门控递归单元(cnn-gru)的编码器卷积神经网络，从输入跟踪序列中提取点级特征。然后利用笔画约束信息，即点与笔画之间的对应关系，将点级特征转换为在线笔画级特征。同样，对于离线模态，我们采用基于 cnn 的编码器从输入图像中提取像素级特征，然后将其转换为离线笔划级特征。引入注意力解码器生成识别结果，注意力实际上隐含地实现了符号分割。笔划级特征作为一种从低层点/像素特征中提取的更高层次、更准确的表示方法，可以潜在地降低符号分割和识别的难度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;对于多模态 hmer，SCAN不仅可以将点和像素按笔划分组，从而产生更有效的符号分割，而且可以使编码器中不同模式的特征融合成为可能。
&lt;ol&gt;
&lt;li&gt;编码融合（encoder fusion）
&lt;ol&gt;
&lt;li&gt;提出的编码器融合算法的一个优点是在解码器融合前一步进行信息交互，从而更早、更充分地发挥多种方式的优势。由于[13]以点和像素为基本单元，在线点级特征和离线像素级特征之间没有明确对齐的情况下，很难实现编码器融合&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;解码融合（dedoder fusion）
&lt;ol&gt;
&lt;li&gt;在这项工作中，多模态注意配备了重新注意机制，通过生成一个包含两种在线和离线模式信息的多模态笔画级上下文矢量来指导解码过程。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如图1所示，scan 将stroke视为基本单位，因此在stroke级别的特征之间存在在线和离线。因此，我们可以融合它们在编码器，以获得多模态笔画水平的特征，然后反馈到解码器。最后采用注意机制指导解码过程，逐步生成识别结果。它可以利用这两个在线和离线信息获得更准确的注意结果，并显著提高在线 hmer 的性能&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;本文主要工作
&lt;ol&gt;
&lt;li&gt;通过充分利用笔划信息，提出了一种新的基于在线HMER的编码器-解码器SCAN框架。&lt;/li&gt;
&lt;li&gt;通过在线/离线笔划级特征的新颖设计，提出了一种单模态SCAN方法&lt;/li&gt;
&lt;li&gt;介绍了一种多模式SCAN方法，采用了两种融合策略，即编码器融合和解码器融合。&lt;/li&gt;
&lt;li&gt;我们通过对stroke级特征的注意可视化来证明SCAN的有效性和效率&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;五个方面
&lt;ol&gt;
&lt;li&gt;笔画作为高层次的表示，而不是点/像素作为单模态和多模态 hmer 的低层次表示&lt;/li&gt;
&lt;li&gt;笔划级别的特征用于多模态注意，配备了再注意功能，以显示笔划约束信息的强度;&lt;/li&gt;
&lt;li&gt;在编码融合策略中充分利用了在线和离线级别的特征;&lt;/li&gt;
&lt;li&gt;提出了一个笔划级别的注意引导器，以帮助更好地学习注意力;&lt;/li&gt;
&lt;li&gt;在已公布的 crohme2014/crohme2016/crohme2019基准上设计了一套综合实验。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-related-work&#34;&gt;2 Related Work&lt;/h2&gt;
&lt;h3 id=&#34;21-traditional-approaches-for-hmer&#34;&gt;2.1 Traditional approaches for HMER&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在线 hmer 的一个关键特性是在书写过程中可以获得笔尖运动(xy 坐标)和笔状态(笔下行和笔上行)。对于 hmer [14,15,16]的传统方法通常利用钢笔状态提前对属于同一笔划的轨迹点进行分组，并将笔划作为基本单位，即将数学表达式表示为一组笔划。Hmer 的过程可分为两个步骤: 符号识别和结构分析。符号识别包括符号分割和分类。符号分割实际上是对属于同一个符号的笔画进行分组。这两个步骤可以单独或联合实现，分别引用顺序方法和全局方法。顺序方法[5,6]首先通过寻找最佳的笔画组和识别与每个笔画组相对应的符号来实现符号识别。然后用句法模型表示符号之间的空间关系，如树型结构模型[17]。在顺序方法中，上下文信息没有得到充分利用，符号分割/识别错误将随后传播到结构分析中。相反，整体方法[7,8]使用完全表达式同时优化符号识别和结构分析。然而，全局搜索方法在计算上更加昂贵，因此必须定义有效的搜索策略。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;22-attention-based-encoder-decoder-approches-for-hmer&#34;&gt;2.2 Attention based encoder-decoder approches for HMER&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;编解码框架已广泛应用于许多应用，包括机器翻译[19,20,21]、语音识别[22,23]和图像标题[24,25,26]。通常，首先使用编码器从输入中提取高级表示。然后，应用解码器逐步生成可变长度的序列作为输出。为了解决输入和输出都是可变长度的问题，译码器通常采用注意机制[27,28,29] ，通过对可变长度的高层表示进行加权平均，生成一个固定长度的上下文矢量来指导译码过程。随着深度学习技术的发展，基于注意机制的编译码方法也被广泛应用于 hmer，它将树型结构的输出格式转换为乳胶字符串，显著地优于传统的编译码方法。按照 hmer 的输入方式不同，这些方法可以分为在线和离线输入法。在线方法将 hme 视为动态跟踪，而离线方法将 hme 视为静态图像。在线方法[9]采用了空间注意的基于 gru 的编码器和基于 gru 的解码器，与传统的 hmer 方法相比，取得了显著的改进。[10]引入了一种带有额外时间注意力和注意引导器的点击模式，以进一步提高性能。此外，[30]在编码器中采用了剩余连接，在解码器中采用了转换转移矩阵。对于离线方法，[11]采用了一种 wap 模型，该模型采用基于 cnnbased 编码器从静态图像中提取特征。[12]提出了一个从粗到细的注意力提高效率的方法。此外，[31]引入了 pal 模式，并在培训中采用了对抗性学习策略。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;23-multi-modal-machine-learning&#34;&gt;2.3 Multi-modal machine learning&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;最近，越来越多的研究集中在多模态机器学习，其目的是利用优势和互补的多模态[32,33,34,35]。多模态的一个重要主题是如何将不同模式的信息融合起来。针对不同长度的特征，如句子、视频和音频流，多模态融合的一个难点是不同形态的不对齐性。由于基于编解码器的框架被广泛应用于序列机器学习，本文重点讨论了在编码和解码阶段的多模态融合技术。一般来说，编码器中的融合特征可以获得比解码器[38,39]更好的性能，因为来自不同方式的信息可以更早地交互。然而，我们通常缺乏最佳的映射之间的不同形式，这使编码器融合的挑战。虽然[40,41]利用跨模态自我注意来实现编码融合，但由于跨模态自我注意所获得的对齐不能保证准确，因此仍然存在不对齐问题。不同的是，对于在线 hmer，我们可以通过充分利用笔划约束信息来获得在线和离线模式之间的 oracle 比对(oracle alignments)。因此，在这项研究中，我们提出SCAN来实现编码器中的在线和离线模式融合，这将显著提高识别性能。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-single-modal-scan&#34;&gt;3 Single-modal SCAN&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在这一部分，我们介绍了建议的单模态 hmer SCAN，包括在线SCAN(onscan)和离线SCAN(offscan)。与以往的单模态方法[10,11,12]不同，我们在基于 hmer 的编解码器中明确地利用了笔画约束信息。具体来说，SCAN中采用的是笔划级特征，而不是点级和像素级特征。此外，解码器的注意机制是发现预测的数学符号与输入特征之间的对齐关系。因此，&lt;strong&gt;SCAN中的注意实际上是对属于同一个符号的笔画进行分组&lt;/strong&gt;，这显然比以往的笔画特征分组方法更简单、更有效，因为笔画级特征是一种比局部点级或像素级特征更高层次的注意表示，可以降低注意难度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;31-data-preparation&#34;&gt;3.1 Data Preparation&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;对于在线 hmer，输入的原始数据是手写的痕迹，可以表示为可变长度的序列:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;{[x1, y1, s1] , [x2, y2, s2] , · · · , [xN , yN , sN ]}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 xi 和 yi 是笔运动的 xy 坐标，si 表示第 i 点属于哪个笔划。&lt;/p&gt;
&lt;h4 id=&#34;311-input-features&#34;&gt;3.1.1 Input Features&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;在线8维向量：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;xoni = [xi, yi,∆xi,∆yi,∆2xi,∆2yi, strokeFlag1, strokeFlag2]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中: xi = xi 1-xi，something yi = yi 1-yi，something 2xi = xi 2-xi，something 2yi = yi 2-yi。最后两个词是表示钢笔状态的标志，即[1,0]表示“ pen-down”，而[0,1]表示“ pen-up”。我们将处理后的跟踪点序列称为 xon = { xon1，xon2，，xonn } ，其中 n 表示跟踪点的个数。&lt;br&gt;
2. 离线&lt;br&gt;
对于离线模式，我们首先计算所有笔画的高度。然后计算高度大于最大高度的十分之一的笔画的平均高度。在此基础上，根据平均高度对所有点的 xy 坐标进行归一化处理，并简单地将每一笔的轨迹点直线化为静态图像，减小了大小为 hin × win。&lt;/p&gt;
&lt;h4 id=&#34;312-stroke-masks&#34;&gt;3.1.2 Stroke Masks&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;在线情况：&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;msup&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;{&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;msubsup&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/msubsup&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;msubsup&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/msubsup&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;msubsup&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/msubsup&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;msubsup&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/msubsup&gt;&lt;mo&gt;}&lt;/mo&gt;&lt;mspace linebreak=&#34;newline&#34;&gt;&lt;/mspace&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Mask^{on}=\{mask^{on}_1,mask^{on}_2,mask^{on}_3,....,mask^{on}_M\}\\&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.69444em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.664392em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.025331em;vertical-align:-0.275331em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.664392em;&#34;&gt;&lt;span style=&#34;top:-2.4518920000000004em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.24810799999999997em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.664392em;&#34;&gt;&lt;span style=&#34;top:-2.4518920000000004em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.24810799999999997em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.664392em;&#34;&gt;&lt;span style=&#34;top:-2.4518920000000004em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.24810799999999997em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.664392em;&#34;&gt;&lt;span style=&#34;top:-2.424669em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.275331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace newline&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;
M个笔画&lt;br&gt;
N个点（公式的所有点）&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;msubsup&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;/msubsup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;mask^{on}_j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.0892119999999998em;vertical-align:-0.394772em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.664392em;&#34;&gt;&lt;span style=&#34;top:-2.441336em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.394772em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;是一个N维的向量，第i个点要在第j个笔画上，就为1，不在就是0&lt;/li&gt;
&lt;li&gt;离线情况：&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;msup&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;/mrow&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;{&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;msubsup&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;/mrow&gt;&lt;/msubsup&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;msubsup&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;/mrow&gt;&lt;/msubsup&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;msubsup&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;mrow&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;/mrow&gt;&lt;/msubsup&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;msubsup&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;M&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;/mrow&gt;&lt;/msubsup&gt;&lt;mo&gt;}&lt;/mo&gt;&lt;mspace linebreak=&#34;newline&#34;&gt;&lt;/mspace&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;Mask^{off}=\{mask^{off}_1,mask^{off}_2,mask^{off}_3,....,mask^{off}_M\}\\&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.8491079999999999em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8491079999999999em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.2605469999999999em;vertical-align:-0.293531em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9670159999999999em;&#34;&gt;&lt;span style=&#34;top:-2.433692em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.1809080000000005em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.266308em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9670159999999999em;&#34;&gt;&lt;span style=&#34;top:-2.433692em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.1809080000000005em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.266308em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9670159999999999em;&#34;&gt;&lt;span style=&#34;top:-2.433692em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.1809080000000005em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.266308em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9670159999999999em;&#34;&gt;&lt;span style=&#34;top:-2.4064690000000004em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10903em;&#34;&gt;M&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.1809080000000005em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.293531em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace newline&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;m&lt;/mi&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;s&lt;/mi&gt;&lt;msubsup&gt;&lt;mi&gt;k&lt;/mi&gt;&lt;mi&gt;j&lt;/mi&gt;&lt;mrow&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;mi&gt;f&lt;/mi&gt;&lt;/mrow&gt;&lt;/msubsup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;mask^{off}_j&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.379988em;vertical-align:-0.412972em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.03148em;&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.9670159999999999em;&#34;&gt;&lt;span style=&#34;top:-2.4231360000000004em;margin-left:-0.03148em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.05724em;&#34;&gt;j&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.1809080000000005em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;mord mathdefault mtight&#34; style=&#34;margin-right:0.10764em;&#34;&gt;f&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.412972em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;是一个h*w的矩阵，每个（h,w）处，若该点在j笔画上，就置为1，否则置为0&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;32-online-encoder&#34;&gt;3.2 Online Encoder&lt;/h3&gt;
&lt;p&gt;CNN的输入：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;X&lt;/mi&gt;&lt;mi&gt;o&lt;/mi&gt;&lt;/msup&gt;&lt;mi&gt;n&lt;/mi&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;X^on&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.07847em;&#34;&gt;X&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.664392em;&#34;&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;o&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;n&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;转换成的8×1×N的张量&lt;br&gt;
卷积层：密集连接的层，特征映射的高度为1时，卷积层的内核大小从3×3修改为1×3&lt;br&gt;
CNN的输出：1×L×&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;D_0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;
&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msup&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;msup&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;mo mathvariant=&#34;normal&#34;&gt;′&lt;/mo&gt;&lt;/msup&gt;&lt;/msup&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;{&lt;/mo&gt;&lt;msubsup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;msup&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;mo mathvariant=&#34;normal&#34;&gt;′&lt;/mo&gt;&lt;/msup&gt;&lt;/msubsup&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msubsup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;msup&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;mo mathvariant=&#34;normal&#34;&gt;′&lt;/mo&gt;&lt;/msup&gt;&lt;/msubsup&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msubsup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;msup&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;mo mathvariant=&#34;normal&#34;&gt;′&lt;/mo&gt;&lt;/msup&gt;&lt;/msubsup&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msubsup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;msup&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;mo mathvariant=&#34;normal&#34;&gt;′&lt;/mo&gt;&lt;/msup&gt;&lt;/msubsup&gt;&lt;mo&gt;}&lt;/mo&gt;&lt;mspace linebreak=&#34;newline&#34;&gt;&lt;/mspace&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A^{&amp;#x27;}=\{a^{&amp;#x27;}_1,a^{&amp;#x27;}_2,a^{&amp;#x27;}_3,....,a^{&amp;#x27;}_L\}\\&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.94248em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.94248em;&#34;&gt;&lt;span style=&#34;top:-2.94248em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.57948em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8278285714285715em;&#34;&gt;&lt;span style=&#34;top:-2.931em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.217811em;vertical-align:-0.275331em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.94248em;&#34;&gt;&lt;span style=&#34;top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8278285714285715em;&#34;&gt;&lt;span style=&#34;top:-2.931em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.24810799999999997em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.94248em;&#34;&gt;&lt;span style=&#34;top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8278285714285715em;&#34;&gt;&lt;span style=&#34;top:-2.931em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.24810799999999997em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.94248em;&#34;&gt;&lt;span style=&#34;top:-2.4518920000000004em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8278285714285715em;&#34;&gt;&lt;span style=&#34;top:-2.931em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.24810799999999997em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.94248em;&#34;&gt;&lt;span style=&#34;top:-2.424669em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;L&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8278285714285715em;&#34;&gt;&lt;span style=&#34;top:-2.931em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.275331em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace newline&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;
每个&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msubsup&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;i&lt;/mi&gt;&lt;msup&gt;&lt;mrow&gt;&lt;/mrow&gt;&lt;mo mathvariant=&#34;normal&#34;&gt;′&lt;/mo&gt;&lt;/msup&gt;&lt;/msubsup&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;a^{&amp;#x27;}_i&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1.201144em;vertical-align:-0.258664em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.94248em;&#34;&gt;&lt;span style=&#34;top:-2.441336em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;i&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;top:-3.063em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.8278285714285715em;&#34;&gt;&lt;span style=&#34;top:-2.931em;margin-right:0.07142857142857144em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.5em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size3 size1 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;′&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.258664em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;是一个&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;msub&gt;&lt;mi&gt;D&lt;/mi&gt;&lt;mn&gt;0&lt;/mn&gt;&lt;/msub&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;D_0&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.83333em;vertical-align:-0.15em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34; style=&#34;margin-right:0.02778em;&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;维的向量&lt;br&gt;
CNN-GRU encoder的输出：&lt;span class=&#34;katex&#34;&gt;&lt;span class=&#34;katex-mathml&#34;&gt;&lt;math&gt;&lt;semantics&gt;&lt;mrow&gt;&lt;mi&gt;A&lt;/mi&gt;&lt;mo&gt;=&lt;/mo&gt;&lt;mo&gt;{&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;1&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;2&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mn&gt;3&lt;/mn&gt;&lt;/msub&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mi mathvariant=&#34;normal&#34;&gt;.&lt;/mi&gt;&lt;mo separator=&#34;true&#34;&gt;,&lt;/mo&gt;&lt;msub&gt;&lt;mi&gt;a&lt;/mi&gt;&lt;mi&gt;L&lt;/mi&gt;&lt;/msub&gt;&lt;mo&gt;}&lt;/mo&gt;&lt;mspace linebreak=&#34;newline&#34;&gt;&lt;/mspace&gt;&lt;/mrow&gt;&lt;annotation encoding=&#34;application/x-tex&#34;&gt;A=\{a_1,a_2,a_3,....,a_L\}\\&lt;/annotation&gt;&lt;/semantics&gt;&lt;/math&gt;&lt;/span&gt;&lt;span class=&#34;katex-html&#34; aria-hidden=&#34;true&#34;&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:0.68333em;vertical-align:0em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mrel&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.2777777777777778em;&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;base&#34;&gt;&lt;span class=&#34;strut&#34; style=&#34;height:1em;vertical-align:-0.25em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mopen&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.30110799999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mtight&#34;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mpunct&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mspace&#34; style=&#34;margin-right:0.16666666666666666em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;mord&#34;&gt;&lt;span class=&#34;mord mathdefault&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;msupsub&#34;&gt;&lt;span class=&#34;vlist-t vlist-t2&#34;&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.32833099999999993em;&#34;&gt;&lt;span style=&#34;top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;&#34;&gt;&lt;span class=&#34;pstrut&#34; style=&#34;height:2.7em;&#34;&gt;&lt;/span&gt;&lt;span class=&#34;sizing reset-size6 size3 mtight&#34;&gt;&lt;span class=&#34;mord mathdefault mtight&#34;&gt;L&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-s&#34;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;vlist-r&#34;&gt;&lt;span class=&#34;vlist&#34; style=&#34;height:0.15em;&#34;&gt;&lt;span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mclose&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;mspace newline&#34;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
">Stroke Constrained Attention Network for Online Handwritten Mathematical Expression Recognition笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/vnc-lian-jie-ubuntu-shi-yong-zhu-yi/"" data-c="
          &lt;ol&gt;
&lt;li&gt;安装vncserver&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install vnc4server
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;启动vncserver&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;vncserver
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;输入密码，确认密码&lt;br&gt;
3. 配置图形界面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo apt-get install gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非常重要的一步：修改vnc启动文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo vim ~/.vnc/xstartup
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加以下内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#Uncomment the following two lines for normal desktop:
export XKL_XMODMAP_DISABLE=1
unset SESSION_MANAGER
#exec /etc/X11/xinit/xinitrc
unset DBUS_SESSION_BUS_ADDRESS
gnome-panel &amp;amp;
gnome-settings-daemon &amp;amp;
metacity &amp;amp;
nautilus &amp;amp;
gnome-terminal &amp;amp;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：想要创建虚拟桌面的每个用户都得修改这个配置文件，不然只有修改了配置文件的用户才能连接成功&lt;/strong&gt;&lt;br&gt;
4. 启动vnc客户端&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ip:桌面号
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;要在用户下，不能在root用户下&lt;/li&gt;
&lt;/ol&gt;
">vnc连接ubuntu使用注意</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/ssh-shi-yong/"" data-c="
          &lt;h2 id=&#34;上传文件&#34;&gt;上传文件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;scp /path/filename username@servername:/path
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例如&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;scp /var/www/test.php  root@192.168.0.101:/var/www/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;上传目录&#34;&gt;上传目录&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;scp  -r local_dir username@servername:remote_dir

scp -r test  root@192.168.0.101:/var/www/

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;报错not-a-regular-file&#34;&gt;报错not a regular file&lt;/h2&gt;
&lt;p&gt;可以用scp -r来进行传输&lt;/p&gt;
">ssh使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/ubuntu-chuang-jian-xin-yong-hu-wu-fa-deng-lu/"" data-c="
          &lt;p&gt;useradd不行，得用adduser，然后按提示来&lt;/p&gt;
">Ubuntu创建新用户无法登陆</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/jie-jue-attributeerror-module-scipyndimage-has-no-attribute-imread/"" data-c="
          &lt;p&gt;吴恩达深度学习第一课第二周作业中的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import matplotlib

## START CODE HERE ##
import matplotlib
my_image = &amp;quot;dog.jpg&amp;quot; # change this to the name of your image file 
my_label_y = [1] # the true class of your image (1 -&amp;gt; cat, 0 -&amp;gt; non-cat)
## END CODE HERE ##

fname = &amp;quot;images/&amp;quot; + my_image
image = np.array(matplotlib.pyplot.imread(fname))
my_image = np.array(Image.fromarray(image).resize(size=(num_px,num_px))).reshape((1, num_px*num_px*3)).T
# image = np.array(ndimage.imread(fname, flatten=False))
# my_image = scipy.misc.imresize(image, size=(num_px,num_px)).reshape((num_px*num_px*3,1))
my_predicted_image = predict(my_image, my_label_y, parameters)

plt.imshow(image)
print (&amp;quot;y = &amp;quot; + str(np.squeeze(my_predicted_image)) + &amp;quot;, your L-layer model predicts a \&amp;quot;&amp;quot; + classes[int(np.squeeze(my_predicted_image)),].decode(&amp;quot;utf-8&amp;quot;) +  &amp;quot;\&amp;quot; picture.&amp;quot;)

&lt;/code&gt;&lt;/pre&gt;
">解决AttributeError: module ‘scipy.ndimage‘ has no attribute ‘imread‘</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/guan-yu-numpy-de-shi-yong/"" data-c="
          &lt;ol&gt;
&lt;li&gt;np.dot与np.multiply&lt;br&gt;
前者是线代中的运算，后者是对应位置的元素相乘&lt;/li&gt;
&lt;li&gt;A trick when you want to flatten a matrix X of shape (a,b,c,d) to a matrix X_flatten of shape (b ∗ c ∗ d, a) is to use:&lt;br&gt;
X_flatten = X.reshape(X.shape[0], -1).T      # X.T is the transpose of X&lt;/li&gt;
&lt;/ol&gt;
">关于numpy的使用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/shen-du-xue-xi-xue-xi-bi-ji/"" data-c="
          &lt;h2 id=&#34;第二周&#34;&gt;第二周&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;当你将这个向量加上这个实数时，Python 自动把这个实数 𝑏 扩展成一个 1 × 𝑚 的行向量。&lt;br&gt;
所以这种情况下的操作似乎有点不可思议，它在 Python 中被称作广播(brosdcasting)&lt;/li&gt;
&lt;li&gt;numpy中（n，）与（n，1）的区别&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;if
a.shape=(n,)
b.shape=(n,)
then
a*b转置和b转置*a都是一个数
if
a.shape=(n,1)
b.shape=(n,1)
和线代计算规则一样了
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;纬度，轴，秩&lt;br&gt;
a=[1,2,3]:一维&lt;br&gt;
b=[[1,2,3],[1,2,3]]:二维&lt;br&gt;
c=[  [  [1,2,3],[1,2,3]   ]   ,  [   [1,2,3],[1,2,3]   ]  ,   [   [1,2,3],[1,2,3]   ]]:三维&lt;br&gt;
轴：对于二维来说，行是axis0，列是axis1，三维那个竖着的是axis0&lt;br&gt;
a.shape=(2,3)&lt;br&gt;
b.shape=(3,2,3):3层，每层2行3列&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;第三周-浅层神经网络&#34;&gt;第三周 浅层神经网络&lt;/h2&gt;
&lt;h3 id=&#34;常用激活函数&#34;&gt;常用激活函数&lt;/h3&gt;
&lt;p&gt;sigmoid，tanh，Relu，leaky relu&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在讨论优化算法时，有一点要说明：我基本已经不用 sigmoid 激活函数了，tanh 函数在所有场合都优于 sigmoid 函数。但有一个例外：在二分类的问题中，对于输出层，因为𝑦的值是 0 或 1，所以想让𝑦^的数值介于 0 和 1 之间，而不是在-1 和+1 之间。所以需要使用 sigmoid 激活函数。&lt;/li&gt;
&lt;li&gt;relu函数在大于0时，是线性的，在小于0时也是线性的，但是整体是非线性的&lt;/li&gt;
&lt;li&gt;在实践中，使用 ReLu 激活函数神经网络通常会比使用 sigmoid 或者 tanh 激活函数学习的更快。&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;sigmoid 激活函数：除了输出层是一个二分类问题基本不会用它。&lt;br&gt;
tanh 激活函数：tanh 是非常优秀的，几乎适合所有场合。&lt;br&gt;
ReLu 激活函数：最常用的默认函数，，如果不确定用哪个激活函数，就使用 ReLu 或者Leaky ReLu。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;第四周-深层神经网路&#34;&gt;第四周 深层神经网路&lt;/h2&gt;
&lt;h3 id=&#34;偏差方差&#34;&gt;偏差，方差&lt;/h3&gt;
&lt;h4 id=&#34;高方差&#34;&gt;高方差：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;特点：训练集err%低，验证集err%高，过拟合的&lt;/li&gt;
&lt;li&gt;解决方法：
&lt;ol&gt;
&lt;li&gt;正则化&lt;/li&gt;
&lt;li&gt;准备更多数据&lt;br&gt;
低方差：&lt;br&gt;
训练集err%高&lt;br&gt;
验证集err%高（和训练集的差不多）&lt;br&gt;
欠拟合的&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;第四门-卷积神经网络&#34;&gt;第四门 卷积神经网络&lt;/h2&gt;
&lt;h3 id=&#34;padding&#34;&gt;padding&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;valid卷积：不填充&lt;br&gt;
有一个𝑛 × 𝑛的图像，用一个𝑓 × 𝑓的过滤器&lt;br&gt;
卷积，它将会给你一个(𝑛 − 𝑓 + 1) × (𝑛 − 𝑓 + 1)维的输出&lt;/li&gt;
&lt;li&gt;same卷积：填充，使卷积后的和原图一样大&lt;br&gt;
根据这个公式𝑛 − 𝑓 + 1，当你填充𝑝个像素点，𝑛就变成了𝑛 + 2𝑝，最后公式变为𝑛 + 2𝑝 − 𝑓 + 1。因此如果你有一个𝑛 × 𝑛的图像，用𝑝个像素填充边缘，输出的大小就是这样的(𝑛 + 2𝑝 − 𝑓 + 1) × (𝑛 + 2𝑝 − 𝑓 + 1)。如果你想让𝑛 + 2𝑝 − 𝑓 + 1 = 𝑛的话，使得输出和输入大小相等，如果你用这个等式求解𝑝，那么𝑝 = (𝑓 − 1)/2&lt;/li&gt;
&lt;li&gt;习惯上，计算机视觉中，𝑓通常是奇数&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;输出计算&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;fxf的过滤器，nxn的图像，步长s，padding为p，输出为（n+2p-f）/s+1    x    （n+2p-f）/s+1：向下取整&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
">深度学习学习笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/jupyter-notebook-shi-yong-wen-ti-zen-me-xiu-gai-da-kai-shi-de-mo-ren-mu-lu/"" data-c="
          &lt;ol&gt;
&lt;li&gt;打开anaconda prompt，输入&lt;code&gt; jupyter notebook --generate-config&lt;/code&gt;,查看jupyter_notebook_config.py路径&lt;/li&gt;
&lt;li&gt;修改该文件内容&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;## The directory to use for notebooks and kernels.
#c.NotebookApp.notebook_dir = &#39;&#39;  要是想改到某个磁盘的根目录，比如D盘就是  D：
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;找到Jupyter notebook的快捷方式，右键属性，快捷方式栏下的目标里的内容，删除%USERPROFILE%，这一步非常关键，没有的话是改不了的。&lt;/li&gt;
&lt;/ol&gt;
">Jupyter notebook使用问题怎么修改打开时的默认目录</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/ddl-yu-dml-de-qu-bie/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;DML(Data Manipulation Language)数据操纵语言：&lt;br&gt;
适用范围：对数据库中的数据进行一些简单操作，如insert,delete,update,select等.&lt;br&gt;
DDL(Data Definition Language)数据定义语言：&lt;br&gt;
适用范围：对数据库中的某些对象(例如，database,table)进行管理，如Create,Alter和Drop.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;1-ddl数据定义语言data-definition-language&#34;&gt;1 DDL(数据定义语言,Data Definition Language)&lt;/h2&gt;
&lt;p&gt;建库、建表、设置约束等：create\drop\alter&lt;br&gt;
1、创建数据库:&lt;br&gt;
create database IF NOT EXISTS hncu CHARACTER SET utf8;&lt;/p&gt;
&lt;p&gt;2、创建表格:&lt;br&gt;
use hncu;&lt;br&gt;
create table IF NOT EXISTS stud(&lt;br&gt;
id int,&lt;br&gt;
name varchar(30),&lt;br&gt;
age int&lt;br&gt;
);&lt;/p&gt;
&lt;p&gt;3、更改表结构(设置约束)&lt;br&gt;
desc stud; //查看表结构&lt;br&gt;
alter table stud drop column age;&lt;br&gt;
alter table stud add column age int;&lt;/p&gt;
&lt;p&gt;4、删除表、删除数据库&lt;br&gt;
drop table stud;&lt;br&gt;
drop database hncu;&lt;/p&gt;
&lt;h2 id=&#34;2-dml-数据操纵语言data-manipulation-language&#34;&gt;2 DML (数据操纵语言，Data Manipulation Language )&lt;/h2&gt;
&lt;p&gt;主要指数据的增删查改: Select\delete\update\insert\call&lt;/p&gt;
&lt;p&gt;select * from stud;&lt;br&gt;
select name,age from stud; //查询指定的列&lt;br&gt;
select name as 姓名, age as 年龄 from stud;&lt;/p&gt;
">DDL与DML的区别</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/cde-vector-yong-fa-zong-jie-冲突-宋宇航_Win10/"" data-c="
          &lt;h2 id=&#34;1-初始化&#34;&gt;1 初始化&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;      (1) vector&amp;lt;int&amp;gt; a(10); //定义了10个整型元素的向量（尖括号中为元素类型名，它可以是任何合法的数据类型），但没有给出初值，其值是不确定的。
   （2）vector&amp;lt;int&amp;gt; a(10,1); //定义了10个整型元素的向量,且给出每个元素的初值为1
   （3）vector&amp;lt;int&amp;gt; a(b); //用b向量来创建a向量，整体复制性赋值
   （4）vector&amp;lt;int&amp;gt; a(b.begin(),b.begin+3); //定义了a值为b中第0个到第2个（共3个）元素
   （5）int b[7]={1,2,3,4,5,9,8};
        vector&amp;lt;int&amp;gt; a(b,b+7); //从数组中获得初值
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-重要操作&#34;&gt;2 重要操作&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;    （1）a.assign(b.begin(), b.begin()+3); //b为向量，将b的0~2个元素构成的向量赋给a
    （2）a.assign(4,2); //是a只含4个元素，且每个元素为2
    （3）a.back(); //返回a的最后一个元素
    （4）a.front(); //返回a的第一个元素
    （5）a[i]; //返回a的第i个元素，当且仅当a[i]存在2013-12-07
    （6）a.clear(); //清空a中的元素
    （7）a.empty(); //判断a是否为空，空则返回ture,不空则返回false
    （8）a.pop_back(); //删除a向量的最后一个元素
    （9）a.erase(a.begin()+1,a.begin()+3); //删除a中第1个（从第0个算起）到第2个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+         3（不包括它）
    （10）a.push_back(5); //在a的最后一个向量后插入一个元素，其值为5
    （11）a.insert(a.begin()+1,5); //在a的第1个元素（从第0个算起）的位置插入数值5，如a为1,2,3,4，插入元素后为1,5,2,3,4
    （12）a.insert(a.begin()+1,3,5); //在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5
    （13）a.insert(a.begin()+1,b+3,b+6); //b为数组，在a的第1个元素（从第0个算起）的位置插入b的第3个元素到第5个元素（不包括b+6），如b为1,2,3,4,5,9,8         ，插入元素后为1,4,5,9,2,3,4,5,9,8
    （14）a.size(); //返回a中元素的个数；
    （15）a.capacity(); //返回a在内存中总共可以容纳的元素个数
    （16）a.resize(10); //将a的现有元素个数调至10个，多则删，少则补，其值随机
    （17）a.resize(10,2); //将a的现有元素个数调至10个，多则删，少则补，其值为2
    （18）a.reserve(100); //将a的容量（capacity）扩充至100，也就是说现在测试a.capacity();的时候返回值是100.这种操作只有在需要给a添加大量数据的时候才         显得有意义，因为这将避免内存多次容量扩充操作（当a的容量不足时电脑会自动扩容，当然这必然降低性能） 
    （19）a.swap(b); //b为向量，将a中的元素和b中的元素进行整体性交换
    （20）a==b; //b为向量，向量的比较操作还有!=,&amp;gt;=,&amp;lt;=,&amp;gt;,&amp;lt;
      (21)//distance计算第一个参数到第二个参数之间的距离。如果第二个参数的顺序在第一个参数前面的话,函数是会返回负值的；如果迭代器不在一个容器内,程序会抛出异常。
		return distance(v.begin(),it); 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-误区&#34;&gt;3 误区&lt;/h2&gt;
&lt;p&gt;一开始为空时并不能直接下标赋值,下面是错的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;vector&amp;lt;int&amp;gt; a;
a[i]=i;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;4-重要方法&#34;&gt;4 重要方法&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;algorithm&amp;gt;
（1）sort(a.begin(),a.end()); //对a中的从a.begin()（包括它）到a.end()（不包括它）的元素进行从小到大排列
（2）reverse(a.begin(),a.end()); //对a中的从a.begin()（包括它）到a.end()（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1
（3）copy(a.begin(),a.end(),b.begin()+1); //把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开        始复制，覆盖掉原有元素
（4）find(a.begin(),a.end(),10); //在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;5-注意事项&#34;&gt;5 注意事项&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;用vector作为函数的参数或者返回值时，需要注意写法eg：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;//注意“&amp;amp;”，一定记得写上，不能丢掉 double test(vector&amp;lt;int&amp;gt;&amp;amp;a, vector&amp;lt;int&amp;gt;&amp;amp;b)
&lt;/code&gt;&lt;/pre&gt;
">C++的vector用法总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/cde-vector-yong-fa-zong-jie/"" data-c="
          &lt;h2 id=&#34;1-初始化&#34;&gt;1 初始化&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;      (1) vector&amp;lt;int&amp;gt; a(10); //定义了10个整型元素的向量（尖括号中为元素类型名，它可以是任何合法的数据类型），但没有给出初值，其值是不确定的。
   （2）vector&amp;lt;int&amp;gt; a(10,1); //定义了10个整型元素的向量,且给出每个元素的初值为1
   （3）vector&amp;lt;int&amp;gt; a(b); //用b向量来创建a向量，整体复制性赋值
   （4）vector&amp;lt;int&amp;gt; a(b.begin(),b.begin+3); //定义了a值为b中第0个到第2个（共3个）元素
   （5）int b[7]={1,2,3,4,5,9,8};
        vector&amp;lt;int&amp;gt; a(b,b+7); //从数组中获得初值
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;2-重要操作&#34;&gt;2 重要操作&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;    （1）a.assign(b.begin(), b.begin()+3); //b为向量，将b的0~2个元素构成的向量赋给a
    （2）a.assign(4,2); //是a只含4个元素，且每个元素为2
    （3）a.back(); //返回a的最后一个元素
    （4）a.front(); //返回a的第一个元素
    （5）a[i]; //返回a的第i个元素，当且仅当a[i]存在2013-12-07
    （6）a.clear(); //清空a中的元素
    （7）a.empty(); //判断a是否为空，空则返回ture,不空则返回false
    （8）a.pop_back(); //删除a向量的最后一个元素
    （9）a.erase(a.begin()+1,a.begin()+3); //删除a中第1个（从第0个算起）到第2个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+         3（不包括它）
    （10）a.push_back(5); //在a的最后一个向量后插入一个元素，其值为5
    （11）a.insert(a.begin()+1,5); //在a的第1个元素（从第0个算起）的位置插入数值5，如a为1,2,3,4，插入元素后为1,5,2,3,4
    （12）a.insert(a.begin()+1,3,5); //在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5
    （13）a.insert(a.begin()+1,b+3,b+6); //b为数组，在a的第1个元素（从第0个算起）的位置插入b的第3个元素到第5个元素（不包括b+6），如b为1,2,3,4,5,9,8         ，插入元素后为1,4,5,9,2,3,4,5,9,8
    （14）a.size(); //返回a中元素的个数；
    （15）a.capacity(); //返回a在内存中总共可以容纳的元素个数
    （16）a.resize(10); //将a的现有元素个数调至10个，多则删，少则补，其值随机
    （17）a.resize(10,2); //将a的现有元素个数调至10个，多则删，少则补，其值为2
    （18）a.reserve(100); //将a的容量（capacity）扩充至100，也就是说现在测试a.capacity();的时候返回值是100.这种操作只有在需要给a添加大量数据的时候才         显得有意义，因为这将避免内存多次容量扩充操作（当a的容量不足时电脑会自动扩容，当然这必然降低性能） 
    （19）a.swap(b); //b为向量，将a中的元素和b中的元素进行整体性交换
    （20）a==b; //b为向量，向量的比较操作还有!=,&amp;gt;=,&amp;lt;=,&amp;gt;,&amp;lt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;3-误区&#34;&gt;3 误区&lt;/h2&gt;
&lt;p&gt;并不能直接下标赋值,下面是错的&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-C++&#34;&gt;vector&amp;lt;int&amp;gt; a;
a[i]=i;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;重要算法&#34;&gt;重要算法&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-c++&#34;&gt;#include&amp;lt;algorithm&amp;gt;
（1）sort(a.begin(),a.end()); //对a中的从a.begin()（包括它）到a.end()（不包括它）的元素进行从小到大排列
（2）reverse(a.begin(),a.end()); //对a中的从a.begin()（包括它）到a.end()（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1
（3）copy(a.begin(),a.end(),b.begin()+1); //把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开        始复制，覆盖掉原有元素
（4）find(a.begin(),a.end(),10); //在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置
&lt;/code&gt;&lt;/pre&gt;
">C++的vector用法总结</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/shu-ju-ku-xue-xi-冲突-宋宇航_Win10/"" data-c="
          &lt;h2 id=&#34;1-基本概念&#34;&gt;1 基本概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;最终用户——交互式用户。
&lt;ul&gt;
&lt;li&gt;临时用户—用SQL访问DBMS的用户。&lt;/li&gt;
&lt;li&gt;初级用户——通过菜单访问DBMS的用户。·&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用程序员——编写菜单程序的程序员。&lt;/li&gt;
&lt;li&gt;数据库管理员——管理DBMS的专家。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;行列相关&#34;&gt;行列相关&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://imgtu.com/i/6ddAN6&#34;&gt;&lt;img src=&#34;https://s3.ax1x.com/2021/03/13/6ddAN6.png&#34; alt=&#34;6ddAN6.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://imgtu.com/i/6daWAP&#34;&gt;&lt;img src=&#34;https://s3.ax1x.com/2021/03/13/6daWAP.png&#34; alt=&#34;6daWAP.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;列:属性&lt;br&gt;
行:元组&lt;br&gt;
表:关系&lt;br&gt;
表的标题:关系模式,组成关系的属性的集合&lt;br&gt;
数据库:表/关系的集合&lt;br&gt;
数据库所有的关系模式的集合构成了数据库的模式&lt;br&gt;
表的行(元组)集合:表的内容;行数叫做表的基数&lt;/p&gt;
&lt;h3 id=&#34;域的概念&#34;&gt;域的概念&lt;/h3&gt;
&lt;p&gt;表T的属性A的取值范围集合D,D就叫做域&lt;/p&gt;
&lt;h2 id=&#34;2-关系规则&#34;&gt;2 关系规则&lt;/h2&gt;
&lt;h3 id=&#34;21-规则一第一范式&#34;&gt;2.1 规则一:第一范式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;概念&lt;br&gt;
规则1 第一范式规则 在定义的表中，关系模型坚持不允许含有多值属性（有时称为重复字段）和含有内部结构（比如记录类型）的列。遵守这样规则的表称为第一范式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要求&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这是不被允许的&lt;a href=&#34;https://imgtu.com/i/6dBSgS&#34;&gt;&lt;img src=&#34;https://s3.ax1x.com/2021/03/13/6dBSgS.png&#34; alt=&#34;6dBSgS.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;第一范式规则同时也要求任何列的值都必须是简单类型，不允许包含内部结构。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;规则二&#34;&gt;规则二&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;概念&lt;br&gt;
只能基于内容存取行规则&lt;br&gt;
但是存在RID,一般也不会用这个来查询&lt;/li&gt;
&lt;li&gt;推论
&lt;ul&gt;
&lt;li&gt;根据规则2，表oRDERS是没有第一行、第二行或者是第三行之分的，由表中行组成的表的内容是集合的无序元素。用更抽象的数学术语来说，可以简单地表述为关系是元组的集合。&lt;/li&gt;
&lt;li&gt;规则2的另外一个含义是你无法建立一个指向行的指针以便以后可以再次检索它，这种指针是不允许的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;规则三&#34;&gt;规则三&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;概念&lt;br&gt;
行唯一性原则,关系模型的第三条规则要求关系中的任何两个元组（表中的行）的值在同一时刻不能是完全相同的。关系可以被看做是关系模型中的元组的集合，理所当然集合是不允许包含相同元素的，集合中的任意元组必须唯一。而且，由于纯关系查询语言只能通过它们的列值来区分行（规则2），这也说明了必定有另一个方法可以区分任何一行数据和其他的行的值，这样查询语言语句就可以唯---的检索出它来。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;键超键空值&#34;&gt;键,超键,空值&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;书中的&lt;br&gt;
超键(super key): 在关系中能唯一标识元组的属性集称为关系模式的超键&lt;br&gt;
候选键(candidate key): 有时也叫键,不含有多余属性的超键称为候选键。也就是在候选键中，若再删除属性，就不是超键了！&lt;br&gt;
主键(primary key): 用户选作元组标识的一个候选键程序主键&lt;br&gt;
外键(foreign key)：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。&lt;br&gt;
空值:未知的或尚未定义的,注意和0以及空字符串区别&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;理解&lt;br&gt;
学生信息（学号 身份证号 性别 年龄 身高 体重 宿舍号）和 宿舍信息（宿舍号 楼号）&lt;br&gt;
超键：只要含有“学号”或者“身份证号”两个属性的集合就叫超键，例如R1（学号 性别）、R2（身份证号 身高）、R3（学号 身份证号）等等都可以称为超键！&lt;br&gt;
候选键：不含有多余的属性的超键，比如（学号）、（身份证号）都是候选键，又比如R1中学号这一个属性就可以唯一标识元组了，而有没有性别这一属性对是否唯一标识元组没有任何的影响！&lt;br&gt;
主键：就是用户从很多候选键选出来的一个键就是主键，比如你要求学号是主键，那么身份证号就不可以是主键了！&lt;br&gt;
外键：宿舍号就是学生信息表的外键&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-关系代数&#34;&gt;3 关系代数&lt;/h2&gt;
&lt;h3 id=&#34;31-集合运算&#34;&gt;3.1 集合运算&lt;/h3&gt;
&lt;p&gt;兼容表:Head(S)=Head(R),且属性是从相同的域中选择并具有相同的属性&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;并,交,差&lt;/li&gt;
&lt;li&gt;赋值,别名
&lt;ol&gt;
&lt;li&gt;定义2.6.3 赋值、别名 R是一个表，Head（R）=A…A，。假定B，，…，B，是n个属性。对于所有的1≤i≤n，它们的域Domain（B，）=Domain（A，）。通过赋值S(B,,…,B,):=R(A,-,A)&lt;/li&gt;
&lt;li&gt;我们已经努力使得赋值运算允许对源表的标题里的属性名进行重定义，我们不久就可以体会到这一点的价值。现在我们需要指明，属性的重定义并不总是必要.如果两个表中所有的属性名都是一对一的，并且对于所有的1≤i≤n都有B，=A，成立，我们可以简单地称S为表R的别名，简写为S∶=R。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;乘积&lt;br&gt;
我们用W.A的形式来表示一个属性的名字（W是相乘表中的表名）．并称之为限定属性名，或限定属性。乘积表的标题由限定属性组成，并且当我们需要重点指出属性是从哪个表中取出来的时，可以用这些限定属性，因为在多个乘积表中同时出现相同的列名，有可能造成混乱。如果属性名只出现在一个表中，我们可以直接用它的非限定属性。&lt;br&gt;
&lt;strong&gt;两个1000行的表的乘积有100万行&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;32-自然关系运算&#34;&gt;3.2 自然关系运算&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;投影&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;删除某些列,再把重复的行去掉&lt;br&gt;
投影运算作用在一个表上，删除了表上的某些列，包括标题以及表内容上对应的列上的值。我们说把表投影到没有被删除的列的集合上。注意到表R上不同的行在投影到列的子集上后可能会相同，因为用于区别两个值的列已经被删除掉了。当发生这种情况的时候，投影运算符同样删除重复的行，只在结果集中留下重复行的一个拷贝。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;选择&lt;br&gt;
注意不要有内容依赖(就是按照自己知道的某个结果来根据其特征去查找,这不一定符合题目的要求)&lt;/li&gt;
&lt;li&gt;连接&lt;br&gt;
&lt;a href=&#34;https://imgtu.com/i/6hrhhn&#34;&gt;&lt;img src=&#34;https://s4.ax1x.com/2021/03/20/6hrhhn.png&#34; alt=&#34;6hrhhn.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
如果R和S具有相同的属性集,那么R连接S=R交S&lt;/li&gt;
&lt;li&gt;除法&lt;br&gt;
表T为R÷S（读作R除以S）的结果，如果Head（T）=A…A，并且T中包含的恰好是这样的行t∶对于S中每一个行s，t和s串接的结果的行可以在表R中找到。&lt;br&gt;
注意:R=TXS才能得到:T=R÷S&lt;br&gt;
一般强调查询所有的是用除法&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;33-优先级&#34;&gt;3.3 优先级&lt;/h3&gt;
&lt;p&gt;投影&amp;gt;选择&amp;gt;乘积&amp;gt;连接,除法&amp;gt;交&amp;gt;并,差&lt;/p&gt;
">数据库概念学习</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/shu-ju-ku-xue-xi/"" data-c="
          &lt;h2 id=&#34;1-基本概念&#34;&gt;1 基本概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;最终用户——交互式用户。
&lt;ul&gt;
&lt;li&gt;临时用户—用SQL访问DBMS的用户。&lt;/li&gt;
&lt;li&gt;初级用户——通过菜单访问DBMS的用户。·&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;应用程序员——编写菜单程序的程序员。&lt;/li&gt;
&lt;li&gt;数据库管理员——管理DBMS的专家。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;行列相关&#34;&gt;行列相关&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://imgtu.com/i/6ddAN6&#34;&gt;&lt;img src=&#34;https://s3.ax1x.com/2021/03/13/6ddAN6.png&#34; alt=&#34;6ddAN6.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://imgtu.com/i/6daWAP&#34;&gt;&lt;img src=&#34;https://s3.ax1x.com/2021/03/13/6daWAP.png&#34; alt=&#34;6daWAP.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;列:属性&lt;br&gt;
行:元组&lt;br&gt;
表:关系&lt;br&gt;
表的标题:关系模式,组成关系的属性的集合&lt;br&gt;
数据库:表/关系的集合&lt;br&gt;
数据库所有的关系模式的集合构成了数据库的模式&lt;br&gt;
表的行(元组)集合:表的内容;行数叫做表的基数&lt;/p&gt;
&lt;h3 id=&#34;域的概念&#34;&gt;域的概念&lt;/h3&gt;
&lt;p&gt;表T的属性A的取值范围集合D,D就叫做域&lt;/p&gt;
&lt;h2 id=&#34;2-关系规则&#34;&gt;2 关系规则&lt;/h2&gt;
&lt;h3 id=&#34;21-规则一第一范式&#34;&gt;2.1 规则一:第一范式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;概念&lt;br&gt;
规则1 第一范式规则 在定义的表中，关系模型坚持不允许含有多值属性（有时称为重复字段）和含有内部结构（比如记录类型）的列。遵守这样规则的表称为第一范式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要求&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这是不被允许的&lt;a href=&#34;https://imgtu.com/i/6dBSgS&#34;&gt;&lt;img src=&#34;https://s3.ax1x.com/2021/03/13/6dBSgS.png&#34; alt=&#34;6dBSgS.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;第一范式规则同时也要求任何列的值都必须是简单类型，不允许包含内部结构。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;规则二&#34;&gt;规则二&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;概念&lt;br&gt;
只能基于内容存取行规则&lt;br&gt;
但是存在RID,一般也不会用这个来查询&lt;/li&gt;
&lt;li&gt;推论
&lt;ul&gt;
&lt;li&gt;根据规则2，表oRDERS是没有第一行、第二行或者是第三行之分的，由表中行组成的表的内容是集合的无序元素。用更抽象的数学术语来说，可以简单地表述为关系是元组的集合。&lt;/li&gt;
&lt;li&gt;规则2的另外一个含义是你无法建立一个指向行的指针以便以后可以再次检索它，这种指针是不允许的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;规则三&#34;&gt;规则三&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;概念&lt;br&gt;
行唯一性原则,关系模型的第三条规则要求关系中的任何两个元组（表中的行）的值在同一时刻不能是完全相同的。关系可以被看做是关系模型中的元组的集合，理所当然集合是不允许包含相同元素的，集合中的任意元组必须唯一。而且，由于纯关系查询语言只能通过它们的列值来区分行（规则2），这也说明了必定有另一个方法可以区分任何一行数据和其他的行的值，这样查询语言语句就可以唯---的检索出它来。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;键超键空值&#34;&gt;键,超键,空值&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;书中的&lt;br&gt;
超键(super key): 在关系中能唯一标识元组的属性集称为关系模式的超键&lt;br&gt;
候选键(candidate key): 有时也叫键,不含有多余属性的超键称为候选键。也就是在候选键中，若再删除属性，就不是超键了！&lt;br&gt;
主键(primary key): 用户选作元组标识的一个候选键程序主键&lt;br&gt;
外键(foreign key)：如果关系模式R中属性K是其它模式的主键，那么k在模式R中称为外键。&lt;br&gt;
空值:未知的或尚未定义的,注意和0以及空字符串区别&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;理解&lt;br&gt;
学生信息（学号 身份证号 性别 年龄 身高 体重 宿舍号）和 宿舍信息（宿舍号 楼号）&lt;br&gt;
超键：只要含有“学号”或者“身份证号”两个属性的集合就叫超键，例如R1（学号 性别）、R2（身份证号 身高）、R3（学号 身份证号）等等都可以称为超键！&lt;br&gt;
候选键：不含有多余的属性的超键，比如（学号）、（身份证号）都是候选键，又比如R1中学号这一个属性就可以唯一标识元组了，而有没有性别这一属性对是否唯一标识元组没有任何的影响！&lt;br&gt;
主键：就是用户从很多候选键选出来的一个键就是主键，比如你要求学号是主键，那么身份证号就不可以是主键了！&lt;br&gt;
外键：宿舍号就是学生信息表的外键&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3-关系代数&#34;&gt;3 关系代数&lt;/h2&gt;
&lt;h3 id=&#34;31-集合运算&#34;&gt;3.1 集合运算&lt;/h3&gt;
&lt;p&gt;兼容表:Head(S)=Head(R),且属性是从相同的域中选择并具有相同的属性&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;并,交,差&lt;/li&gt;
&lt;li&gt;赋值,别名
&lt;ol&gt;
&lt;li&gt;定义2.6.3 赋值、别名 R是一个表，Head（R）=A…A，。假定B，，…，B，是n个属性。对于所有的1≤i≤n，它们的域Domain（B，）=Domain（A，）。通过赋值S(B,,…,B,):=R(A,-,A)&lt;/li&gt;
&lt;li&gt;我们已经努力使得赋值运算允许对源表的标题里的属性名进行重定义，我们不久就可以体会到这一点的价值。现在我们需要指明，属性的重定义并不总是必要.如果两个表中所有的属性名都是一对一的，并且对于所有的1≤i≤n都有B，=A，成立，我们可以简单地称S为表R的别名，简写为S∶=R。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;乘积&lt;br&gt;
我们用W.A的形式来表示一个属性的名字（W是相乘表中的表名）．并称之为限定属性名，或限定属性。乘积表的标题由限定属性组成，并且当我们需要重点指出属性是从哪个表中取出来的时，可以用这些限定属性，因为在多个乘积表中同时出现相同的列名，有可能造成混乱。如果属性名只出现在一个表中，我们可以直接用它的非限定属性。&lt;br&gt;
&lt;strong&gt;两个1000行的表的乘积有100万行&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;32-自然关系运算&#34;&gt;3.2 自然关系运算&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;投影&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;删除某些列,再把重复的行去掉&lt;br&gt;
投影运算作用在一个表上，删除了表上的某些列，包括标题以及表内容上对应的列上的值。我们说把表投影到没有被删除的列的集合上。注意到表R上不同的行在投影到列的子集上后可能会相同，因为用于区别两个值的列已经被删除掉了。当发生这种情况的时候，投影运算符同样删除重复的行，只在结果集中留下重复行的一个拷贝。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;选择&lt;br&gt;
注意不要有内容依赖(就是按照自己知道的某个结果来根据其特征去查找,这不一定符合题目的要求)&lt;/li&gt;
&lt;li&gt;连接&lt;br&gt;
&lt;a href=&#34;https://imgtu.com/i/6hrhhn&#34;&gt;&lt;img src=&#34;https://s4.ax1x.com/2021/03/20/6hrhhn.png&#34; alt=&#34;6hrhhn.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
如果R和S具有相同的属性集,那么R连接S=R交S&lt;/li&gt;
&lt;li&gt;除法&lt;br&gt;
表T为R÷S（读作R除以S）的结果，如果Head（T）=A…A，并且T中包含的恰好是这样的行t∶对于S中每一个行s，t和s串接的结果的行可以在表R中找到。&lt;br&gt;
注意:R=TXS才能得到:T=R÷S&lt;br&gt;
一般强调查询所有的是用除法&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;33-优先级&#34;&gt;3.3 优先级&lt;/h3&gt;
&lt;p&gt;投影&amp;gt;选择&amp;gt;乘积&amp;gt;连接,除法&amp;gt;交&amp;gt;并,差&lt;/p&gt;
">数据库学习</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/xiao-si-cuo-ti-ji-zhi-shi-dian-冲突-宋宇航_Win10/"" data-c="
          &lt;h2 id=&#34;肖四的一&#34;&gt;肖四的一&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;劳动是价值的唯一源泉,不是社会财富的唯一源泉&lt;/li&gt;
&lt;li&gt;可能和不可能是不能转换的&lt;/li&gt;
&lt;li&gt;评价标准归根到底是&lt;strong&gt;主体&lt;/strong&gt;的需要&lt;/li&gt;
&lt;li&gt;帝国主义实质:垄断资本凭借垄断地位获取高额垄断利润&lt;/li&gt;
&lt;li&gt;垄断并不能消除竞争反而加剧&lt;/li&gt;
&lt;li&gt;发展中的矛盾和问题集中体现在发展质量上&lt;/li&gt;
&lt;li&gt;海南自由贸易港:要把制度集成创新摆在突出位置&lt;/li&gt;
&lt;li&gt;脱贫攻坚:
&lt;ol&gt;
&lt;li&gt;根本:坚持党的领导,强化组织保证&lt;/li&gt;
&lt;li&gt;要义:坚持精准方略,提高脱贫实效&lt;/li&gt;
&lt;li&gt;保障:坚持加大投入,强化资金支持&lt;/li&gt;
&lt;li&gt;合力:坚持社会动员,凝聚各方力量&lt;/li&gt;
&lt;li&gt;要领:坚持从严要求,促进真抓实干&lt;/li&gt;
&lt;li&gt;基础:坚持群众主体,激发内生动力&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;全面依法治国的着力点:解决法治领域突出问题&lt;/li&gt;
&lt;li&gt;瓦窑堡都和抗日统一战线有关&lt;/li&gt;
&lt;li&gt;1937.2,致电国民党五届三中全会,提出停止内战一致对外等五项&lt;/li&gt;
&lt;li&gt;洛川:抗日救国十大纲领,全民族抗战&lt;/li&gt;
&lt;li&gt;1939.7,共产党:三大口号&lt;/li&gt;
&lt;li&gt;&amp;lt;&amp;lt;反对本本主义&amp;gt;&amp;gt;:表现了毛泽东开辟新道路,创造新理论的革命首创精神&lt;/li&gt;
&lt;li&gt;针对人民内部的矛盾
&lt;ol&gt;
&lt;li&gt;政治思想领域:实行团结-批评-团结的方针&lt;/li&gt;
&lt;li&gt;物质利益分配:实行统筹兼顾,适当安排&lt;/li&gt;
&lt;li&gt;科学文化:百花齐放百家争鸣&lt;/li&gt;
&lt;li&gt;共产党和民主党派:长期共存,互相监督&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;十四五期间经济社会发展的主题:推动高质量发展
&lt;ol&gt;
&lt;li&gt;主线:深化供给侧结构性改革&lt;/li&gt;
&lt;li&gt;根本目的:满足.....&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;习近平总书记的主张
&lt;ol&gt;
&lt;li&gt;需要什么样的联合国:主持公道,厉行法治,促进合作,聚焦行动&lt;/li&gt;
&lt;li&gt;二十国集团第十五次第一阶段会议:坚持多边主义,开放包容,互利合作,与时俱进&lt;/li&gt;
&lt;li&gt;亚太经合组织第二十七次非正会议:坚持开放包容,创新增长,互联互通,合作共赢&lt;/li&gt;
&lt;li&gt;第三届巴黎和平论坛:团结互助,共抗疫情.....&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;使用价值是价值的物质承担着,价值寓于使用价值之中&lt;/li&gt;
&lt;li&gt;价值是交换价值的基础,交换价值是价值的表现形式&lt;/li&gt;
&lt;li&gt;只要资本主义存在,经济危机就不能避免&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
">肖四错题及知识点</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/xiao-si-cuo-ti-ji-zhi-shi-dian/"" data-c="
          &lt;h2 id=&#34;肖四的一&#34;&gt;肖四的一&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;劳动是价值的唯一源泉,不是社会财富的唯一源泉&lt;/li&gt;
&lt;li&gt;可能和不可能是不能转换的&lt;/li&gt;
&lt;li&gt;评价标准归根到底是&lt;strong&gt;主体&lt;/strong&gt;的需要&lt;/li&gt;
&lt;li&gt;帝国主义实质:垄断资本凭借垄断地位获取高额垄断利润&lt;/li&gt;
&lt;li&gt;垄断并不能消除竞争反而加剧&lt;/li&gt;
&lt;li&gt;发展中的矛盾和问题集中体现在发展质量上&lt;/li&gt;
&lt;li&gt;海南自由贸易港:要把制度集成创新摆在突出位置&lt;/li&gt;
&lt;li&gt;脱贫攻坚:
&lt;ol&gt;
&lt;li&gt;根本:坚持党的领导,强化组织保证&lt;/li&gt;
&lt;li&gt;要义:坚持精准方略,提高脱贫实效&lt;/li&gt;
&lt;li&gt;保障:坚持加大投入,强化资金支持&lt;/li&gt;
&lt;li&gt;合力:坚持社会动员,凝聚各方力量&lt;/li&gt;
&lt;li&gt;要领:坚持从严要求,促进真抓实干&lt;/li&gt;
&lt;li&gt;基础:坚持群众主体,激发内生动力&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;全面依法治国的着力点:解决法治领域突出问题&lt;/li&gt;
&lt;li&gt;瓦窑堡都和抗日统一战线有关&lt;/li&gt;
&lt;li&gt;1937.2,致电国民党五届三中全会,提出停止内战一致对外等五项&lt;/li&gt;
&lt;li&gt;洛川:抗日救国十大纲领,全民族抗战&lt;/li&gt;
&lt;li&gt;1939.7,共产党:三大口号&lt;/li&gt;
&lt;li&gt;&amp;lt;&amp;lt;反对本本主义&amp;gt;&amp;gt;:表现了毛泽东开辟新道路,创造新理论的革命首创精神&lt;/li&gt;
&lt;li&gt;针对人民内部的矛盾
&lt;ol&gt;
&lt;li&gt;政治思想领域:实行团结-批评-团结的方针&lt;/li&gt;
&lt;li&gt;物质利益分配:实行统筹兼顾,适当安排&lt;/li&gt;
&lt;li&gt;科学文化:百花齐放百家争鸣&lt;/li&gt;
&lt;li&gt;共产党和民主党派:长期共存,互相监督&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;十四五期间经济社会发展的主题:推动高质量发展
&lt;ol&gt;
&lt;li&gt;主线:深化供给侧结构性改革&lt;/li&gt;
&lt;li&gt;根本目的:满足.....&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;习近平总书记的主张
&lt;ol&gt;
&lt;li&gt;需要什么样的联合国:主持公道,厉行法治,促进合作,聚焦行动&lt;/li&gt;
&lt;li&gt;二十国集团第十五次第一阶段会议:坚持多边主义,开放包容,互利合作,与时俱进&lt;/li&gt;
&lt;li&gt;亚太经合组织第二十七次非正会议:坚持开放包容,创新增长,互联互通,合作共赢&lt;/li&gt;
&lt;li&gt;第三届巴黎和平论坛:团结互助,共抗疫情.....&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;使用价值是价值的物质承担着,价值寓于使用价值之中&lt;/li&gt;
&lt;li&gt;价值是交换价值的基础,交换价值是价值的表现形式&lt;/li&gt;
&lt;li&gt;只要资本主义存在,经济危机就不能避免&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
">肖四错题及知识点</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/xiao-ba-cuo-ti-ji-zhi-shi-dian-zheng-li/"" data-c="
          &lt;ol&gt;
&lt;li&gt;开放型经济的首要之义是&lt;strong&gt;反对保护主义&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;战时共产主义的主要特征:余量收集制和取消商品货币关系&lt;/li&gt;
&lt;li&gt;鸦片走私并没有瓦解中国自给自足的自然经济,并且为中国资本主义的产生提供了某些客观条件&lt;/li&gt;
&lt;li&gt;根本政治制度在第一次人大54年确立,新型政党制度(中国共产党领导的...)49年9月第一届政协确立,国体(工人阶级领导的,以....)和国家结构形式(不是联邦制而是民族区域自治)是在新中国成立就确立的&lt;/li&gt;
&lt;li&gt;文化产业既有社会意识形态属性,又有市场属性,但社会意识形态属性是本质属性&lt;/li&gt;
&lt;li&gt;不同时期政权的性质
&lt;ol&gt;
&lt;li&gt;土地革命时期:工农民主专政&lt;/li&gt;
&lt;li&gt;抗日战争:抗日民族统一战线性质的政权:一切赞成反帝又赞成民主的人们的政权&lt;/li&gt;
&lt;li&gt;解放战争:各个革命阶级的联合专政&lt;/li&gt;
&lt;li&gt;新中国:人民民主专政&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;民法典最大的亮点之一:单设人格权编
&lt;ol&gt;
&lt;li&gt;民法典包括7编:总则编,物权编,合同编,人格权编,婚姻家庭编,继承编,侵权责任编&lt;/li&gt;
&lt;li&gt;特点:坚持民商合一,单设人格权编,不设独立额债券编,不设独立的知识产权编,单设侵权责任编&lt;/li&gt;
&lt;li&gt;人格权:生命权,身体权,健康权,姓名权,名称权,肖像权,名誉权,荣誉权,隐私权&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;俄罗斯第一个派遣防疫专家的&lt;/li&gt;
&lt;li&gt;认识是否具有真理性不在于是否得到所有人的认可,而是要看主观认识和客观实际是否相符合&lt;/li&gt;
&lt;li&gt;价值尺度必须以真理为前提,只有按照真理办事才能在实践中去的成功&lt;/li&gt;
&lt;li&gt;选举民主和协商民主都是我国民主的两种形式,没有首要和补充之分&lt;/li&gt;
&lt;li&gt;引进来和走出去是对外开放的基本途径&lt;/li&gt;
&lt;li&gt;增加就业是最有效最直接的脱贫方式,就业是民生之本,最大的民生&lt;/li&gt;
&lt;li&gt;收入分配是民生之源,是改善民生,实现发展成果由人民共享的最重要最直接的方法&lt;/li&gt;
&lt;li&gt;中共二大明确提出了反帝反封建的民主纲领,三大提出了统一战线&lt;/li&gt;
&lt;li&gt;世界观决定人生观,有什么样的人生观就有什么样的价值观&lt;/li&gt;
&lt;li&gt;民法典在法律体系中居于基础性地位,也是市场经济的基本法,是全面依法治国的重要制度载体&lt;/li&gt;
&lt;li&gt;工业化和农业集体化,苏联模式是在列宁逝世后&lt;/li&gt;
&lt;li&gt;五四运动.工人阶级才开始以独立的姿态登上历史舞台&lt;/li&gt;
&lt;li&gt;共产国际是在43年才解散的,是在整风运动之后&lt;/li&gt;
&lt;li&gt;志愿服务没有参与国家管理&lt;/li&gt;
&lt;li&gt;再分配领域是靠的政府&lt;/li&gt;
&lt;li&gt;国家安全的基石是人民安全&lt;/li&gt;
&lt;li&gt;西藏工作的着眼点和着力点是&lt;strong&gt;维护祖国统一,加强民族团结&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;感觉和心理是高级动物都有的但是意识是人所特有的&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;三&#34;&gt;三&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;国家安全的基石/宗旨是人民安全
&lt;ol&gt;
&lt;li&gt;国家利益至上(准则)&lt;/li&gt;
&lt;li&gt;政治安全根本&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;权利保障的根本环节是行政保护
&lt;ol&gt;
&lt;li&gt;宪法保障:前提和基础&lt;/li&gt;
&lt;li&gt;立法保障:重要条件&lt;/li&gt;
&lt;li&gt;行政保护:关键&lt;/li&gt;
&lt;li&gt;司法保障:最后防线&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;西藏工作:
&lt;ol&gt;
&lt;li&gt;着眼点和着力点:维护祖国统一,加强民族团结&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;新疆工作:
&lt;ol&gt;
&lt;li&gt;总目标:社会稳定和长治久安&lt;/li&gt;
&lt;li&gt;根本:凝聚人心&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;联合国宪章首要原则:大小国家互相尊重,一律平等&lt;/li&gt;
&lt;li&gt;联合国以和平为己任,发展为目标,公平为要义&lt;/li&gt;
&lt;li&gt;系统解决党的政治路线的问题的:&amp;lt;&amp;lt;论反对日本帝国主义的策略&amp;gt;&amp;gt;&lt;/li&gt;
&lt;li&gt;维护祖国统一和民族团结是加强爱国主义教育的着力点,主题是实现中华民族伟大复兴&lt;/li&gt;
&lt;li&gt;生民权是享有其他一切权利的前提,人身自由权是一切行动和生活的条件&lt;/li&gt;
&lt;li&gt;我国第一大贸易伙伴东盟(东亚十国)&lt;/li&gt;
&lt;li&gt;实践的主体和客体关系:实践关系(根本),认识关系,价值关系&lt;/li&gt;
&lt;li&gt;人人创造历史是错的,有积极的力量也有阻碍的,只有前者才创造历史&lt;/li&gt;
&lt;li&gt;西部大开发的新格局:大保护,大开放,高质量发展&lt;/li&gt;
&lt;li&gt;五四之后的新文化运动才是新民主主义的&lt;/li&gt;
&lt;li&gt;十月革命是1917,孙中山的联俄联共的是1924年国民党一大才有的&lt;/li&gt;
&lt;li&gt;民事主体从事民事活动应当遵循自愿原则,公平原则,诚信原则&lt;/li&gt;
&lt;li&gt;特区精神:敢闯敢试,埋头苦干,敢为人先&lt;/li&gt;
&lt;li&gt;水平分工取代垂直是以资本技术管理...跨国流动为前提的
&lt;ol&gt;
&lt;li&gt;以跨国界生产为核心&lt;/li&gt;
&lt;li&gt;全球化生产体系的形成和建立为标志&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;香港的政治体制是行政主导
&lt;ol&gt;
&lt;li&gt;概括为:三权分置,行政主导,司法独立,行政长官代表特别行政区向中央总负责&lt;/li&gt;
&lt;li&gt;复合制和单一制是国家结构形式,不是政治体制&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;五&#34;&gt;五&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;尊重科学，集中体现了中国人民求真务实、开拓创新的实践品格。&lt;/li&gt;
&lt;li&gt;反共限共溶共是国民党的,中国共产党明确提出的是坚持抗战,团结,进步,反对拖鞋分裂倒退&lt;/li&gt;
&lt;li&gt;全球治理观:共商共建共享&lt;/li&gt;
&lt;li&gt;社会治理格局:共建共治共享&lt;/li&gt;
&lt;li&gt;中国人民对帝国主义的认识
&lt;ol&gt;
&lt;li&gt;第一阶段:义和团等笼统的排外主义的斗争&lt;/li&gt;
&lt;li&gt;第二阶段:五四运动以后&lt;/li&gt;
&lt;li&gt;和辛亥革命没啥关系&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;实行最严格的生态环境保护制度是正确的&lt;/li&gt;
&lt;li&gt;打赢脱贫攻坚战是全面建成小康社会底线任务和标志性指标
&lt;ol&gt;
&lt;li&gt;两不愁三保障是脱贫的基本要求和核心指标&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;中国政府治理香港的法律依据是香港基本法和宪法
&lt;ol&gt;
&lt;li&gt;1984的联合声明是英国交还香港的过渡性文件(还是他在此期间怎么管理)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;市场主体是我国经济的力量载体&lt;/li&gt;
&lt;li&gt;共产主义是实现人类的解放,只有到那时人们才成为自然界的自觉的和真正的主人&lt;/li&gt;
&lt;li&gt;凡经过实践证明了的一切认识都是客观真理,都具有不可推翻的性质&lt;/li&gt;
&lt;li&gt;相对静止的两种状态:空间的相对位置暂时不变和事物的根本性质暂时不变&lt;/li&gt;
&lt;li&gt;56届慕尼黑安全会议主题:西方缺失,55届:倡导国际合作,维护多边主义&lt;/li&gt;
&lt;li&gt;75届联合国大会:&amp;quot;我们想要的未来,我们需要的联合国:重申我们对多边主义的集体承诺&lt;/li&gt;
&lt;li&gt;疫情防控斗争中,中国的理念:人类命运共同体&lt;/li&gt;
&lt;li&gt;守望相助,同舟共济是抗议斗争的中国精神之一&lt;/li&gt;
&lt;li&gt;社会主义法律和社会主义道德在性质作用和目标上的一致性决定了,...依法治国,以德治国相结合&lt;/li&gt;
&lt;li&gt;道德的功能:
&lt;ol&gt;
&lt;li&gt;调节功能:指道德通过评价等方式,指导和纠正...&lt;/li&gt;
&lt;li&gt;认识功能:指道德反应社会关系,特别是反应社会经济关系的功效与能力&lt;/li&gt;
&lt;li&gt;规范功能:在正确的善恶观下,规范社会成员.....&lt;/li&gt;
&lt;li&gt;还有导向,激励功能&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;新民主主义的5种经济:
&lt;ol&gt;
&lt;li&gt;社会主义经济&lt;/li&gt;
&lt;li&gt;国家资本主义:私人资本主义向国营经济过渡&lt;/li&gt;
&lt;li&gt;私人资本主义&lt;/li&gt;
&lt;li&gt;合作社经济:个体经济向社会主义集体经济过渡&lt;/li&gt;
&lt;li&gt;个体经济&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;三民主义:民族(驱除鞑虏,恢复中华),民权(创立民国),民生(平均地权),分别对应的革命:
&lt;ol&gt;
&lt;li&gt;民族革命&lt;/li&gt;
&lt;li&gt;政治革命&lt;/li&gt;
&lt;li&gt;社会革命&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;洋务运动
&lt;ol&gt;
&lt;li&gt;目标:自强求富&lt;/li&gt;
&lt;li&gt;指导思想:中学为体,西学为用&lt;/li&gt;
&lt;li&gt;师夷长技以制夷:魏源海国图志提出的&lt;/li&gt;
&lt;li&gt;振兴中华:孙中山提出的&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;党的政治建设的首要任务:保证全党服从中央,坚持党中央权威和集中统一领导&lt;/li&gt;
&lt;li&gt;平安是老百姓解决温饱后的第一需求&lt;/li&gt;
&lt;li&gt;九二共识是确保两岸关系和平发展的关键&lt;/li&gt;
&lt;li&gt;大团结大联合是统一战线永恒不变的主题
&lt;ol&gt;
&lt;li&gt;坚持一致性和多样性是统一战线的仿真&lt;/li&gt;
&lt;li&gt;争取人心,凝聚力量是统一战线工作的根本任务&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;坚持围绕中心,服务大局是人民政协履行职能的基本遵循&lt;/li&gt;
&lt;li&gt;时代和实践的不断发展是造成社会主义发展道路多样性的&lt;strong&gt;现实原因&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;垄断组织在经济生活中起决定作用&lt;/li&gt;
&lt;li&gt;真理的内容是客观的,形式是主观的&lt;/li&gt;
&lt;li&gt;实践是认识的基础和来源&lt;/li&gt;
&lt;li&gt;理念是行动的先导&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;六完jb蛋&#34;&gt;六(完jb蛋)&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;党领导立法,保证执法,支持司法,带头守法&lt;/li&gt;
&lt;li&gt;共产党的成立并没有改变时代主题,还是战争与革命&lt;/li&gt;
&lt;li&gt;改革开放是必由之路,重要法宝,关键一招&lt;/li&gt;
&lt;li&gt;全面建成小康社会是关键一步&lt;/li&gt;
&lt;li&gt;脱贫攻坚
&lt;ol&gt;
&lt;li&gt;第一次作为五年规划纲要的重要内容&lt;/li&gt;
&lt;li&gt;第一次由省区市党政一把手下军令状&lt;/li&gt;
&lt;li&gt;第一次把脱贫作为五年规划的约束性指标&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;共同富裕是南方谈话就提出了&lt;/li&gt;
&lt;li&gt;人民健康不是社会和谐之本&lt;/li&gt;
&lt;li&gt;民生是人民幸福之基,社会和谐之本&lt;/li&gt;
&lt;li&gt;金融资本是工业垄断资本和银行垄断资本融合在一起形成的一种垄断资本
&lt;ol&gt;
&lt;li&gt;形成的主要途径有金融联系,资本参与,人事参与&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;劳动创造价值不是马克思先提出的,英国古典政治经济学的劳动创造价值理论,亚当斯密已经认识到商品的二因素,劳动创造价值&lt;/li&gt;
&lt;li&gt;生产者是生产力中最活跃的因素,不是科技&lt;/li&gt;
&lt;li&gt;实践3种
&lt;ol&gt;
&lt;li&gt;物质生产实践:最基本&lt;/li&gt;
&lt;li&gt;社会政治实践&lt;/li&gt;
&lt;li&gt;科学文化是实践&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;抗美援朝胜利的根本原因是其正义性&lt;/li&gt;
&lt;li&gt;法制建设的指导方针:科学立法,严格执法,公正司法,全民守法&lt;/li&gt;
&lt;li&gt;革命道德的灵魂:坚持社会主义,共产主义理想和信念的不屈不挠的精神&lt;/li&gt;
&lt;li&gt;抗日战争:
&lt;ol&gt;
&lt;li&gt;决定性因素:民族精神&lt;/li&gt;
&lt;li&gt;关键:中国共产党的中流砥柱的作用&lt;/li&gt;
&lt;li&gt;重要法宝:全民族抗战&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;大革命推翻了北洋军阀的统治,但国民政府的统治依然是地主阶级和买办性质的大资产阶级的统治与北洋军阀的统治没有本质区别&lt;/li&gt;
&lt;li&gt;大革命的失败是指反帝反封的革命任务没有完成
&lt;ol&gt;
&lt;li&gt;失败的标志是国共合作全面破裂&lt;/li&gt;
&lt;li&gt;后果:工人农民运动转入低潮&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;最基本的民生是公共安全,&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;就业是最大的民生也是民生之本,&lt;/li&gt;
&lt;li&gt;收入分配是民生之源,是改善民生,实现发展成果由人民共享的最重要最直接的方式&lt;/li&gt;
&lt;li&gt;社会保障体系发挥兜底作用&lt;/li&gt;
&lt;li&gt;乡村振兴战略的
&lt;ol&gt;
&lt;li&gt;总目标(根本目的):农业农村现代化&lt;/li&gt;
&lt;li&gt;总方针:坚持农业农村优先发展&lt;/li&gt;
&lt;li&gt;总要求:产业兴旺,生态宜居,乡风文明,治理有效,生活富裕&lt;/li&gt;
&lt;li&gt;制度保障:建立健全城乡融合发展体制机制和政策体系&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;实现富国强军的统一
&lt;ol&gt;
&lt;li&gt;的重要途径是走军民融合式发展路子&lt;/li&gt;
&lt;li&gt;军政军民团结是重要政治保障,我军特有的政治优势&lt;/li&gt;
&lt;li&gt;国防动员是军民融合发展的重要纽带&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;我国国家治理体系能治理能力是中国特色社会主义制度及其执行能力的集中体现&lt;/li&gt;
&lt;li&gt;c:v(不变:可变)有机构成;m:v(剩余价值:可变);利润和剩余价值在量上是相等的&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;七&#34;&gt;七&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;物质是运动的承担着&lt;/li&gt;
&lt;li&gt;运动是物质的存在方式,并不是唯一属性&lt;/li&gt;
&lt;li&gt;反应和创造并不是人类认识的两种本质,而是同一本质的两种不同功能&lt;/li&gt;
&lt;li&gt;人的认识是反映性或摹写性与创造性的统一&lt;/li&gt;
&lt;li&gt;简单商品经济发展到资本主义商品经济的标志是劳动力成为商品&lt;/li&gt;
&lt;li&gt;商品经济的产生的历史条件:
&lt;ol&gt;
&lt;li&gt;社会分工的存在&lt;/li&gt;
&lt;li&gt;生产资料和劳动产品属于不同的所有者&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;新经济政策的主要特征是发展商品经济&lt;/li&gt;
&lt;li&gt;毛泽东思想开始形成的标志是在理论上阐述了中国革命的新道路&lt;/li&gt;
&lt;li&gt;新时代党的建设
&lt;ol&gt;
&lt;li&gt;总要求:坚持和加强党的全面领导,坚持党要管党,全面从严治党&lt;/li&gt;
&lt;li&gt;主线:加强党的长期执政能力建设先进性和纯洁性建设&lt;/li&gt;
&lt;li&gt;统领:政治建设&lt;/li&gt;
&lt;li&gt;着力点:调动全党的积极性,主动性,创造性&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;资本主义思想和封建主义的第一次交锋:维新派和守旧派的论战&lt;/li&gt;
&lt;li&gt;戊戌变法主张君主立宪,辛亥革命主张推翻君主专制,建立共和国;两者都没有提出明确的反帝反封建的纲领&lt;/li&gt;
&lt;li&gt;三三制:
&lt;ol&gt;
&lt;li&gt;非党的左派进步分子代表:小资产阶级&lt;/li&gt;
&lt;li&gt;共产党员代表:工人和农民&lt;/li&gt;
&lt;li&gt;不左不右的中间派包括:民族资产阶级和开明绅士&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;民主党派和中国共产党的新民主主义革命政纲基本相同(主张爱国反对卖国,主张民主,反对独裁),因此一直有不同程度的合作关系&lt;/li&gt;
&lt;li&gt;理想和现实的冲突属于应然和实然的矛盾&lt;/li&gt;
&lt;li&gt;科学家精神拍首位的是爱国精神&lt;/li&gt;
&lt;li&gt;今年是中俄科技创新年&lt;/li&gt;
&lt;li&gt;认识的过程
&lt;ol&gt;
&lt;li&gt;实践到认识&lt;/li&gt;
&lt;li&gt;认识到实践:更重要&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;自然主义历史观夸大了自然条件对社会的影响和制约,并没有认识到人类社会也反作用于自然界&lt;/li&gt;
&lt;li&gt;供求关系只能影响商品价格不能决定价值量&lt;/li&gt;
&lt;li&gt;虚拟经济越来越脱离实体经济&lt;/li&gt;
&lt;li&gt;两大历史任务主题,内容,实现方式都不一样&lt;/li&gt;
&lt;li&gt;基层自治:
&lt;ol&gt;
&lt;li&gt;自我管理&lt;/li&gt;
&lt;li&gt;自我服务&lt;/li&gt;
&lt;li&gt;自我教育&lt;/li&gt;
&lt;li&gt;自我监督&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;辛亥革命没有改变社会性质,没有改变中国人民的悲惨命运,没有完成历史任务&lt;/li&gt;
&lt;li&gt;五四运动是旧到新的转折&lt;/li&gt;
&lt;li&gt;护法运动的失败标志着旧民主主义革命的失败&lt;/li&gt;
&lt;li&gt;论持久战:
&lt;ol&gt;
&lt;li&gt;兵民是胜利之本&lt;/li&gt;
&lt;li&gt;预测战略防御,相持,反攻三个阶段&lt;/li&gt;
&lt;li&gt;批驳了亡国论和速战论&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;平等是社会主义法律的基本属性,社会主义法治的基本要求&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;八&#34;&gt;八&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;意识是客观世界的主观映像,其内容是客观的,形式是主观的,任何意识都是客观内容和主观形式的统一&lt;/li&gt;
&lt;/ol&gt;
">肖八错题及知识点整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/lao-shi-ji-bu-zhu-de-dan-ci-冲突-宋宇航_Win10/"" data-c="
          &lt;p&gt;subtle:微妙的,机智的&lt;br&gt;
hasten:加速&lt;br&gt;
moisture:水分&lt;br&gt;
vital:至关重要的,必不可少的&lt;br&gt;
diversity:多样性&lt;br&gt;
drought:干旱&lt;br&gt;
endeavor:努力,尽力,试图&lt;br&gt;
strike a balance:达成平衡&lt;br&gt;
sink:下沉&lt;/p&gt;
">老是记不住的单词</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/lao-shi-ji-bu-zhu-de-dan-ci/"" data-c="
          &lt;p&gt;subtle:微妙的,机智的&lt;br&gt;
hasten:加速&lt;br&gt;
moisture:水分&lt;br&gt;
vital:至关重要的,必不可少的&lt;br&gt;
diversity:多样性&lt;br&gt;
drought:干旱&lt;br&gt;
endeavor:努力,尽力,试图&lt;br&gt;
strike a balance:达成平衡&lt;br&gt;
sink:下沉&lt;/p&gt;
">老是记不住的单词</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/mao-zhong-te/"" data-c="
          &lt;h2 id=&#34;毛泽东思想&#34;&gt;毛泽东思想&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/DivndP&#34;&gt;&lt;img src=&#34;https://s3.ax1x.com/2020/11/15/DivndP.png&#34; alt=&#34;DivndP.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;注意区别几个作风:
&lt;ul&gt;
&lt;li&gt;三大作风:理论和实际相结合,和人民群众紧密的联系在一起,自我批评&lt;/li&gt;
&lt;li&gt;两个务必中的作风:务必....谦虚谨慎不骄不躁的作风,务必.....艰苦奋斗的作风&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;毛泽东思想不涉及改革,中特不涉及革命经验的总结&lt;/li&gt;
&lt;li&gt;两个革命能连起来的原因:民主革命中包含了社会主义的因素&lt;/li&gt;
&lt;li&gt;农民阶级,民族资产阶级,小资产阶级都是中间的&lt;/li&gt;
&lt;li&gt;&amp;lt;&amp;lt;中国革命和中国共产党&amp;gt;&amp;gt;与&amp;lt;&amp;lt;在晋绥干部会议上的讲话&amp;gt;&amp;gt;:
&lt;ul&gt;
&lt;li&gt;前者第一次提出新民主主义革命的概念和总路线的内容&lt;/li&gt;
&lt;li&gt;相同点:都是无产阶级领导的,都是人民大众的革命&lt;/li&gt;
&lt;li&gt;不同:前者只有反帝反封,后者反帝反封反官僚资本主义,后者还说是总路线,&lt;strong&gt;总政策&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;左倾:混淆新与社的界限(区别):毕其功于一役&lt;/li&gt;
&lt;li&gt;右倾:割裂了联系:二次革命论&lt;/li&gt;
&lt;li&gt;工人阶级对农民的领导是实现革命领导权的基础&lt;/li&gt;
&lt;li&gt;新民主主义革命的主要内容:没收封建地主阶级的土地归农民所有&lt;/li&gt;
&lt;li&gt;武装斗争是中国革命的特点和优点之一&lt;/li&gt;
&lt;li&gt;统一战线中必须坚持的原则:独立自主&lt;/li&gt;
&lt;li&gt;共产党人发刊词中的伟大工程是指建设全国范围的广大群众性的马克思主义政党&lt;/li&gt;
&lt;li&gt;对待同盟者只有两点:率领.....并取得胜利,给以物质福利....
&lt;ul&gt;
&lt;li&gt;发展进步势力,争取......这是抗日民族统一战线的总方针,不是无产阶级对同盟者领导的具备的条件&lt;/li&gt;
&lt;li&gt;有理有利有节是对顽固派的策略&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;完成遗留问题:土地改革&lt;/li&gt;
&lt;li&gt;向社会主义过渡:没收官僚资本,建立这会注意性质的国营经济;完成土改后的农村集市开展互助合作运动;在调整工商业的过程中,采取对私营工商业加工订货.....广泛发展成初级形式的国家资本主义&lt;/li&gt;
&lt;li&gt;毛主席分析我国农民的两大积极性:个体经济积极性,互助合作积极性&lt;/li&gt;
&lt;li&gt;新民主主义社会并不是独立的社会形态,是过渡性的,属于社会主义体系的,既有社会主义因素,又有非社会主义因素&lt;/li&gt;
&lt;li&gt;没收官僚资本的两重性:
&lt;ul&gt;
&lt;li&gt;反对帝国主义附庸--买办资产阶级:民主革命性质&lt;/li&gt;
&lt;li&gt;反对中国大资产阶级--社会主义革命的性质&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;过渡的两个思路
&lt;ul&gt;
&lt;li&gt;先搞工业化再一举渡过&lt;/li&gt;
&lt;li&gt;同时搞(注意一定没有先过渡再搞工业化)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;新中国的成立已经为过渡提供了政治上的基础,因此过渡需要相当长的一个时间并不因为政治上的,而是经济文化工商业等原因&lt;/li&gt;
&lt;li&gt;过渡的经验只有三条,没有兼顾国家个人集体的利益&lt;/li&gt;
&lt;li&gt;毛主席将社会主义划分为:不发达的和比较发达的&lt;/li&gt;
&lt;li&gt;第二次结合还没有完成,当时也并没有开始重新认识什么是社会主义该怎样建设社会主义&lt;/li&gt;
&lt;li&gt;&amp;lt;&amp;lt;论十大关系&amp;gt;&amp;gt;也提出了向外国学习的口号&lt;/li&gt;
&lt;li&gt;十二大:邓小平理论的主题形成:&lt;/li&gt;
&lt;li&gt;十三大:邓小平理论的轮廓形成&lt;/li&gt;
&lt;li&gt;发展是第一要务,人才是第一资源,创新是第一动力&lt;/li&gt;
&lt;li&gt;开放是国家繁荣发展的必由之路&lt;/li&gt;
&lt;li&gt;全面深化经济体制改革的重点是完善产权制度和要素市场配置&lt;/li&gt;
&lt;li&gt;目标一般比较宏观大的那种,XX现代化啊,XX工业化之类的&lt;/li&gt;
&lt;li&gt;方针一般实际一点,坚持XXX,要XXX\发展&lt;/li&gt;
&lt;li&gt;要求原则之类的都是四字啥的,很详细&lt;/li&gt;
&lt;li&gt;国有经济的主导作用体现在控制力上而不是量上(从三大改造那里也可以看出,不是最多的,但是起主导作用)&lt;/li&gt;
&lt;li&gt;人民政协不是国家机关,而是国家机构,不是民主党派和和社会团体的联合组织,是统一战线组织,是共产党领导,而不是政府领导,因此也就不向人大负责&lt;/li&gt;
&lt;li&gt;人民政协的工作主线:服务实现&amp;quot;两个一百年&amp;quot;奋斗目标&lt;/li&gt;
&lt;li&gt;我国是单一制国家,民族区域自治制度属于我国国家结构形式的制度&lt;/li&gt;
&lt;li&gt;统一战线的主题:大团结大联合&lt;/li&gt;
&lt;li&gt;人民政协的主题:团结民主&lt;/li&gt;
&lt;li&gt;收入分配是改善民生,实现发成果共享最重要最直接的方式&lt;/li&gt;
&lt;li&gt;国家安全的根本是政治安全,宗旨是人民安全,坚持国家利益至上&lt;/li&gt;
&lt;li&gt;在疫情中,中国始终秉持的理念是人类命运共同体&lt;/li&gt;
&lt;li&gt;公有制和非公有制都是我国经济发展的重要基础&lt;/li&gt;
&lt;li&gt;注意公有制和非公有制的实现形式,和公有制非公有制是不同的概念,公有制的实现形式是混合所有制&lt;/li&gt;
&lt;li&gt;非公有制1经济包括:个体经济,私营经济,外商独资经济&lt;/li&gt;
&lt;li&gt;社会主义公有制包括全民所有制和集体所有制&lt;/li&gt;
&lt;li&gt;中国特色社会主义政治发展道路不是西方的翻版也不是中国传统政治的再版,而是反复比较,长期探索,实践验证的原版&lt;/li&gt;
&lt;li&gt;经济发展攻关期的内容是转变发展方式,优化经济结构,转换增长动力&lt;/li&gt;
&lt;li&gt;创新驱动战略是现代化经济体系的战略支撑&lt;/li&gt;
&lt;li&gt;建设现代化经济体系是我国发展的战略目标&lt;/li&gt;
&lt;li&gt;保持土地经营权不变是错的,经营权是可以转的&lt;/li&gt;
&lt;li&gt;坚持九二共识就是承认九二共识的历史事实,认同两岸同属一个中国,没有别的选项就这俩对的&lt;/li&gt;
&lt;li&gt;社会主义核心价值观只关乎国家,社会,公民层面,没有政府&lt;/li&gt;
&lt;li&gt;上层建筑的核心是国家政权&lt;/li&gt;
&lt;li&gt;文化是观念上层建筑,说它完善政治上层建筑是错的&lt;/li&gt;
&lt;li&gt;生态文明属于历史范畴&lt;/li&gt;
&lt;li&gt;环保工作中,两个首位:预防为主......;利用自然力修复......&lt;/li&gt;
&lt;li&gt;法治国家是目标,法治社会是构建法治国家的基础,法治政府是主体&lt;/li&gt;
&lt;li&gt;建立严密的法治监督体系的重点是规范和约束公权力&lt;/li&gt;
&lt;li&gt;贸易战没有赢家,不是为了打赢贸易战&lt;/li&gt;
&lt;li&gt;国家治理体系和治理能力不是等同的,不是谁越好另一个就越好&lt;/li&gt;
&lt;li&gt;中国特色社会主义制度和国家治理体系与构建人类命运共同体无关&lt;/li&gt;
&lt;li&gt;权利运行制约和监督体系:要以规范和约束公权力为重点,做到有权必有责,用权受监督,违法必追究,就这仨记住了哈&lt;/li&gt;
&lt;li&gt;立法:科学立法,民主立法,依法立法&lt;/li&gt;
&lt;li&gt;勇于自我革命，从严管党治党，是我们党最鲜明的品格&lt;/li&gt;
&lt;li&gt;新时代强军目标:听党指挥,能打胜仗,作风优良&lt;/li&gt;
&lt;li&gt;中国共产党领导中国人民取得伟大胜利&lt;strong&gt;使具有五千多年文明历史的中华民族全面迈向现代化&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;没有伟大构想这一说法&lt;/li&gt;
&lt;li&gt;构建中国特色现代军事力量体系的重点是优化作战力量结构&lt;/li&gt;
&lt;li&gt;体现我军鲜明特色和政治优势的是作风优良&lt;/li&gt;
&lt;li&gt;外交政策的宗旨是维护世界和平,促进共同发展&lt;/li&gt;
&lt;li&gt;建立不忘初心牢记使命的制度是首位&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;党执政兴国的第一要务是发展&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;中国革命的xx问题&#34;&gt;中国革命的XX问题&lt;/h2&gt;
&lt;p&gt;首要问题:分清敌友&lt;br&gt;
基本问题:农民问题&lt;br&gt;
中心问题:无产阶级的领导权(也是新民主主义革命理论的核心问题)&lt;/p&gt;
">毛中特</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/zui-hou-yi-bu-fen-pai-xu/"" data-c="
          &lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;
&lt;p&gt;任意n个关键字基于比较的排序,至少要进行log&lt;sub&gt;2&lt;/sub&gt;[上取整(n!)]&lt;/p&gt;
&lt;h2 id=&#34;插入排序&#34;&gt;插入排序&lt;/h2&gt;
&lt;h3 id=&#34;直接插入排序&#34;&gt;直接插入排序&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void InsertSort(ElemType A[],int n)
{
    int i,j,temp;
    for(i=0;i&amp;lt;n;i++)
    {
        if(A[i]&amp;lt;A[i-1])
        {
            temp=A[i];
            for(j=i-1;j&amp;gt;=0&amp;amp;&amp;amp;A[j]&amp;gt;temp;j--)//后移
            {
                A[j+1]=A[j];
            }
            A[j+1]=temp;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;折半插入排序&#34;&gt;折半插入排序&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void InsertSort(ElemType A[],int n)
{
    int i,j,low,high;
    for(i=2;i&amp;lt;=n;i++)
    {
        A[0]=A[i];
        low=1;high=i-1;
        while(low&amp;lt;=high)
        {
            mid=(low+high)/2;
            if(A[mid]&amp;gt;A[0]) high=mid-1;//中间元素更大,说明要往左边再找
            else low=mid+1;//包括了等于,保证稳定性,因为如果等于,还是往右边找,就可以保证顺序不变
        }
        for(j=i-1;j&amp;gt;=low;j--)//也即为high+1开始,因为high=low-1是结束的标志
        {
            A[j+1]=A[j];
        }
        A[low]=A[0];//其实j+1也对

    }

}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;shell-排序&#34;&gt;shell 排序&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void ShellSort(ElemType A[],int n)
{
    int i,j,dk;
    for(dk=n/2;dk&amp;gt;=1;dk=dk/2)
    {
        for(i=1+dk;i&amp;lt;=n;i++)//轮流切换分组处理,类似于进程切换,但在画图写的时候,咱是分好组之后,在每组内使用直接插入排序,但是代码中是一个接一个的使用组内插入排序的,实际上也是一样的
        {
            if(A[i]&amp;lt;A[i-dk])
            {
                A[0]=A[i]
                for(j=i-dk;j&amp;gt;0;j-=dk)
                {
                    A[j+dk]=A[j];
                }
                A[j+dk]=A[0];
            }

        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;交换排序&#34;&gt;交换排序&lt;/h2&gt;
&lt;h3 id=&#34;冒泡排序&#34;&gt;冒泡排序&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void BubbleSort(ElemType A[],int n)
{
    int i,j;
    bool flag;
    for(i=0;i&amp;lt;n-1;i++)
    {
        flag=false;
        for(j=n-1;j&amp;gt;i;j--)
        {
            if(A[j-1]&amp;gt;A[j])
            {
                swap(A[j-1],A[j]);
                flag=true;
            }
        }
        if(flag==false)
        return;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;快速排序&#34;&gt;快速排序&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BvQZAs&#34;&gt;&lt;img src=&#34;https://s3.ax1x.com/2020/11/11/BvQZAs.png&#34; alt=&#34;BvQZAs.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;递归实现&#34;&gt;递归实现&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#define ElemType int
int MyPartition(ElemType A[],int low,int high);
void QuickSort(ElemType A[],int low,int high)
{
    if(low&amp;lt;high)
    {
        int pivotpos;
        pivotpos=MyPartition(A,low,high);
        QuickSort(A,low,pivotpos-1);
        QuickSort(A,pivotpos+1,high);
    }

}
int MyPartition(ElemType A[],int low,int high)
{
    ElemType pivot=A[low];
    while(low&amp;lt;high)
    {
        while(low&amp;lt;high&amp;amp;&amp;amp;A[high]&amp;gt;=pivot) high--;
        A[low]=A[high];
        while(low&amp;lt;high&amp;amp;&amp;amp;A[low]&amp;lt;=pivot) low++;
        A[high]=A[low];
    }
    A[low]=pivot;
    return low;
}
int AnotherPartition(ElemType A[],int low,int high)
{
    ElemType pivot=A[low];
    int i=low;
    for(int j=low+1;j&amp;lt;=high;j++)
    {
        if(A[j]&amp;lt;pivot)
            swap(A[++i],A[j]);
    }
    swap(A[i],A[low]);
    return i;
}
int main()
{
	int A[10]={23,54,1,33,58,11,67,24,5,8};
   /* 我的第一个 C 程序 */
    int i=0;
	QuickSort(A,0,9);
	i=0;
	printf(&amp;quot;ssss\n&amp;quot;);
	while(i&amp;lt;=9)
	{
		printf(&amp;quot;%d\n&amp;quot;,A[i]);
		i++;
	}
   printf(&amp;quot;Hello, World! \n&amp;quot;);

   return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;利用交换思想解决问题&#34;&gt;利用交换思想解决问题&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;荷兰旗&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
int swap(int *a,int *b)
{
	int temp=*a;
	*a=*b;
	*b=temp;
	return 0;
}
void Classify(int a[],int n)
{
	int i=0,j=0,k=n-1;
	while(j&amp;lt;=k)
	{
		switch(a[j]){
			case 0:swap(&amp;amp;a[j],&amp;amp;a[i]);j++;i++;break;
			case 1:j++;break;
			case 2:swap(&amp;amp;a[j],&amp;amp;a[k]);k--;break;
		}
	}
	
}
int main()
{
	int a[15]={1,2,1,2,0,1,0,2,0,1,0,0,2,2,1};
	Classify(a,15);
	int i=0;
	while(i&amp;lt;15){
		printf(&amp;quot;%d  &amp;quot;,a[i]);
		i++;
	}
   return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;选择排序&#34;&gt;选择排序&lt;/h2&gt;
&lt;h3 id=&#34;简单选择排序&#34;&gt;简单选择排序&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void SimpleSelectSort(ElemType A[],int n)
{
    int i,j,min;
    for(i=0;i&amp;lt;n-1;i++)
    {
        min=i;
        for(j=i+1;j&amp;lt;n;j++)
        {
            if(A[j]&amp;lt;A[min])
            {
                min=j;
            }
        }
        if(min!=i) swap(A[i],A[min]);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;堆排序&#34;&gt;堆排序&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;void BuildMaxHeap(ElemType A[],int len)
{
    for(int i=len/2;i&amp;gt;0;i--)
    {
        HeadAdjust(A,i,len);
    }
}
void HeapAdjust(ElemType A[],int k,int ken)
{
    A[0]=A[k];
    for(i=2*k;i&amp;lt;=len;i*=2)
    {
        if(i&amp;lt;len&amp;amp;&amp;amp;A[i]&amp;lt;A[i+1])//i&amp;lt;len:保证有右兄弟,后面的是是否比右兄弟小
            i++;
        if(A[0]&amp;gt;=A[i])//比孩子结点大,直接退了
        {
            break;
        }
        else
        {
            A[k]=A[i];
            k=i;//转到孩子结点继续判断
        }
    }
    A[k]=A[0];
}
void HeapSort(ElemType A[],int len)
{
    BuildHeapMax(A,len);
    for(int i=len;i&amp;gt;1;i--)
    {
        swap(A[i],A[1]);
        HeapAdjust(A,1,i-1);//由于最后一个元素就是最大元素了,故只调整前面的
    }
}
&lt;/code&gt;&lt;/pre&gt;
">最后一部分 排序</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/zheng-zhi-zhi-shi-dian-shi-gang/"" data-c="
          &lt;h2 id=&#34;土地政策&#34;&gt;土地政策&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;天朝田亩制度:太平天国&lt;/li&gt;
&lt;li&gt;平均地权:孙中山的民生主义,但是没地的还是没地,只是保证地价不涨&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;宪法的发展&#34;&gt;宪法的发展&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;1908年,清末新政的&amp;lt;&amp;lt;钦定宪法大纲&amp;gt;&amp;gt;&lt;/li&gt;
&lt;li&gt;中华民国临时约法&lt;a href=&#34;https://imgchr.com/i/BTP5e1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/11/08/BTP5e1.png&#34; alt=&#34;BTP5e1.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
##知识点&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;中国长期以来是一个统一的大国&lt;/strong&gt;这句话是对的&lt;/li&gt;
&lt;li&gt;师夷长技以制夷不是甲午战争之后的口号,睁眼看世界是鸦片战争之后提出的&lt;/li&gt;
&lt;li&gt;鸦片战争过后,中国社会性质发生质的变化是变成&lt;strong&gt;半殖民地半封建制国家&lt;/strong&gt;,不是说的主要矛盾和主要任务&lt;/li&gt;
&lt;li&gt;在中国工人阶级比资产阶级更早出现,因为外国来开的厂&lt;/li&gt;
&lt;li&gt;鸦片战争使中国的社会性质,主要矛盾,革命任务,阶级及阶级关系都发生了变化&lt;/li&gt;
&lt;li&gt;涉港的条约有:南京条约,北京条约,拓展香港界址专条&lt;/li&gt;
&lt;li&gt;盛世危言中不是共和制,应该是君民共主&lt;/li&gt;
&lt;li&gt;太平天国运动是一场反帝反封建的运动,尽管他的纲领中并没有明确提出提出反帝,他的任务是,结果也是&lt;/li&gt;
&lt;li&gt;甲午战争的失败
&lt;ul&gt;
&lt;li&gt;标志着列强瓜分中国达到高潮&lt;/li&gt;
&lt;li&gt;标志着中华民族普遍意识的觉醒&lt;/li&gt;
&lt;li&gt;标志着洋务运动的失败&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;维新运动才是资产阶级第一次与封建主义的交锋&lt;/li&gt;
&lt;li&gt;采取官督商办的也都是资本主义性质的&lt;/li&gt;
&lt;li&gt;决定洋务运动必然失败的原因是指导思想是&amp;quot;中学为体,西学为用&amp;quot;(因为还是没学制度,只是为了巩固封建统治)&lt;/li&gt;
&lt;li&gt;维新运动的论战只是维新派和守旧派的,不涉及革命&lt;/li&gt;
&lt;li&gt;维新运动不敢否定封建主义,政治上不敢根本否定封建君主制度,经纪上,未触及封建主义的经济基础-封建土地所有制,思想上仍借助孔子的旗号&lt;/li&gt;
&lt;li&gt;维新派是鼓吹民权的&lt;/li&gt;
&lt;li&gt;兴中会是第一个革命团体,同盟会是第一个革命政党&lt;/li&gt;
&lt;li&gt;非中共失败的根本原因都是阶级局限性&lt;/li&gt;
&lt;li&gt;中共失败的根本原因是不能把马克思主义与中国实际相结合,成功原因就是能相结合&lt;/li&gt;
&lt;li&gt;辛亥革命失败的客观根本原因是资本主义建国方案行不通,主观根本原因是阶级局限性,但没强调就选阶级局限性原因如上&lt;/li&gt;
&lt;li&gt;同盟会成立时的政治纲领是驱除鞑虏,恢复中华,创立民国,平均地权,三民主义只是孙中山概括的&lt;/li&gt;
&lt;li&gt;兴中会是二十世纪前的,那几个是在二十世纪初传播过程中才成立的&lt;/li&gt;
&lt;li&gt;辛亥革命不是统治者自上而下的改良道路&lt;/li&gt;
&lt;li&gt;戊戌变法是改革君主专制,辛亥革命是完全推翻,注意程度&lt;/li&gt;
&lt;li&gt;平均地权没有触及封建土地所有制&lt;/li&gt;
&lt;li&gt;民族主义是要结束清政府的专制统治及其媚外政策&lt;/li&gt;
&lt;li&gt;辛亥革命开创了完全意义上的近代民族民主革命是对的,说资产阶级革命更好&lt;/li&gt;
&lt;li&gt;说五四运动前(或者说是背景),马克思主义广泛传播是错的&lt;/li&gt;
&lt;li&gt;国民大革命的失败主要是指反帝反封建的革命任务没有完成,而国共合作全面破裂标志着其失败&lt;/li&gt;
&lt;li&gt;民主革命的主力军是农民,工人阶级是新民主主义革命的领导阶级&lt;/li&gt;
&lt;li&gt;五四运动以前的新文化运动是资产阶级民主主义的&lt;/li&gt;
&lt;li&gt;五四运动以前的民主:资产阶级民主主义的制度,资产阶级民主主义的思想&lt;/li&gt;
&lt;li&gt;五四运动以后的(接受马克思主义之后):多数人的民主,以劳动群众为主体的民主&lt;/li&gt;
&lt;li&gt;把改造国民性置于优先地位是五四前的文化运动干的&lt;/li&gt;
&lt;li&gt;中国共产党的诞生才是开天辟地的大事件,五四运动只是重要意义的大事件&lt;/li&gt;
&lt;li&gt;中国共产党的初心和使命只管得了咱自己,不包括为世界谋和平,为人类谋发展&lt;/li&gt;
&lt;li&gt;诞生之初没找到革命道路,也没有把党的工作重心放到农村&lt;/li&gt;
&lt;li&gt;遵义会议之后毛主席还不算完全的老大,张闻天代替博古&lt;strong&gt;负总的责任&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;抗日战争取得最后胜利的最关键的阶段是&lt;strong&gt;战略相持阶段&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;和顽固派的斗争:有理,有利,有节&lt;/li&gt;
&lt;li&gt;经验,教条主义是思想路线的,冒险,投降注意是政治路线的&lt;/li&gt;
&lt;li&gt;三大作风:理论和实际相结合,和人民群众紧密的联系在一起,自我批评&lt;/li&gt;
&lt;li&gt;1956之前涉及社会主义的一定要小心,那时候还没确立&lt;/li&gt;
&lt;li&gt;中国人民政治协商会议第一届全体会议和46年在重庆的那个的区别是中国共产党处于领导地位,通过的纲领是新民主主义的,不是社会主义的&lt;/li&gt;
&lt;li&gt;毛主席提出两个务必,原因主要是中国共产党即将成为执政党&lt;/li&gt;
&lt;li&gt;蒋介石邀请毛主席重庆谈判,
&lt;ul&gt;
&lt;li&gt;原因在于全国人民强烈要求和平,反对内战,国民党军队大都在西南西北..完成内战部署要相当的时间,国际希望中国和平建国&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的不可能包括&lt;/strong&gt;满足全国人民强烈要求和平的愿望,建立....&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;46.6-47.6是战略防御阶段&lt;/li&gt;
&lt;li&gt;必须实行全国军事总动员,全国人民的总动员是1937洛川会议的,是为了抗日的&lt;/li&gt;
&lt;li&gt;指出必须打败蒋,能打败蒋的时候还没进入战略进攻&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
">政治知识点 史纲</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/zheng-zhi-zhi-shi-dian-si-xiu-bu-fen/"" data-c="
          &lt;ul&gt;
&lt;li&gt;爱国主义不是永恒的
&lt;ul&gt;
&lt;li&gt;会随着国家的概念的消亡而消亡&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;爱社会主义不能算作爱国主义的内涵
&lt;ul&gt;
&lt;li&gt;内涵就那四个:大好河山,骨肉同胞,灿烂文化,自己的国家&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;要把国家安全,荣誉,利益放在高于一切的地位&lt;/li&gt;
&lt;li&gt;文化是培养民族心理,民族个性,民族精神的摇篮&lt;/li&gt;
&lt;li&gt;凡事说到啥理论根本特性的时候一般都是人民性,因为我们都是基于马克思主义原理的,其最鲜明的特点就是人民性&lt;/li&gt;
&lt;li&gt;在整个上层建筑中,政治上层建筑&lt;/li&gt;
&lt;li&gt;社会主义核心价值观把涉及国家,社会,公民的价值要求融为一体,社会主义核心价值体系没有&lt;/li&gt;
&lt;li&gt;社会主义核心价值观体现了社会主义意识形态的本质要求&lt;/li&gt;
&lt;li&gt;社会主义核心价值观&lt;strong&gt;没有普适性&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;先进性:&lt;/li&gt;
&lt;li&gt;人民性:根本特性&lt;/li&gt;
&lt;li&gt;真实性:不要看到提到人民就是人民性,关键在于看有没有说到不是用来做摆设的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;家庭美德的基本规范&lt;strong&gt;没有同甘共苦&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;道德的产生归源于社会经济关系&lt;/li&gt;
&lt;li&gt;道德&lt;strong&gt;在本质上是知行合一的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在阶级社会中,道德是调节阶级矛盾和对立阶级之间开展阶级斗争的重要工具
&lt;ul&gt;
&lt;li&gt;占统治地位的是统治阶级的道德&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;革命道德的灵魂是坚持社会主义,共产主义理想和信念的不屈不挠的精神
&lt;ul&gt;
&lt;li&gt;红线是为人民服务&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;推进新时代公民道德建设的出发点和落脚点是培养担当民族复兴大任的时代新人&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在社会主义道德建设中具有基础性作用的是&lt;strong&gt;个人品德&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意:道德一经产生就&lt;strong&gt;具有相对独立性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;社会主义道德
&lt;ul&gt;
&lt;li&gt;核心:为人民服务&lt;/li&gt;
&lt;li&gt;原则:集体主义&lt;/li&gt;
&lt;li&gt;重点:诚实守信&lt;/li&gt;
&lt;li&gt;基本要求:社会主义荣辱观&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有序的公共生活&lt;strong&gt;不是推动社会发展额重要动力&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;只有实现中华民族的伟大复兴的中国梦,家庭梦才能成真&lt;/li&gt;
&lt;li&gt;恋爱的道德规范没有尊重对方爹妈&lt;/li&gt;
&lt;li&gt;守法就是遵守宪法和法律&lt;/li&gt;
&lt;li&gt;诉讼程序和非诉讼程序中都有调解,&lt;strong&gt;诉讼内的是司法调解&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;公正司法是维护贡品争议的最后一道防线&lt;/li&gt;
&lt;li&gt;注意生命健康权和人身自由权
&lt;ul&gt;
&lt;li&gt;生命权是人享有其他各项权利的前提&lt;/li&gt;
&lt;li&gt;人身自由是人们一切行动和生活的条件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;国家强制力量并不是保护法律实施的唯一力量,因此法律的每一个实施过程并非都需要借助于国家的强制力&lt;/li&gt;
&lt;li&gt;中国特色社会主义法律体系
&lt;ul&gt;
&lt;li&gt;统帅:宪法&lt;/li&gt;
&lt;li&gt;主干:法律&lt;/li&gt;
&lt;li&gt;重要组成部分:行政法规,地方性法规&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;决定法律本质.....的根本因素是生产方式&lt;/li&gt;
&lt;li&gt;平等是社会主义法律的基本属性&lt;/li&gt;
&lt;li&gt;守法是法律实施和实现的基本途径&lt;/li&gt;
&lt;li&gt;关于依法治国
&lt;ul&gt;
&lt;li&gt;党的领导是依法治国的根本保障&lt;/li&gt;
&lt;li&gt;建设法治国家是全面依法治国的总目标&lt;/li&gt;
&lt;li&gt;实现人民幸福,尊重和保障人权是全面依法治国的根本目的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;几个法的基本原则
&lt;ul&gt;
&lt;li&gt;民法:民事主体地位平等,自愿,公平,诚信,公序良俗,有利于节约资源,保护生态环境&lt;/li&gt;
&lt;li&gt;商法:除民法的基本原则外,交易自由,等价有偿,边界安全&lt;/li&gt;
&lt;li&gt;行政法:职权法定,程序法定,公正公平,有效监督&lt;/li&gt;
&lt;li&gt;社会法:公平和谐,国家适度干预&lt;/li&gt;
&lt;li&gt;刑法:罪刑法定,法律面前人人平等,罪刑相适应&lt;/li&gt;
&lt;li&gt;仲裁法:自愿,仲裁独立,一裁终局&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;法律执行又叫行政执法,原则:合法性,合理性,信赖保护,效率&lt;/li&gt;
&lt;li&gt;民族区域自治制度,特别行政区制度是&lt;strong&gt;我国国家结构形式的政治制度&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;科学立法的目标:完善以宪法为核心的中国特色社会主义法律体系&lt;/li&gt;
&lt;li&gt;严格执法:深入推进依法行政,加快建设法治政府&lt;/li&gt;
&lt;li&gt;公正司法:要保证公正司法,提高司法公信力....&lt;/li&gt;
&lt;li&gt;全民守法:增强全民法治观念,推进法治社会建设&lt;/li&gt;
&lt;li&gt;公正是法治的生命线,是司法活动最高的价值追求&lt;/li&gt;
&lt;li&gt;坚持党的领导,人民当家作主,依法治国有机统一起来是我国社会主义法制建设的一条基本经验&lt;/li&gt;
&lt;li&gt;全面依法治国的基本格局是严格执法,不能是保证执法,而坚持党的领导,体现在党的保证执法即可&lt;/li&gt;
&lt;li&gt;权利保障包括&lt;strong&gt;宪法保障(前提和基础),立法保障(重要条件),行政保护(关键环节),司法保障(最后防线)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;法律责任:民事责任,行政责任,刑事责任&lt;/li&gt;
&lt;/ul&gt;
">政治知识点 思修部分</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/b-shu/"" data-c="
          &lt;pre&gt;&lt;code&gt;struct node{
    ElementType keys[m-1];
    struct node* child[m];
    int num;//关键字数量
}
&lt;/code&gt;&lt;/pre&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/Bwd1qx&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/11/01/Bwd1qx.png&#34; alt=&#34;Bwd1qx.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BwxJ7d&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/11/01/BwxJ7d.png&#34; alt=&#34;BwxJ7d.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;插入元素引起分裂,不一定会长高,只要他父结点还可以容纳&lt;/li&gt;
&lt;li&gt;说一个树是5阶的,并不要求里面一定得有个有4个关键字的结点,切记&lt;/li&gt;
&lt;li&gt;B+树支持顺序查找,B树不支持,但两个都支持随机查找&lt;/li&gt;
&lt;li&gt;都可以用于文件索引和数据库索引,但B+更适合,因为读写磁盘效率更高&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BD7NRS&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/11/02/BD7NRS.png&#34; alt=&#34;BD7NRS.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;p&gt;**注意:**线性探测查找失败不是按照表的元素个数啥的求,比如模7,就看0~6上的元素,即使后面还有,也不算了,就算前面的,0开始,到空为算,看几个,然后1开始到空为算...但是到后面如果一直连着超过了6,也是得算上个数,直到空&lt;br&gt;
另外,空算一次&lt;/p&gt;
">B树和散列表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-qi-zhang-cha-zhao-de-cuo-ti-ji-zhi-shi-dian/"" data-c="
          &lt;h2 id=&#34;判定树&#34;&gt;判定树&lt;/h2&gt;
&lt;p&gt;向下取整,则每次右子树比左子树多1或0个&lt;br&gt;
反之,就是左比右多1或0&lt;/p&gt;
">第七章 查找的错题及知识点</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/tu-de-cuo-ti-ji-zhi-shi-dian/"" data-c="
          &lt;ol&gt;
&lt;li&gt;Dijkstra算法除了不适合求带负权值的,其他都可以&lt;/li&gt;
&lt;li&gt;最短路径一定是简单路径
&lt;ol&gt;
&lt;li&gt;顶点不重复出现的是简单路径&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Floyd算法的,当最短路径修改后,path&lt;sub&gt;k-1&lt;/sub&gt;不一定是path&lt;sub&gt;k&lt;/sub&gt;的子集&lt;/li&gt;
&lt;li&gt;可以判断一个有向图是否有环的:DFS,拓扑排序,求关键路径&lt;/li&gt;
&lt;li&gt;拓扑排序并不要求是否连通,因此若一个有向图的顶点不能排在一个拓扑序列中,则可判定该有向图&lt;strong&gt;含有顶点数目大于1的强连通分量&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一个有向图具有&lt;strong&gt;有序&lt;/strong&gt;的拓扑排序序列,则它的邻接矩阵必&lt;strong&gt;三角&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;若&lt;strong&gt;没有有序&lt;/strong&gt;,则为一般&lt;/li&gt;
&lt;li&gt;如果邻接矩阵是三角,则必定有拓扑序列,即有环&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;最小生成树的边不一定比未选的边小&lt;a href=&#34;https://imgchr.com/i/BeX9TU&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/25/BeX9TU.png&#34; alt=&#34;BeX9TU.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;DAG的拓扑序列唯一并不能唯一确定该图&lt;a href=&#34;https://imgchr.com/i/BeXn0K&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/25/BeXn0K.png&#34; alt=&#34;BeXn0K.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;求关键路径是以拓扑排序为基础的&lt;/li&gt;
&lt;li&gt;破圈法是正确的&lt;a href=&#34;https://imgchr.com/i/Bex3p4&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/25/Bex3p4.png&#34; alt=&#34;Bex3p4.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
">图的错题及知识点</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/cao-zuo-xi-tong-di-wu-zhang-cuo-ti-ji-zhi-shi-dian-zheng-li/"" data-c="
          &lt;ol&gt;
&lt;li&gt;共享设备是指在一段时间内允许多个进程同时访问的设备,并不是同一时刻&lt;/li&gt;
&lt;li&gt;设备控制器通常需要提供&lt;strong&gt;控制寄存器,状态寄存器,控制命令&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;没有I/O地址寄存器这种东西&lt;/li&gt;
&lt;li&gt;中断寄存器在CPU内&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;字节多路通道&lt;/strong&gt;用作连接大量的低速或中速I/O设备&lt;/li&gt;
&lt;li&gt;设备分配一般不考虑设备的及时性,需要考虑的有:
&lt;ol&gt;
&lt;li&gt;设备的固有属性&lt;/li&gt;
&lt;li&gt;设备独立性&lt;/li&gt;
&lt;li&gt;安全性&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;设备的绝对号:区分设备的代号&lt;/li&gt;
&lt;li&gt;通道控制器控制设备控制器,设备控制器控制设备工作&lt;/li&gt;
&lt;li&gt;首先获得硬件信息的是中断处理程序,它处于最底层&lt;/li&gt;
&lt;li&gt;将系统调用参数翻译成设备操作命令的工作由&lt;strong&gt;设备无关的操作系统软件实现&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;用户层软件向上提供了库函数,实际使用了系统调用来实现库函数&lt;/li&gt;
&lt;li&gt;设备独立软件向上提供了系统调用,也就是他实现了系统调用,故而参数啥的都是在它里面翻译&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;若I/O所花费的时间比CPU处理时间短的多,则缓冲区几乎无效&lt;/li&gt;
&lt;li&gt;磁盘到缓冲区时间:T1;缓冲区到用用户区:T2;CPU处理:T3
&lt;ol&gt;
&lt;li&gt;单缓冲:max(T1,T3)+T2&lt;/li&gt;
&lt;li&gt;双缓冲:max(T1,T2+T3)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;缓冲区管理首先要考虑的是&lt;strong&gt;实现进程访问缓冲区的互斥&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;提高单机资源利用率的关键技术是多道程序设计技术&lt;/li&gt;
&lt;li&gt;SPOOLing系统由预输入程序,井管理程序,缓输出技术构成&lt;/li&gt;
&lt;/ol&gt;
">操作系统 第五章 错题及知识点整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/cao-zuo-xi-tong-di-wu-zhang-io-she-bei-guan-li/"" data-c="
          &lt;h2 id=&#34;io管理概述&#34;&gt;I/O管理概述&lt;/h2&gt;
&lt;h3 id=&#34;io设备&#34;&gt;I/O设备&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BkInjs&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BkInjs.png&#34; alt=&#34;BkInjs.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;分类&#34;&gt;分类&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BkI84U&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BkI84U.png&#34; alt=&#34;BkI84U.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BkIdD1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BkIdD1.md.png&#34; alt=&#34;BkIdD1.md.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BkIBE6&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BkIBE6.png&#34; alt=&#34;BkIBE6.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BkIgvd&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BkIgvd.png&#34; alt=&#34;BkIgvd.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h3 id=&#34;io控制器&#34;&gt;I/O控制器&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BkoPxJ&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BkoPxJ.png&#34; alt=&#34;BkoPxJ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BkoBss&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BkoBss.png&#34; alt=&#34;BkoBss.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BkogiT&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BkogiT.png&#34; alt=&#34;BkogiT.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BkoXSe&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BkoXSe.png&#34; alt=&#34;BkoXSe.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/Bkovyd&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/Bkovyd.png&#34; alt=&#34;Bkovyd.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h3 id=&#34;io控制方式&#34;&gt;I/O控制方式&lt;/h3&gt;
&lt;h4 id=&#34;程序直接控制方式轮询&#34;&gt;程序直接控制方式(轮询)&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BkLlQS&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BkLlQS.png&#34; alt=&#34;BkLlQS.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;数据准备好,放到数据寄存器才会修改状态寄存器,CPU一查到就读取数据&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BkL7TA&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BkL7TA.png&#34; alt=&#34;BkL7TA.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;p&gt;为什么会往存储器里放?&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BkOSmQ&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BkOSmQ.png&#34; alt=&#34;BkOSmQ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BkOZXF&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BkOZXF.png&#34; alt=&#34;BkOZXF.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;中断驱动方式&#34;&gt;中断驱动方式&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BkON0H&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BkON0H.png&#34; alt=&#34;BkON0H.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;p&gt;##注意:##每次中断只能读入一个字的数据&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BkOqHJ&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BkOqHJ.png&#34; alt=&#34;BkOqHJ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;dma方式direct-memory-access直接存储器存取&#34;&gt;DMA方式(Direct Memory Access:直接存储器存取)&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BkXDa9&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BkXDa9.png&#34; alt=&#34;BkXDa9.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h5 id=&#34;dma寄存器&#34;&gt;DMA寄存器&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/Bkj9Gq&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/Bkj9Gq.png&#34; alt=&#34;Bkj9Gq.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;DMA控制器也是一次读一个字然后放到内存中的,存够一批&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BkxHR1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BkxHR1.png&#34; alt=&#34;BkxHR1.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;读入的块或者在内存存放的块必须是连续的(因为它要求是一批连续的),如果想要读非连续的或者非连续的存放必须要多个I/O指令,一次是不行的&lt;/li&gt;
&lt;li&gt;一个DMA控制器只对应一台设备与内存传递数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;通道控制方式&#34;&gt;通道控制方式&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/Bkz1yV&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/Bkz1yV.png&#34; alt=&#34;Bkz1yV.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;通道执行的指令很单一,且和CPU共享内存&lt;/li&gt;
&lt;li&gt;通道程序相当于任务清单,由一系列通道指令构成&lt;/li&gt;
&lt;li&gt;一个通道控制多个I/O控制器,一个I/O控制器控制多个I/O设备,也就是一个通道可以控制多台设备与内存交换数据&lt;/li&gt;
&lt;/ul&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/Bkz6Te&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/Bkz6Te.png&#34; alt=&#34;Bkz6Te.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;小结&#34;&gt;小结&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/Bkz2Yd&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/Bkz2Yd.png&#34; alt=&#34;Bkz2Yd.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h3 id=&#34;io系统层次&#34;&gt;I/O系统层次&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BAmEI1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BAmEI1.png&#34; alt=&#34;BAmEI1.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;用户层io软件&#34;&gt;用户层I/O软件&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BAm8II&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BAm8II.png&#34; alt=&#34;BAm8II.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;设备独立性软件&#34;&gt;设备独立性软件&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;向上层提供统一的调用接口(如write/read系统调用)&lt;/li&gt;
&lt;li&gt;设备保护&lt;/li&gt;
&lt;li&gt;差错处理&lt;/li&gt;
&lt;li&gt;设备分配与回收&lt;/li&gt;
&lt;li&gt;数据缓冲区管理&lt;/li&gt;
&lt;li&gt;建立逻辑设备名到物理设备名的映射关系,根据设备类型调用相应的设备驱动程序&lt;br&gt;
&lt;strong&gt;设备独立性也叫设备无关性&lt;/strong&gt;&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BAmXOe&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BAmXOe.png&#34; alt=&#34;BAmXOe.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
类似于单级目录和两级目录&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;设备驱动程序&#34;&gt;设备驱动程序&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://imgchr.com/i/BAn5jS&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BAn5jS.png&#34; alt=&#34;BAn5jS.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
驱动程序一般以一个独立进程的方式存在&lt;/p&gt;
&lt;h4 id=&#34;中断处理程序&#34;&gt;中断处理程序&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BAumuD&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BAumuD.png&#34; alt=&#34;BAumuD.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;硬件设备&#34;&gt;硬件设备&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;电子部件(设备控制器/适配器)&lt;/li&gt;
&lt;li&gt;机械部件(本身)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;小结-2&#34;&gt;小结&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BAuJv8&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BAuJv8.png&#34; alt=&#34;BAuJv8.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h2 id=&#34;io核心子系统&#34;&gt;I/O核心子系统&lt;/h2&gt;
&lt;h3 id=&#34;io调度与设备保护&#34;&gt;I/O调度与设备保护&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BA0eHA&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BA0eHA.png&#34; alt=&#34;BA0eHA.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BA03jg&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BA03jg.png&#34; alt=&#34;BA03jg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h3 id=&#34;spooling技术假脱机技术&#34;&gt;SPOOLing技术(假脱机技术)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BECYLt&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BECYLt.png&#34; alt=&#34;BECYLt.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://imgchr.com/i/BABF5q&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BABF5q.png&#34; alt=&#34;BABF5q.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://imgchr.com/i/BE93D0&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BE93D0.png&#34; alt=&#34;BE93D0.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://imgchr.com/i/BE9t5F&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BE9t5F.png&#34; alt=&#34;BE9t5F.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://imgchr.com/i/BE9S4e&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BE9S4e.png&#34; alt=&#34;BE9S4e.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://imgchr.com/i/BE9DDx&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BE9DDx.png&#34; alt=&#34;BE9DDx.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;利用spooling技术将独占设备改造成共享式设备&#34;&gt;利用SPOOLing技术将独占设备改造成共享式设备&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BEC9aT&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEC9aT.png&#34; alt=&#34;BEC9aT.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;34&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BECnZ6&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BECnZ6.png&#34; alt=&#34;BECnZ6.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;35&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BEC3zd&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEC3zd.png&#34; alt=&#34;BEC3zd.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h3 id=&#34;设备的分配与回收&#34;&gt;设备的分配与回收&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;36&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BEEpZR&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEEpZR.png&#34; alt=&#34;BEEpZR.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;37&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BECISJ&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BECISJ.png&#34; alt=&#34;BECISJ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;38&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BEC7O1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEC7O1.png&#34; alt=&#34;BEC7O1.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;设备分配的数据结构&#34;&gt;设备分配的数据结构&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://imgchr.com/i/BEkbge&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEkbge.png&#34; alt=&#34;BEkbge.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BEAZEq&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEAZEq.png&#34; alt=&#34;BEAZEq.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BEAuCT&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEAuCT.png&#34; alt=&#34;BEAuCT.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BEAQv4&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEAQv4.png&#34; alt=&#34;BEAQv4.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;分配过程&#34;&gt;分配过程&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://imgchr.com/i/BEAa8O&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEAa8O.png&#34; alt=&#34;BEAa8O.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BEADrd&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEADrd.png&#34; alt=&#34;BEADrd.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BEArqA&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEArqA.png&#34; alt=&#34;BEArqA.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
##改进##&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BEA7aq&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEA7aq.png&#34; alt=&#34;BEA7aq.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BEALGT&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEALGT.png&#34; alt=&#34;BEALGT.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;高速缓存与缓冲区&#34;&gt;高速缓存与缓冲区&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;39&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BEEq0A&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEEq0A.png&#34; alt=&#34;BEEq0A.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;40&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BEEzp8&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEEzp8.png&#34; alt=&#34;BEEzp8.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;单缓冲区&#34;&gt;单缓冲区&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;41&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BEV2jg&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEV2jg.png&#34; alt=&#34;BEV2jg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;p&gt;解题技巧:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://imgchr.com/i/BEZd2T&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEZd2T.png&#34; alt=&#34;BEZd2T.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://imgchr.com/i/BEZTZd&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEZTZd.png&#34; alt=&#34;BEZTZd.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;44&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BEepZj&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEepZj.png&#34; alt=&#34;BEepZj.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;双缓冲区&#34;&gt;双缓冲区&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://imgchr.com/i/BEelJx&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEelJx.png&#34; alt=&#34;BEelJx.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://imgchr.com/i/BEegmQ&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEegmQ.png&#34; alt=&#34;BEegmQ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;结论:采用双缓冲策略,处理一个数据块的平均耗时为Max(T,C+M)&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;区别&#34;&gt;区别&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://imgchr.com/i/BEmEtI&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEmEtI.png&#34; alt=&#34;BEmEtI.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BEmMng&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEmMng.png&#34; alt=&#34;BEmMng.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;循环缓冲区&#34;&gt;循环缓冲区&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;47&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BEms41&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEms41.png&#34; alt=&#34;BEms41.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;缓冲池&#34;&gt;缓冲池&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;48&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BEnkKU&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEnkKU.png&#34; alt=&#34;BEnkKU.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;小结-3&#34;&gt;小结&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;49&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BEnuP1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BEnuP1.png&#34; alt=&#34;BEnuP1.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
">操作系统 第五章 I/O设备管理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/cao-zuo-xi-tong-di-si-zhang-wen-jian-guan-li-cuo-ti-ji-zhi-shi-dian-zheng-li/"" data-c="
          &lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;OS引入文件系统的目的是&lt;strong&gt;实现对文件的按名存取&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;文件的逻辑结构是为了方便&lt;strong&gt;用户&lt;/strong&gt;而设计的
&lt;ol&gt;
&lt;li&gt;即逻辑结构是取决于用户的&lt;/li&gt;
&lt;li&gt;物理结构是取决于存储介质特性,操作系统管理方式的&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;关于索引文件
&lt;ol&gt;
&lt;li&gt;索引文件=索引表+逻辑文件(实际存储的记录数据)&lt;/li&gt;
&lt;li&gt;每条记录在索引表中对应的索引项是唯一的&lt;/li&gt;
&lt;li&gt;索引表中的索引项只含每条记录的长度和在逻辑文件中的位置&lt;/li&gt;
&lt;li&gt;建立索引提高了存储代价&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;读文件不在内存中也是产生缺页中断&lt;/li&gt;
&lt;li&gt;在open之后的操作用的都是文件描述符,并不需要文件名&lt;/li&gt;
&lt;li&gt;文件目录项(也就是FCB是不包括文件控制块(即FCB)的物理地址的&lt;/li&gt;
&lt;li&gt;UNIX操作系统中,文件的索引结构放在索引结点中&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://imgchr.com/i/BCMTxg&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/21/BCMTxg.png&#34; alt=&#34;BCMTxg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;符号链接的时候,引用计数值是直接复制原文件的&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://imgchr.com/i/BCQUSS&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/21/BCQUSS.png&#34; alt=&#34;BCQUSS.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;系统级安全管理包括登录和注册&lt;/li&gt;
&lt;li&gt;访问控制机制必须由系统实现,加密如由系统实现,则不易扩展&lt;/li&gt;
&lt;li&gt;对一个文件的访问,常由&lt;strong&gt;用户访问权限和文件属性&lt;/strong&gt;共同限制&lt;/li&gt;
&lt;li&gt;访问控制列表:规定了每个用户名及其所允许的访问类型(规定了权限)&lt;/li&gt;
&lt;li&gt;FCB包含基本信息,存取控制信息,使用信息
&lt;ol&gt;
&lt;li&gt;存取控制信息就是文件的存取权限,所谓权限也就是哪种用户可以对文件干什么(读,写,删等)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;防止文件受损用的是&lt;strong&gt;备份的方法&lt;/strong&gt;来保护,&lt;strong&gt;存取控制矩阵&lt;/strong&gt;是用于多用户之间的存取权限保护&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关于为什么m个用户,n个类型的访问权限的情况下,描述文件权限的位数至少是 mn&lt;/strong&gt;:
&lt;ol&gt;
&lt;li&gt;这个是对文件权限的描述,也就是他&lt;strong&gt;同时&lt;/strong&gt;代表了哪些人可以干啥,比如11110111101011(瞎写的)代表了用户a有1,2,3权限,b......&lt;/li&gt;
&lt;li&gt;为啥不是logm+logn:11代表a,10代表b之类的,因为这样你一个描述,不知道谁可以干什么,只知道某一个人可以干啥,我一个用户访问这个文件,看到权限描述的是某个人能干啥,就不知道我可以干啥&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;一个文件放在磁带上连续存储,放在磁盘上非连续存储&lt;/li&gt;
&lt;li&gt;用户优先级与是否具有访问权限是无关的&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;OS还可通过FAT(文件分配表)来对文件存储空间管理,切记切记&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;目录的顺序检索完成后,得到的是逻辑地址&lt;/li&gt;
&lt;li&gt;绝大多数OS以簇为单位进行空间分配&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://imgchr.com/i/Bkg2GR&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/Bkg2GR.png&#34; alt=&#34;Bkg2GR.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;a href=&#34;https://imgchr.com/i/BkgRR1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/23/BkgRR1.png&#34; alt=&#34;BkgRR1.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
">操作系统 第四章 文件管理错题及知识点整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-si-zhang-wen-jian-guan-li/"" data-c="
          &lt;h2 id=&#34;1-文件系统基础&#34;&gt;1 文件系统基础&lt;/h2&gt;
&lt;h3 id=&#34;文件的概念&#34;&gt;文件的概念&lt;/h3&gt;
&lt;p&gt;文件是以计算机硬盘为载体的存储在计算机上的信息集合&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据项&lt;/li&gt;
&lt;li&gt;记录&lt;/li&gt;
&lt;li&gt;文件&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;文件的属性&#34;&gt;文件的属性&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/Bpa2M6&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/20/Bpa2M6.png&#34; alt=&#34;Bpa2M6.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BpaxoQ&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/20/BpaxoQ.png&#34; alt=&#34;BpaxoQ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;文件的基本操作&#34;&gt;文件的基本操作&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BFDWp8&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFDWp8.png&#34; alt=&#34;BFDWp8.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BFr6u4&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFr6u4.png&#34; alt=&#34;BFr6u4.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;打开文件&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BFrtBj&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFrtBj.png&#34; alt=&#34;BFrtBj.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;创建文件&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BFDjcF&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFDjcF.png&#34; alt=&#34;BFDjcF.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;写文件&lt;/li&gt;
&lt;li&gt;读文件&lt;/li&gt;
&lt;li&gt;文件重定位(文件寻址)&lt;/li&gt;
&lt;li&gt;删除文件&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BFrVje&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFrVje.png&#34; alt=&#34;BFrVje.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;截断文件&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;文件的打开与关闭&#34;&gt;文件的打开与关闭&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;打开并不是我们平常操作的那样打开(如点开一个txt文件),而是将文件的信息从外存添加到内存的打开文件表的一个表目中,我们平常所说的打开其实还经历了读取这一步骤&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;文件的逻辑结构&#34;&gt;文件的逻辑结构&lt;/h3&gt;
&lt;h4 id=&#34;顺序文件&#34;&gt;顺序文件&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BpD8gA&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/20/BpD8gA.png&#34; alt=&#34;BpD8gA.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;p&gt;又分为定长和可变长&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BpDD3j&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/20/BpDD3j.png&#34; alt=&#34;BpDD3j.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BprYRJ&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/20/BprYRJ.png&#34; alt=&#34;BprYRJ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/Bpshc9&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/20/Bpshc9.png&#34; alt=&#34;Bpshc9.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;链式存储怎样都无法实现随机存取(无论是定长还是非定长)&lt;/li&gt;
&lt;li&gt;定长文件如果顺序存储是可以随机存取的&lt;/li&gt;
&lt;li&gt;如果采用串结构,无法快速找到某关键字对应的记录,但是如果是顺序结构,可以根据关键字快速找到对应记录(折半查找)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;索引文件&#34;&gt;索引文件&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BpcdpD&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/20/BpcdpD.png&#34; alt=&#34;BpcdpD.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;索引顺序文件&#34;&gt;索引顺序文件&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/B9U8QP&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/21/B9U8QP.png&#34; alt=&#34;B9U8QP.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;p&gt;还是嫌多就多级的&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/B9UTOK&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/21/B9UTOK.png&#34; alt=&#34;B9UTOK.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
不是浪费了很多空间么?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里说顺序文件就是指物理上顺序的文件&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&#34;直接文件或散列文件hash-file&#34;&gt;直接文件或散列文件(Hash File)&lt;/h4&gt;
&lt;h3 id=&#34;文件目录&#34;&gt;文件目录&lt;/h3&gt;
&lt;h4 id=&#34;文件控制块&#34;&gt;文件控制块&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/B9arhd&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/21/B9arhd.png&#34; alt=&#34;B9arhd.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/B9d93R&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/21/B9d93R.png&#34; alt=&#34;B9d93R.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;单级文件目录&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/B9dNCj&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/21/B9dNCj.png&#34; alt=&#34;B9dNCj.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两级&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/B9dDbT&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/21/B9dDbT.png&#34; alt=&#34;B9dDbT.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多级&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/B9dbPH&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/21/B9dbPH.png&#34; alt=&#34;B9dbPH.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/B9djMt&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/21/B9djMt.png&#34; alt=&#34;B9djMt.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;缺点:树形目录不便于实现文件的共享(易考查)&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;无环图目录结构&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/B9wyOP&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/21/B9wyOP.png&#34; alt=&#34;B9wyOP.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意文件共享和拷贝的区别:&lt;/strong&gt;&lt;br&gt;
文件的拷贝,就是副本了,并不会指向同一个,一个修改了,另一个不会修改&lt;br&gt;
文件的共享,一个用户修改了,另一个看到的也改了,但是一个人删除了,只是这个用户的指向文件的共享链删除,另一个用户还是能看到这个文件(硬链接)&lt;/p&gt;
&lt;h4 id=&#34;索引结点fcb的改进&#34;&gt;索引结点(FCB的改进)&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/B9rfH0&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/21/B9rfH0.png&#34; alt=&#34;B9rfH0.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/B9s1rn&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/21/B9s1rn.png&#34; alt=&#34;B9s1rn.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;文件的共享&#34;&gt;文件的共享&lt;/h4&gt;
&lt;p&gt;硬链接:基于文件索引结点的共享方式&lt;br&gt;
软链接:利用符号链实现文件共享&lt;br&gt;
区别:&lt;br&gt;
硬链接,某个删除源文件后,另一个用户还可以看到,并不会真的删掉,只是要删除用户的不再指向这个索引结点&lt;br&gt;
软链接,文件拥有者删除源文件后,就真删了,就像windows下的快捷方式,如果源文件删了,快捷方式就失效了.缺点是删了之后,又创建了一个文件名一样的文件,那么软链接的那个就会访问这个,导致出错&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BFgMSx&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFgMSx.png&#34; alt=&#34;BFgMSx.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;文件保护&#34;&gt;文件保护&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BFcAIA&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFcAIA.png&#34; alt=&#34;BFcAIA.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;小结&#34;&gt;小结&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/B9s2GD&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/21/B9s2GD.png&#34; alt=&#34;B9s2GD.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h2 id=&#34;文件系统的实现&#34;&gt;文件系统的实现&lt;/h2&gt;
&lt;h3 id=&#34;文件系统层次结构&#34;&gt;文件系统层次结构&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BF6vP1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BF6vP1.png&#34; alt=&#34;BF6vP1.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h3 id=&#34;文件分配方式&#34;&gt;文件分配方式&lt;/h3&gt;
&lt;h4 id=&#34;连续分配&#34;&gt;连续分配&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;优点:&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BimW3F&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BimW3F.png&#34; alt=&#34;BimW3F.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BimIBR&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BimIBR.png&#34; alt=&#34;BimIBR.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;缺点:&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BimXge&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BimXge.png&#34; alt=&#34;BimXge.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;19&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BimzDA&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BimzDA.png&#34; alt=&#34;BimzDA.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;总结:&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;20&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/Bin9Et&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/Bin9Et.png&#34; alt=&#34;Bin9Et.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;链接分配&#34;&gt;链接分配&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;考试中只说链接分配是指隐式链接&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;隐式链接&#34;&gt;隐式链接&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;21&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BinYr9&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BinYr9.png&#34; alt=&#34;BinYr9.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;22&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/Bin6rd&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/Bin6rd.png&#34; alt=&#34;Bin6rd.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h5 id=&#34;显式链接&#34;&gt;显式链接&lt;/h5&gt;
&lt;p&gt;文件分配表(FAT):整个磁盘只有一个&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;23&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BiuQeA&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BiuQeA.png&#34; alt=&#34;BiuQeA.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;24&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/Biu8FP&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/Biu8FP.png&#34; alt=&#34;Biu8FP.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;索引分配&#34;&gt;索引分配&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;25&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BiuhwR&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BiuhwR.png&#34; alt=&#34;BiuhwR.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;26&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BiKE0s&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BiKE0s.png&#34; alt=&#34;BiKE0s.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h5 id=&#34;链接方案&#34;&gt;链接方案&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;27&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BiKIBj&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BiKIBj.png&#34; alt=&#34;BiKIBj.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h5 id=&#34;多层索引&#34;&gt;多层索引&lt;/h5&gt;
&lt;p&gt;&lt;a href=&#34;https://imgchr.com/i/BiM328&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BiM328.png&#34; alt=&#34;BiM328.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
&lt;strong&gt;求最大文件,访问几次&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&#34;混合索引&#34;&gt;混合索引&lt;/h5&gt;
&lt;p&gt;&lt;a href=&#34;https://imgchr.com/i/BiM6r4&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BiM6r4.png&#34; alt=&#34;BiM6r4.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
直接地址读两次,一级读三次,二级读四次&lt;/p&gt;
&lt;h5 id=&#34;小结-2&#34;&gt;小结&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;28&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BiMRaR&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BiMRaR.png&#34; alt=&#34;BiMRaR.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;小结-3&#34;&gt;小结&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;29&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BiMhPx&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BiMhPx.png&#34; alt=&#34;BiMhPx.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h3 id=&#34;文件存储空间管理&#34;&gt;文件存储空间管理&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;30&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/Bi8V74&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/Bi8V74.png&#34; alt=&#34;Bi8V74.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;存储空间的划分与初始化&#34;&gt;存储空间的划分与初始化&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;31&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/Bi8rDS&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/Bi8rDS.png&#34; alt=&#34;Bi8rDS.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;空闲表法&#34;&gt;空闲表法&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;32&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/Bi8b59&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/Bi8b59.png&#34; alt=&#34;Bi8b59.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;空闲链表法&#34;&gt;空闲链表法&lt;/h4&gt;
&lt;p&gt;盘块:就是物理块,一块一块的&lt;br&gt;
盘区:相邻的空闲盘块组成一个区&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BiG4JA&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BiG4JA.png&#34; alt=&#34;BiG4JA.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&#34;空闲盘块链&#34;&gt;空闲盘块链&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;33&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BiJ8FH&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BiJ8FH.png&#34; alt=&#34;BiJ8FH.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h5 id=&#34;空闲盘区链&#34;&gt;空闲盘区链&lt;/h5&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;34&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BiJTh9&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BiJTh9.png&#34; alt=&#34;BiJTh9.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;位示图法&#34;&gt;位示图法&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;35&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BiY7VS&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BiY7VS.png&#34; alt=&#34;BiY7VS.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;36&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BitSbT&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BitSbT.png&#34; alt=&#34;BitSbT.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;成组链接法&#34;&gt;成组链接法&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;37&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/Bi4MG9&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/Bi4MG9.png&#34; alt=&#34;Bi4MG9.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/smartab/article/details/81285353&#34;&gt;csdn这篇讲的不错&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;逻辑结构vs物理结构&#34;&gt;逻辑结构VS物理结构&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;38&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/Bi3q6f&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/Bi3q6f.png&#34; alt=&#34;Bi3q6f.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h2 id=&#34;磁盘组织与管理&#34;&gt;磁盘组织与管理&lt;/h2&gt;
&lt;h3 id=&#34;磁盘结构&#34;&gt;磁盘结构&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;39&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BF2EgP&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BF2EgP.png&#34; alt=&#34;BF2EgP.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;40&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BF2sv6&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BF2sv6.png&#34; alt=&#34;BF2sv6.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;41&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BF2X5j&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BF2X5j.png&#34; alt=&#34;BF2X5j.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;42&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BFRPqU&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFRPqU.png&#34; alt=&#34;BFRPqU.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;p&gt;注意可换盘磁盘和固定盘磁盘&lt;/p&gt;
&lt;p&gt;小结:&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BFR3IH&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFR3IH.png&#34; alt=&#34;BFR3IH.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;磁盘调度算法&#34;&gt;磁盘调度算法&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;43&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BFHQ1g&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFHQ1g.png&#34; alt=&#34;BFHQ1g.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;fcfs&#34;&gt;FCFS&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;44&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BFbPU0&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFbPU0.png&#34; alt=&#34;BFbPU0.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;sstf虽短寻找时间优先算法&#34;&gt;SSTF(虽短寻找时间优先算法)&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;45&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BFbMUx&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFbMUx.png&#34; alt=&#34;BFbMUx.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;扫描scan算法电梯调度算法&#34;&gt;扫描(SCAN)算法(电梯调度算法)&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;46&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BFqUlF&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFqUlF.png&#34; alt=&#34;BFqUlF.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;look调度算法&#34;&gt;LOOK调度算法&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;47&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BFLVB9&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFLVB9.png&#34; alt=&#34;BFLVB9.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;循环扫描算法c-scan&#34;&gt;循环扫描算法(C-SCAN)&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;48&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BFLjgO&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFLjgO.png&#34; alt=&#34;BFLjgO.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;c-look算法&#34;&gt;C-LOOK算法&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;49&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BFLHER&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFLHER.png&#34; alt=&#34;BFLHER.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;小结-4&#34;&gt;小结&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;50&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BFOPUI&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFOPUI.png&#34; alt=&#34;BFOPUI.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;p&gt;如果题目只说scan就是look&lt;br&gt;
只说c-scan就是c-look&lt;br&gt;
不用到头再返回&lt;/p&gt;
&lt;h4 id=&#34;减少延迟时间&#34;&gt;减少延迟时间&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;51&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BFOrRK&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFOrRK.png&#34; alt=&#34;BFOrRK.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&#34;https://imgchr.com/i/BFXOXD&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFXOXD.png&#34; alt=&#34;BFXOXD.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BFj8uF&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFj8uF.png&#34; alt=&#34;BFj8uF.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;转两圈可能是因为一圈会有遗漏的&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BFvGxf&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFvGxf.png&#34; alt=&#34;BFvGxf.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
和交替编号一样,错位命名也是为了防止转过头,稍微有点儿时间准备&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;52&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BFvszV&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFvszV.png&#34; alt=&#34;BFvszV.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h3 id=&#34;磁盘管理&#34;&gt;磁盘管理&lt;/h3&gt;
&lt;h4 id=&#34;磁盘初始化&#34;&gt;磁盘初始化&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;53&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BFvzWt&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFvzWt.png&#34; alt=&#34;BFvzWt.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;引导块&#34;&gt;引导块&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;54&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BFx21P&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFx21P.png&#34; alt=&#34;BFx21P.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;坏块&#34;&gt;坏块&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;55&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BFxokj&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFxokj.png&#34; alt=&#34;BFxokj.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;小结-5&#34;&gt;小结&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;56&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/BFxq10&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/22/BFxq10.png&#34; alt=&#34;BFxq10.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
">第四章 文件管理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/xu-ni-nei-cun-ji-zhu-de-cuo-ti-ji-zhi-shi-dian/"" data-c="
          &lt;ol&gt;
&lt;li&gt;虚拟存储技术是&lt;strong&gt;补充内存逻辑空间的技术&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;虚拟存储特征
&lt;ol&gt;
&lt;li&gt;虚拟性&lt;/li&gt;
&lt;li&gt;多次性&lt;/li&gt;
&lt;li&gt;离散型&lt;/li&gt;
&lt;li&gt;对换性&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;虽然实际中虚拟存储器的最大容量是内存和外村之和,&lt;strong&gt;但是问的话还是取决于计算机的地质结构,如地址寄存器n位则最大容量是2&lt;/strong&gt;&lt;sup&gt;n&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;导致LRU算法实现起来耗费高的原因:&lt;strong&gt;需要对所有的页排序&lt;/strong&gt;,并不是需要硬件特殊支持&lt;/li&gt;
&lt;li&gt;页表项中的合法位信息显示本页面是否在内存中,即决定了是否会发生页面故障&lt;/li&gt;
&lt;li&gt;产生内存抖动的主要原因是&lt;strong&gt;页面置换算法不合理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;注意区别
&lt;ol&gt;
&lt;li&gt;不要求将作业&lt;strong&gt;同时全部&lt;/strong&gt;装入内存的连续区域是虚拟内存要求的&lt;/li&gt;
&lt;li&gt;不要求将作业装入内存的连续区域是离散式存储管理要求的(包括页式存储管理)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;虚拟存储机制需要请求机制的支持,然后才是基于页或段,都可以&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;快表用于地址变换,就是为了查找物理地址更快&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;无论用什么算法缺页次数都不会少于页号的个数(不同的)&lt;/li&gt;
&lt;li&gt;采用FIFO页面置换,当可供分配的页帧数增加时,缺页中断次数可能增加也可能减少
&lt;ol&gt;
&lt;li&gt;Belady异常:增加的&lt;/li&gt;
&lt;li&gt;序列为123123,两个页帧时,6次缺页中断,3个页帧时,3次,这个是减少的&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;和页面中断一样意思的术语&#34;&gt;和页面中断一样意思的术语&lt;/h2&gt;
&lt;p&gt;页面失效的次数:要包括前面空的时候往上放的页面的个数&lt;br&gt;
页面置换的次数:不包括前面空的时候放的,仅计算需要换出再换入的个数&lt;/p&gt;
&lt;h2 id=&#34;关于访问时间的超级重要&#34;&gt;关于访问时间的(超级重要)&lt;/h2&gt;
&lt;p&gt;缺页中断之后,会更新页表,但不会更新快表,它会向先前一样,先访问快表(因为没更新所有还是无法命中),然后再次访问内存的页表,这个时候不会再缺页了,然后就更新快表项,因此王道上的那个流程图是没问题的&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/BSjVpQ&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/20/BSjVpQ.png&#34; alt=&#34;BSjVpQ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
">虚拟内存技术的错题及知识点</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-liu-zhang-ying-yong-ceng-cuo-ti-ji-zhi-shi-dian/"" data-c="
          &lt;ol&gt;
&lt;li&gt;域名和IP地址,MAC地址,主机&lt;strong&gt;都不是&lt;/strong&gt;一一对应关系&lt;/li&gt;
&lt;li&gt;采用迭代的方式查询,本地域名服务器最少查询0次,最多查询4次
&lt;ol&gt;
&lt;li&gt;有缓存,0次&lt;/li&gt;
&lt;li&gt;根-&amp;gt;顶级-&amp;gt;权限-&amp;gt;权限:因为这里是www.abc.xyz.com所以2个权限域名服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;采用递归方法解析,主机和本地域名服务器请求都是1次&lt;/li&gt;
&lt;li&gt;每台主机都必须在授权域名服务器登记,授权域名服务器总能将其管辖的主机名转换为该主机的IP地址&lt;/li&gt;
&lt;li&gt;DNS名字/名称就是指域名&lt;/li&gt;
&lt;li&gt;用LIST命令传回的列表信息也是通过数据连接返回的,不是控制连接&lt;/li&gt;
&lt;li&gt;FTP不适合两个计算机之间共享读写文件&lt;/li&gt;
&lt;li&gt;匿名FTP访问通常使用&lt;strong&gt;anonymous&lt;/strong&gt;作为用户名&lt;/li&gt;
&lt;li&gt;POP协议,服务器的邮件删不删是由客户端决定的&lt;/li&gt;
&lt;li&gt;POP发送的东西是不加密的,密码也是&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;关于http部分的&#34;&gt;关于HTTP部分的&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;HEAD方法,服务器可对HTTP报文进行响应,但不会返回请求对象,作用主要是调试&lt;/li&gt;
&lt;li&gt;Cookie是服务器产生的,存储在客户端&lt;/li&gt;
&lt;li&gt;非持续连接对于每次请求都建立一次TCP连接,一个页面包含100个图像,则建立了101次&lt;/li&gt;
&lt;li&gt;Connection:连接方式
&lt;ol&gt;
&lt;li&gt;close:非持续连接&lt;/li&gt;
&lt;li&gt;keep-alive:持续连接&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
">第六章 应用层错题及知识点</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-liu-zhang-ying-yong-ceng/"" data-c="
          &lt;h2 id=&#34;网络模型&#34;&gt;网络模型&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0jJaAf.png&#34; alt=&#34;0jJaAf.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0jYlV0.png&#34; alt=&#34;0jYlV0.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;dns&#34;&gt;DNS&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0jt8eI&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0jt8eI.png&#34; alt=&#34;0jt8eI.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0jNk9S&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0jNk9S.png&#34; alt=&#34;0jNk9S.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0jN4C8&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0jN4C8.png&#34; alt=&#34;0jN4C8.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h2 id=&#34;ftp&#34;&gt;FTP&lt;/h2&gt;
&lt;p&gt;FTP:File Transfer Protocol&lt;br&gt;
TFTP:Trivial File Transfer Protocol,简单文件传输协议&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0vn759&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0vn759.png&#34; alt=&#34;0vn759.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;p&gt;&lt;a href=&#34;https://imgchr.com/i/0vuOij&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0vuOij.png&#34; alt=&#34;0vuOij.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
主动:建立连接后,S主动告诉C是20端口发送数据&lt;br&gt;
被动:建立连接后,C问S,S告诉一个端口号&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/0vKPwF&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0vKPwF.png&#34; alt=&#34;0vKPwF.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;电子邮件&#34;&gt;电子邮件&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0v1GE8&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0v1GE8.png&#34; alt=&#34;0v1GE8.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0v1p9J&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0v1p9J.png&#34; alt=&#34;0v1p9J.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0v1ags&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0v1ags.png&#34; alt=&#34;0v1ags.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h3 id=&#34;smtpsimple-mail-transfer-protocol&#34;&gt;SMTP:Simple Mail Transfer Protocol&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0v3rQA&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0v3rQA.png&#34; alt=&#34;0v3rQA.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;** 注意**&lt;br&gt;
端口587只应用于提交（即，邮件客户端到邮件服务器）&lt;br&gt;
端口25只应用于中继（即，邮件服务器到邮件服务器通信&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0v3IQs&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0v3IQs.png&#34; alt=&#34;0v3IQs.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h3 id=&#34;pop3post-office-protocol&#34;&gt;POP3:Post Office Protocol&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0v8SyR&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0v8SyR.png&#34; alt=&#34;0v8SyR.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h3 id=&#34;imapinternet-message-access-protocol因特网报文存取协议&#34;&gt;IMAP:Internet Message Access Protocol(因特网报文存取协议)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0v8eld&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0v8eld.png&#34; alt=&#34;0v8eld.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h3 id=&#34;基于万维网的电子邮件&#34;&gt;基于万维网的电子邮件&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://imgchr.com/i/0v8amq&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0v8amq.png&#34; alt=&#34;0v8amq.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
只有中继地时候才用SMTP,其余的是http协议&lt;/p&gt;
&lt;h2 id=&#34;万维网wwwworld-wide-web&#34;&gt;万维网(www):World Wide Web&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://imgchr.com/i/0vGe4U&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0vGe4U.png&#34; alt=&#34;0vGe4U.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
URL:Uniform Resource Locator:统一资源定位符&lt;br&gt;
HTML:HyperText Makeup Language:超文本标记语言&lt;br&gt;
HTTP:HyperText Transfer Protocol&lt;/p&gt;
&lt;h3 id=&#34;http&#34;&gt;HTTP&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0v098P&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0v098P.png&#34; alt=&#34;0v098P.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0v0ZUs&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0v0ZUs.png&#34; alt=&#34;0v0ZUs.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0v0lKU&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0v0lKU.png&#34; alt=&#34;0v0lKU.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0v0NP1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0v0NP1.png&#34; alt=&#34;0v0NP1.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0v05qg&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0v05qg.png&#34; alt=&#34;0v05qg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
">第六章 应用层</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-wu-zhang-chuan-shu-ceng-zhi-shi-dian-ji-cuo-ti/"" data-c="
          &lt;ol&gt;
&lt;li&gt;TCP保证可靠且&lt;strong&gt;顺序&lt;/strong&gt;交付&lt;/li&gt;
&lt;li&gt;TCP并没有要求网络层必须使用虚电路,TCP不影响网络层提供无连接服务&lt;/li&gt;
&lt;li&gt;UDP接受到有差错的数据就&lt;strong&gt;直接丢弃&lt;/strong&gt;,不要选忽略差错&lt;/li&gt;
&lt;li&gt;当一个IP数据报分成了4片,第一次传过去后两片到了(在缓存区),前两片丢失,第二次前两片到了,后两片丢失,那么能否组成原来的IP数据报
&lt;ol&gt;
&lt;li&gt;是不可以的,第一次和第二次分片的标识部分变了,无法识别成一个数据报&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根据2019年408真题选择38题可知,快速重传的3个冗余ACK并不是指共四个,就是3个&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;客户端和服务器端都可以提出释放连接&lt;/li&gt;
&lt;li&gt;TCP滑动窗口中,规定重传分组的数量最多是&lt;strong&gt;等于滑动窗口的大小&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;滑动窗口的值太大,会导致传送数据太多,路由器拥挤,造成丢失&lt;/li&gt;
&lt;li&gt;拥塞窗口是&lt;strong&gt;发送端&lt;/strong&gt;根据网络拥塞情况确定的窗口值&lt;br&gt;
10.使用两台主机已经建立TCP连接的端口再建立连接,会建立失败,不影响先建立连接的传输&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;已知接收窗口大小问可发送多少&#34;&gt;已知接收窗口大小,问可发送多少&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;单位B,切记,别弄成多少TCP报文段了&lt;/li&gt;
&lt;li&gt;注意问的是有没有收到报文段
&lt;ol&gt;
&lt;li&gt;未收到报文段,就是接收窗口大小&lt;/li&gt;
&lt;li&gt;收到了,比如接收窗口5000B,发送窗口连着发两个,一个1000B,一个3000B,收到1000B的确认,那么还可以继续发送的:5000B-3000B=2000B&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;问拥塞窗口大小的或者变形类的问经历多少时间也就是多少ttl本质一样&#34;&gt;问拥塞窗口大小的(或者变形类的,问经历多少时间也就是多少TTL本质一样)&lt;/h2&gt;
&lt;h3 id=&#34;注意分辨是哪种&#34;&gt;注意分辨是哪种&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;题目给的超时&lt;br&gt;
那么就是慢启动+拥塞避免算法:降到1开始,先慢启动再拥塞避免,注意2倍大于阈值时得取为阈值然后开始使用拥塞避免算法&lt;/li&gt;
&lt;li&gt;题目说收到3个冗余ACK报文&lt;br&gt;
那么就是快重传+快恢复:降到产生拥塞时的一半开始拥塞避免算法&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;注意点&#34;&gt;注意点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;核心点是要知道每次增加(不管翻倍还是增1),都是在一个TTL完成后&lt;/li&gt;
&lt;li&gt;根据1,如果问的是第n次开始传输时大小为多少,那么算的是n-1个TTL后的大小&lt;/li&gt;
&lt;li&gt;如果问拥塞窗口为XXX的时候,经历的时间,本质是一样的&lt;/li&gt;
&lt;/ol&gt;
">第五章 传输层知识点及错题</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-wu-zhang-chuan-shu-ceng/"" data-c="
          &lt;h2 id=&#34;概述&#34;&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0OXJRP.png&#34; alt=&#34;0OXJRP.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0OX7z6.png&#34; alt=&#34;0OX7z6.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0OjSJI.png&#34; alt=&#34;0OjSJI.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0OjAeg.png&#34; alt=&#34;0OjAeg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;udp&#34;&gt;UDP&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0OjLpq.png&#34; alt=&#34;0OjLpq.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0OvUEQ.png&#34; alt=&#34;0OvUEQ.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
源端口可以没有(如果不希望对方回信),全0&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0Ozxnf.png&#34; alt=&#34;0Ozxnf.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
二进制反码就是最高位如果进位,则将进位的1移到最低位,再求和&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1100
1011
_____
0111
0001(进的位到最低位再求和)
_____
1000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;最后几部分求和的结果再取反才是校验和&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;tcp&#34;&gt;TCP&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0XJOoT.png&#34; alt=&#34;0XJOoT.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;格式&#34;&gt;格式:&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0XYFw6.png&#34; alt=&#34;0XYFw6.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0XYu6A.png&#34; alt=&#34;0XYu6A.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0XY8k8.png&#34; alt=&#34;0XY8k8.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;tcp连接管理&#34;&gt;TCP连接管理&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0XaN5V.png&#34; alt=&#34;0XaN5V.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0XaoqA.png&#34; alt=&#34;0XaoqA.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;tcp连接释放&#34;&gt;TCP连接释放&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0Xd6yQ.png&#34; alt=&#34;0Xd6yQ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;tcp可靠传输&#34;&gt;TCP可靠传输&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0XBvYq.png&#34; alt=&#34;0XBvYq.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;tcp流量控制&#34;&gt;TCP流量控制&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0XskJ1.png&#34; alt=&#34;0XskJ1.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;tcp拥塞控制&#34;&gt;TCP拥塞控制&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0X6YVg.png&#34; alt=&#34;0X6YVg.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/18/0X67ZD.png&#34; alt=&#34;0X67ZD.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">第五章 传输层</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-si-zhang-wang-luo-ceng-zhi-shi-dian-ji-cuo-ti-zheng-li/"" data-c="
          &lt;ol&gt;
&lt;li&gt;在路由器连接的多个局域网的结构中,要求每个局域网&lt;strong&gt;物理层,数据链路层,网络层协议可以不同,而网络层以上的协议必须相同&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;网络中发生了拥塞根据是随着通信子网负载的增加,吞吐量反而降低&lt;/li&gt;
&lt;li&gt;网络的异构性是指传输介质,数据编码方式,链路控制协议及不同的数据单元格式和转发机制,这些都是在数据链路层和物理层&lt;/li&gt;
&lt;li&gt;MTU不是帧长度,而是帧的数据部分1500那个&lt;/li&gt;
&lt;li&gt;UDP是传输层的&lt;/li&gt;
&lt;li&gt;RARP(Reverse Address Resolution Protocol ):逆地址解析协议&lt;/li&gt;
&lt;li&gt;与分片和重组无关的是总长度,标识需要判断是否为一个分片&lt;/li&gt;
&lt;li&gt;把IP网络划分成子网,这样做的好处是减少广播域的大小&lt;/li&gt;
&lt;li&gt;DF=1,分组长度超过MTU时丢弃该分组,&lt;strong&gt;且向源主机报告&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;子网划分,CIDR,NAT都只能缓解IPv4地址耗尽的危机,提高利用率,治本的还是使用IPv6&lt;/li&gt;
&lt;li&gt;CIDR的作用是把小的网络汇聚成大的超网&lt;/li&gt;
&lt;li&gt;一道比较好的题&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/16/0b9Dl6.png&#34; alt=&#34;0b9Dl6.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
224说明到前27位,第四个字节借了3位用作子网,可以划分8个&lt;br&gt;
000|00001    1&lt;br&gt;
000|11110    30:202.3.1.1~202.3.1.30为第一个,全1和全0都不可以分配&lt;br&gt;
001|00001    33&lt;br&gt;
001|11110    62:33~62第二个,可以看到ACD都是在这个范围内&lt;br&gt;
010|00001    65 //B属于这个段&lt;br&gt;
..........&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;13&#34;&gt;
&lt;li&gt;NAT添加表项需要管理员配置,因此来了一个新的分组,找不到表项,就会丢弃不转发&lt;/li&gt;
&lt;li&gt;2019真题&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0q7pv9.png&#34; alt=&#34;0q7pv9.png&#34; loading=&#34;lazy&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0q7mgH.png&#34; alt=&#34;0q7mgH.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;OSPF划分区域使得交换的信息减少了&lt;/li&gt;
&lt;li&gt;RIP中,距离值为16表示该网络不可达&lt;/li&gt;
&lt;li&gt;所谓路由收敛是指当路由环境变化之后,各路由器调整自己的路由表以适应网络拓扑结构的变化,最终达到稳定状态(也就是路由表与网络拓扑状态保持一致)
&lt;ol&gt;
&lt;li&gt;收敛越快,路由器就能越快适应网络拓扑结构的变化&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;keepalive是BGP的报文
&lt;ol&gt;
&lt;li&gt;Open&lt;/li&gt;
&lt;li&gt;Update&lt;/li&gt;
&lt;li&gt;Keepalive&lt;/li&gt;
&lt;li&gt;Notification&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;hello是OSPF的报文,用来发现和维持邻站的可达性&lt;/li&gt;
&lt;li&gt;多个单播仿真组播时
&lt;ol&gt;
&lt;li&gt;需要的带宽多于组播,但是组播的带宽小于多个组播之和&lt;/li&gt;
&lt;li&gt;时延很大,处理一个组播分组的时延很小&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;移动IP移到外网时,既不能直接接收数据,也不能发送,都要本地代理转到外部代理&lt;/li&gt;
&lt;li&gt;添加路由表项的题目,如果看到要到所有子网,一定要想着合并路由(超网)&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
">第四章 网络层知识点及错题整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-si-zhang-wang-luo-ceng/"" data-c="
          &lt;h2 id=&#34;ipv4&#34;&gt;IPv4&lt;/h2&gt;
&lt;h3 id=&#34;格式&#34;&gt;格式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/15/0TqHIS.png&#34; alt=&#34;0TqHIS.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/15/0TjNe1.png&#34; alt=&#34;0TjNe1.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
这一章网络层里暂时先把数据报当成分组,只是过大的时候要分片&lt;br&gt;
首部长度单位是4B,总长度单位是1B,片偏移长度是8B&lt;/p&gt;
&lt;h3 id=&#34;ip数据报分片&#34;&gt;IP数据报分片&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/15/0TLZs1.png&#34; alt=&#34;0TLZs1.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/15/0Tv5Ax.png&#34; alt=&#34;0Tv5Ax.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;ip地址&#34;&gt;IP地址&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/15/07PUPI.png&#34; alt=&#34;07PUPI.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/15/07P7dJ.png&#34; alt=&#34;07P7dJ.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/15/07iKoj.png&#34; alt=&#34;07iKoj.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;子网划分&#34;&gt;子网划分&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/15/07mLYF.png&#34; alt=&#34;07mLYF.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/16/0H9jPI.png&#34; alt=&#34;0H9jPI.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;cidrclassless-interdomain-routing&#34;&gt;CIDR(classless interdomain routing)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/16/0HCCqg.png&#34; alt=&#34;0HCCqg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;arpaddress-resolution-protocol&#34;&gt;ARP(Address resolution protocol)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/16/0HVR9H.png&#34; alt=&#34;0HVR9H.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/16/0HZdIS.png&#34; alt=&#34;0HZdIS.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;dhcpdynamic-host-configuration-protocol&#34;&gt;DHCP(Dynamic Host Configuration Protocol)&lt;/h3&gt;
&lt;p&gt;应用层协议&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/16/0HeKLq.png&#34; alt=&#34;0HeKLq.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/16/0Hm8Bt.png&#34; alt=&#34;0Hm8Bt.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注意全都是广播&lt;/p&gt;
&lt;h3 id=&#34;icmpinternet-control-message-protocol&#34;&gt;ICMP(Internet Control Message Protocol)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/16/0HKcUP.png&#34; alt=&#34;0HKcUP.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/16/0HKxKJ.png&#34; alt=&#34;0HKxKJ.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/16/0Hdb3d.png&#34; alt=&#34;0Hdb3d.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/16/0HKK9U.png&#34; alt=&#34;0HKK9U.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
ICMP差错报告报文就是IP数据报的数据部分&lt;br&gt;
有5种差错报告报文和4种询问报文&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/16/0H0mLt.png&#34; alt=&#34;0H0mLt.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
最后两种不再使用了&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/16/0H0tLq.png&#34; alt=&#34;0H0tLq.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;ipv6&#34;&gt;IPv6&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0qHjl4.png&#34; alt=&#34;0qHjl4.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0qHUJO.png&#34; alt=&#34;0qHUJO.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;rip&#34;&gt;RIP&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0LVOyj.png&#34; alt=&#34;0LVOyj.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0LVBe1.png&#34; alt=&#34;0LVBe1.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0LVOyj.png&#34; alt=&#34;0LVOyj.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0LM03V.png&#34; alt=&#34;0LM03V.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0LMDjU.png&#34; alt=&#34;0LMDjU.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;ospfopen-shortest-path-first&#34;&gt;OSPF(Open Shortest Path First)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0LlYYn.png&#34; alt=&#34;0LlYYn.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0Llcf1.png&#34; alt=&#34;0Llcf1.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0L3MVg.png&#34; alt=&#34;0L3MVg.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0L3Jx0.png&#34; alt=&#34;0L3Jx0.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;bgpborder-gateway-protocol&#34;&gt;BGP(Border Gateway Protocol)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0L3cM6.png&#34; alt=&#34;0L3cM6.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0L8Hh9.png&#34; alt=&#34;0L8Hh9.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0LwET0.png&#34; alt=&#34;0LwET0.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0LwYtK.png&#34; alt=&#34;0LwYtK.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;ip组播多播&#34;&gt;IP组播(多播)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0LDyA1.png&#34; alt=&#34;0LDyA1.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0L4But.png&#34; alt=&#34;0L4But.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;igmp与组播路由算法&#34;&gt;IGMP与组播路由算法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0L4YND.png&#34; alt=&#34;0L4YND.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0L4c4g.png&#34; alt=&#34;0L4c4g.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0L47UU.png&#34; alt=&#34;0L47UU.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0LItld.png&#34; alt=&#34;0LItld.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0LIclj.png&#34; alt=&#34;0LIclj.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0LIh7V.png&#34; alt=&#34;0LIh7V.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0LIohF.png&#34; alt=&#34;0LIohF.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;移动ip&#34;&gt;移动IP&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0O9Dr6.png&#34; alt=&#34;0O9Dr6.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0LIohF.png&#34; alt=&#34;0LIohF.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;网络层设备&#34;&gt;网络层设备&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0OFq00.png&#34; alt=&#34;0OFq00.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0OkzUf.png&#34; alt=&#34;0OkzUf.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/17/0OFsld.png&#34; alt=&#34;0OFsld.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">第四章 网络层</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-san-zhang-shu-ju-lian-lu-ceng-lian-xi/"" data-c="
          &lt;ol&gt;
&lt;li&gt;出错控制的几个功能
&lt;ol&gt;
&lt;li&gt;CRC/汉明码=&amp;gt;位错&lt;/li&gt;
&lt;li&gt;计时器超时重发=&amp;gt;避免传输过程中帧的丢失&lt;/li&gt;
&lt;li&gt;枕编号=&amp;gt;不会受到重复帧&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;物理信道传输成功率为X,一个网络层分组分成N个数据链路层帧,则发送分组成功率为X&lt;sup&gt;N&lt;/sup&gt;,因为要保证每一个都成功&lt;/li&gt;
&lt;li&gt;奇偶校验码和CRC只能检查出奇数个比特错误,汉明码是可以发现双比特错误,纠正单比特错误&lt;/li&gt;
&lt;li&gt;链路层能提供差错检测,也能纠正(汉明码)&lt;/li&gt;
&lt;li&gt;通过提高信噪比可以减弱随机差错的影响&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/10/0szHqs.png&#34; alt=&#34;0szHqs.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;发送窗口大小≤窗口大小-1
&lt;ol&gt;
&lt;li&gt;我觉得减一是因为接收窗口至少为1&lt;/li&gt;
&lt;li&gt;在SR协议中,接收窗口+发送窗口≤2&lt;sup&gt;n&lt;/sup&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;FDM比TDM应用多是因为&lt;strong&gt;TDM可用于数字传输而FDM不可以&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;注意题目经常用FDMA,TDMA:frequency division multiple access&lt;/li&gt;
&lt;li&gt;随机访问介质访问控制有冲突,其他都没有&lt;/li&gt;
&lt;li&gt;CSMA/CD做题的时候抓住核心就是一切为了避免&lt;strong&gt;帧在传输完之前,上一个返回,也就是传输的时间得大于2τ&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;帧长度减少了,那么要么传输速率减小,要么2τ减小(即线路变短,使帧在传输完之前,能赶回来)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;使用二进制回退算法考虑了网络负载对冲突的影响,k越大,发生冲突的概率越小&lt;/li&gt;
&lt;li&gt;CSMA/CA有确认&lt;/li&gt;
&lt;li&gt;令牌环网更适合负载重的,也不存在冲突&lt;/li&gt;
&lt;li&gt;多路复用转换器的主要功能是结合来自两条或多条线路的传输&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;关于局域网&#34;&gt;关于局域网&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;令牌环网中,一个站点最坏情况下等待获得令牌和发送数据帧的时间是&lt;strong&gt;所有发送站点传送令牌和发送帧的时间的总和&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/14/05GZfU.png&#34; alt=&#34;05GZfU.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/14/05G8k6.png&#34; alt=&#34;05G8k6.png&#34; loading=&#34;lazy&#34;&gt;
&lt;ol&gt;
&lt;li&gt;不需要在发送过程中进行碰撞检测&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/14/05JC9O.png&#34; alt=&#34;05JC9O.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;大量的广播信息会降低整个网络性能的原因是:每台计算机都必须处理每个广播信息&lt;/li&gt;
&lt;li&gt;a,b,c,d四台计算机,a向b发送数据,每台都能1接收到&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;关于广域网&#34;&gt;关于广域网&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;广域网采用的传输方式是&lt;strong&gt;存储转发式&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;关于广播域和冲突域&#34;&gt;关于广播域和冲突域&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;广播域看路由器&lt;/li&gt;
&lt;li&gt;冲突域看交换机,几个口就几个冲突域&lt;/li&gt;
&lt;li&gt;VLAN可以隔离冲突域也可以隔离广播域&lt;/li&gt;
&lt;li&gt;网桥可以互联不同的物理层,不同的MAC子层及不同速率的以太网&lt;/li&gt;
&lt;li&gt;网桥可以过滤网段之间的数据但是不能过滤并有效阻止广播数据
&lt;ol&gt;
&lt;li&gt;第二层设备没法解决广播域的问题&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;网络层设备既可以隔离广播域又可以隔离冲突域&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;交换机&#34;&gt;交换机&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;直通式交换机只检查帧的目的地址,转发时延就是地址大小/带宽&lt;/li&gt;
&lt;li&gt;交换机比集线器提供更好的网络性能的原因是交换机支持多对用户同时通信
&lt;ol&gt;
&lt;li&gt;交换机是隔离冲突域的,且是半双工通信,因此可以多对同时通信,而集线器下,都是一个冲突域,不能同时通信&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;对于10Mb/s的端口,半双工带宽为10Mb/s,全双工是20Mb/s&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/15/0TAnDU.png&#34; alt=&#34;0TAnDU.png&#34; loading=&#34;lazy&#34;&gt;
&lt;ol&gt;
&lt;li&gt;如果是全双工,每个连接点获得的带宽值就是20&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;如果一个结点向某个结点发送信息,所有的结点(包括自己)都能收到信息,但是如果各自连在某个交换机的口上,那么交换机只会向这个端口以外的端口转发(没有转发表)&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
">第三章 数据链路层练习</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/ji-suan-ji-wang-luo-di-san-zhang-shu-ju-lian-lu-ceng/"" data-c="
          &lt;h2 id=&#34;1-数据链路层功能&#34;&gt;1 数据链路层功能&lt;/h2&gt;
&lt;h2 id=&#34;成帧&#34;&gt;成帧&lt;/h2&gt;
&lt;h2 id=&#34;差错控制&#34;&gt;差错控制&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/10/0ySkIx.png&#34; alt=&#34;0ySkIx.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;流量控制&#34;&gt;流量控制&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/10/0yZuVO.png&#34; alt=&#34;0yZuVO.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;窗口大小都是固定的&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;单帧滑动窗口与停止等待协议&#34;&gt;单帧滑动窗口与停止等待协议&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/10/0yaSL8.png&#34; alt=&#34;0yaSL8.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;多帧滑动窗口与后退n帧协议gbn&#34;&gt;多帧滑动窗口与后退N帧协议(GBN)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/10/06PWSP.png&#34; alt=&#34;06PWSP.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/10/06iKkd.png&#34; alt=&#34;06iKkd.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/10/06Fy8I.png&#34; alt=&#34;06Fy8I.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/10/06kuRI.png&#34; alt=&#34;06kuRI.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/10/06AD1I.png&#34; alt=&#34;06AD1I.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/10/06A53n.png&#34; alt=&#34;06A53n.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/10/06AON4.png&#34; alt=&#34;06AON4.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;多帧滑动窗口与选择重传协议sr&#34;&gt;多帧滑动窗口与选择重传协议(SR)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/10/06VZoF.png&#34; alt=&#34;06VZoF.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/10/06eJ8H.png&#34; alt=&#34;06eJ8H.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/10/06eOqx.png&#34; alt=&#34;06eOqx.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/10/06mVdf.png&#34; alt=&#34;06mVdf.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/10/06nm0x.png&#34; alt=&#34;06nm0x.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/10/06mgYD.png&#34; alt=&#34;06mgYD.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;介质访问控制&#34;&gt;介质访问控制&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/11/0g89S0.png&#34; alt=&#34;0g89S0.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;信道划分介质访问控制&#34;&gt;信道划分介质访问控制&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;FDM&lt;/li&gt;
&lt;li&gt;TDM
&lt;ol&gt;
&lt;li&gt;注意STDM,使用集中器&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;WDM&lt;/li&gt;
&lt;li&gt;CDM&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;随机访问介质访问控制&#34;&gt;随机访问介质访问控制&lt;/h3&gt;
&lt;h4 id=&#34;aloha协议&#34;&gt;ALOHA协议&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/11/0gUBn0.png&#34; alt=&#34;0gUBn0.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;csma协议carrier-sense-multiple-access载波侦听多路访问&#34;&gt;CSMA协议(Carrier Sense Multiple Access,载波侦听多路访问)&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/11/0gakgs.png&#34; alt=&#34;0gakgs.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;1-坚持CSMA&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/11/0gaJDx.png&#34; alt=&#34;0gaJDx.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;非坚持CSMA&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/11/0gy4u4.png&#34; alt=&#34;0gy4u4.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;p-坚持CSMA&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/11/0gyetx.png&#34; alt=&#34;0gyetx.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
缺点:冲突了还是会把数据发完,造成浪费&lt;/li&gt;
&lt;li&gt;对比&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/11/0g6C5t.png&#34; alt=&#34;0g6C5t.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;csmacdcollision-detection&#34;&gt;CSMA/CD(Collision Detection)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/11/0gcGfP.png&#34; alt=&#34;0gcGfP.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/12/0RUEkT.png&#34; alt=&#34;0RUEkT.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
书上的图只是为了得到2τ,CSMA/CD的根本目的为了在传输完成前就可以检测到碰撞进而停止发送,而不是让他们发送出去之后检测到碰撞&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/12/0Rw4HI.png&#34; alt=&#34;0Rw4HI.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/12/0R0mUx.png&#34; alt=&#34;0R0mUx.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/12/0R03KH.png&#34; alt=&#34;0R03KH.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;csmacacollision-avoidance&#34;&gt;CSMA/CA(Collision Avoidance)&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/12/0Rs4t1.png&#34; alt=&#34;0Rs4t1.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;轮询访问介质访问控制令牌传递协议&#34;&gt;轮询访问介质访问控制:令牌传递协议&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/12/0R2YZD.png&#34; alt=&#34;0R2YZD.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/12/0RWoaF.png&#34; alt=&#34;0RWoaF.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;小结&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/12/0RgUg0.png&#34; alt=&#34;0RgUg0.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
只有第二类随机访问介质访问控制会产生冲突&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/12/0RfCPH.png&#34; alt=&#34;0RfCPH.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;局域网&#34;&gt;局域网&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/12/0WlOL8.png&#34; alt=&#34;0WlOL8.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/12/0W1mFJ.png&#34; alt=&#34;0W1mFJ.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/12/0W3YuV.png&#34; alt=&#34;0W3YuV.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/12/0W333n.png&#34; alt=&#34;0W333n.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/12/0W8Svq.png&#34; alt=&#34;0W8Svq.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/12/0W8txI.png&#34; alt=&#34;0W8txI.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/12/0W86Rs.png&#34; alt=&#34;0W86Rs.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;以太网&#34;&gt;以太网&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/13/0f7qb9.png&#34; alt=&#34;0f7qb9.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/13/0fHQbj.png&#34; alt=&#34;0fHQbj.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/13/0fHaMF.png&#34; alt=&#34;0fHaMF.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/13/0fHOsg.png&#34; alt=&#34;0fHOsg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;ieee-80211&#34;&gt;IEEE 802.11&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/13/0hpzGQ.png&#34; alt=&#34;0hpzGQ.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/13/0h98IO.png&#34; alt=&#34;0h98IO.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;广域网&#34;&gt;广域网&lt;/h2&gt;
&lt;h3 id=&#34;ppp协议&#34;&gt;PPP协议&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;只支持全双工&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/14/05wDWq.png&#34; alt=&#34;05wDWq.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/14/05wcOU.png&#34; alt=&#34;05wcOU.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/14/05yVSA.png&#34; alt=&#34;05yVSA.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/14/05yDfJ.png&#34; alt=&#34;05yDfJ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;hdlc及对比总结&#34;&gt;HDLC及对比总结&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/14/05gAW4.png&#34; alt=&#34;05gAW4.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/14/05guex.png&#34; alt=&#34;05guex.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;数据链层设备&#34;&gt;数据链层设备&lt;/h2&gt;
&lt;h3 id=&#34;物理层扩展&#34;&gt;物理层扩展&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/14/0IavwQ.png&#34; alt=&#34;0IavwQ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;网桥数据链层扩展&#34;&gt;网桥(数据链层扩展)&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/14/0IwSBD.png&#34; alt=&#34;0IwSBD.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/14/0I0tzt.png&#34; alt=&#34;0I0tzt.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;交换机&#34;&gt;交换机&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/14/0I0jeO.png&#34; alt=&#34;0I0jeO.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/14/0IBEm8.png&#34; alt=&#34;0IBEm8.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;冲突域与广播域&#34;&gt;冲突域与广播域&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/14/0IDdUg.png&#34; alt=&#34;0IDdUg.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
广播域看路由器&lt;br&gt;
冲突域看交换机,几个口就几个冲突域&lt;br&gt;
VLAN可以隔离冲突域也可以隔离广播域&lt;/p&gt;
&lt;h3 id=&#34;小结-2&#34;&gt;小结&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/14/0IDgbT.png&#34; alt=&#34;0IDgbT.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">计算机网络 第三章 数据链路层</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/wu-li-ceng-lian-xi/"" data-c="
          &lt;h2 id=&#34;1-概念&#34;&gt;1 概念&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;同步异步传输是通信方式不是传输方式,并行传输距离短速度快,串行传输距离长速度慢,计算机内部采用并行传输&lt;/li&gt;
&lt;li&gt;以太网使用曼彻斯特编码,因此每位数据需要两个电平&lt;/li&gt;
&lt;li&gt;为保证数据无差错地传送,不用选用的交换方式是电路交换&lt;/li&gt;
&lt;li&gt;分组交换是对报文交换的改进,这种改进的直接结果是减少了传输时延&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;利用模拟通信信道传输数字信号的方法叫频带传输&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;报文交换不可以用于语音数据传输&lt;/li&gt;
&lt;li&gt;利用一根同轴电缆,互连主机成以太网,通信方式为半双工&lt;/li&gt;
&lt;li&gt;同轴电缆较双绞线带宽更高得益于它的高屏蔽性&lt;/li&gt;
&lt;li&gt;中继器试讲衰减的信号进行还原和再生而&lt;strong&gt;并非简单的放大&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;两个网段在&lt;strong&gt;物理层&lt;/strong&gt;进行互联时要求数据传输率相同,但&lt;strong&gt;数据链路层的协议可以不同&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;数据传输率是对于物理层来说的&lt;/li&gt;
&lt;li&gt;本层互联时只要求本层及本层以下的协议必须相同,本层及本层以上的协议可以不同&lt;/li&gt;
&lt;li&gt;这一层相通只代表可以传输这一层的信号,以上层的不可以&lt;/li&gt;
&lt;li&gt;如果说物理层设备连接的几个网段仍是一个局域网,就要求不能连接具有不同数据链路层协议的网段&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-计算&#34;&gt;2 计算&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;计算时注意奈氏准则和香农定理的共同限制,奈氏的可能隐藏信息(如出现多少进制)&lt;/li&gt;
&lt;li&gt;P43/22注意一下&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/09/0rukef.png&#34; alt=&#34;0rukef.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;这两题本质是一样的,都是将所有分组从发送端发送完后,分析最后一个分组,此时只要看最后一个分组需要再存储转发几次就可以&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;数据率=数据大小/时间
&lt;ol&gt;
&lt;li&gt;采样采的是帧&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
">物理层练习</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/ji-suan-ji-wang-luo-di-er-zhang-wu-li-ceng/"" data-c="
          &lt;h2 id=&#34;总览&#34;&gt;总览&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/08/0wztSA.png&#34; alt=&#34;0wztSA.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;通信基础&#34;&gt;通信基础&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/08/0wzzkD.png&#34; alt=&#34;0wzzkD.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/08/0090w6.png&#34; alt=&#34;0090w6.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
k进制码元&lt;br&gt;
例如4进制码元,码元的离散状态有4个,代表4种高低不同的信号波形&lt;br&gt;
00  01  10  11&lt;br&gt;
那么一个码元就带有2b的信息&lt;br&gt;
同理,16进制的码元,离散状态有16个,代表16种高低不同的信号波形&lt;br&gt;
0000  0001  0010 0011 0100  0101  0110  0111.....16个&lt;br&gt;
因此每个码元带有4b的信息&lt;/p&gt;
&lt;h2 id=&#34;奈氏与香农&#34;&gt;奈氏与香农&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/08/00jecq.png&#34; alt=&#34;00jecq.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;基带信号与宽带信号&#34;&gt;基带信号与宽带信号&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/08/00vnGd.png&#34; alt=&#34;00vnGd.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;编码与调制&#34;&gt;编码与调制&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/08/00xYm6.png&#34; alt=&#34;00xYm6.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/09/0BOTN4.png&#34; alt=&#34;0BOTN4.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;电路交换报文交换分组交换&#34;&gt;电路交换,报文交换,分组交换&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/09/0BjBFg.png&#34; alt=&#34;0BjBFg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;数据报虚电路&#34;&gt;数据报,虚电路&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/09/0BxGrt.png&#34; alt=&#34;0BxGrt.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/09/0BxgaT.png&#34; alt=&#34;0BxgaT.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;传输介质&#34;&gt;传输介质&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/09/0rNchq.png&#34; alt=&#34;0rNchq.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/09/0rtJzT.png&#34; alt=&#34;0rtJzT.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/09/0rNSf0.png&#34; alt=&#34;0rNSf0.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/09/0rNdc8.png&#34; alt=&#34;0rNdc8.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;物理层设备&#34;&gt;物理层设备&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/09/0rdOg0.png&#34; alt=&#34;0rdOg0.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/09/0rwYqS.png&#34; alt=&#34;0rwYqS.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;物理层部分总结&#34;&gt;物理层部分总结&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/09/0rBH4H.png&#34; alt=&#34;0rBH4H.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">计算机网络 第二章 物理层</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/ying-yu-fan-yi-bi-ji/"" data-c="
          &lt;h2 id=&#34;1-一些单词的误译&#34;&gt;1 一些单词的误译&lt;/h2&gt;
&lt;p&gt;town:是城镇,而不是乡下&lt;/p&gt;
&lt;h2 id=&#34;2-常见的短语&#34;&gt;2 常见的短语&lt;/h2&gt;
&lt;p&gt;think about:一般开头作为祈使句时,想带读者进入虚拟场景,翻译成&lt;strong&gt;试想&lt;/strong&gt;&lt;br&gt;
twist and turn:曲曲弯弯,迂回曲折&lt;br&gt;
know...like the back of one&#39;s hand:对...十分熟悉,&lt;strong&gt;了如指掌&lt;/strong&gt;&lt;br&gt;
well-travelled:经常旅行的,去过很多地方的(指人),频繁经过的&lt;br&gt;
come to:偏口语化的表达,翻译时弱化或省去&lt;/p&gt;
&lt;h2 id=&#34;3-一些转折的连词&#34;&gt;3 一些转折的,连词&lt;/h2&gt;
&lt;p&gt;afterwards:以后,后来&lt;br&gt;
after all:毕竟,终究&lt;/p&gt;
">英语翻译笔记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/ji-suan-ji-wang-luo-di-yi-zhang-ti-mu-zheng-li/"" data-c="
          &lt;h2 id=&#34;1-概念部分&#34;&gt;1 概念部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;局域网接入广域网是通过路由器实现的&lt;/li&gt;
&lt;li&gt;附加信息开销大事分组交换网络的缺点&lt;/li&gt;
&lt;li&gt;计算机网络的拓扑结构主要取决于它的&lt;strong&gt;通信子网&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;城域网采用的技术与局域网相似,只是大一些&lt;/li&gt;
&lt;li&gt;局域网和广域网的差异:
&lt;ul&gt;
&lt;li&gt;覆盖范围不同&lt;/li&gt;
&lt;li&gt;使用的协议不同,局域网只要下两层就行,没有路由器&lt;/li&gt;
&lt;li&gt;采用的技术不同:局域网:广播技术,广域网:交换技术&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;没有特地强调通信容量的差别&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;计算机网络中的资源一定要选全,硬件软件都要包含&lt;/li&gt;
&lt;li&gt;计算机网络中可以没有数据库管理系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-参考模型部分&#34;&gt;2 参考模型部分&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;定义功能执行的方法&lt;/strong&gt;不是对网络模型进行分层的目标
&lt;ol&gt;
&lt;li&gt;注意:具体内部细节实现的都不属于体系结构中&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;因特网采用的核心技术是&lt;strong&gt;TCP/IP&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;集线器应用在物理层&lt;/li&gt;
&lt;li&gt;(☆)噪声使得传输链路上的一个0变成1,或1变0这样的差错&lt;strong&gt;发生在物理层&lt;/strong&gt;,&lt;strong&gt;纠正在数据链路层&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
">计算机网络 第一章 题目整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/ji-suan-ji-wang-luo-di-yi-zhang-ji-suan-ji-wang-luo-ti-xi-jie-gou/"" data-c="
          &lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/07/0aIHKA.png&#34; alt=&#34;0aIHKA.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/07/0dSf9s.png&#34; alt=&#34;0dSf9s.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-计算机网络概述&#34;&gt;1 计算机网络概述&lt;/h2&gt;
&lt;h3 id=&#34;1-计算机网络的概念&#34;&gt;1 计算机网络的概念&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/07/0aINBq.png&#34; alt=&#34;0aINBq.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
ISP:因特网服务提供商&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/07/0aIfUK.png&#34; alt=&#34;0aIfUK.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-组成功能分类&#34;&gt;2 组成,功能,分类&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/07/0aqyvD.png&#34; alt=&#34;0aqyvD.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;终端,服务器,工作站,共享的打印机等设备以及相关软件都属于资源子网&lt;/li&gt;
&lt;li&gt;网卡,线缆,路由器,网桥等都是通信子网&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-计算机网络的标准化工作及相关组织&#34;&gt;3 计算机网络的标准化工作及相关组织&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/07/0a7FhT.png&#34; alt=&#34;0a7FhT.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4-性能指标&#34;&gt;4 性能指标&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;速率&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/07/0a7I8U.png&#34; alt=&#34;0a7I8U.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注意:换算比例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;带宽&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;吞吐量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时延&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发送时延&lt;/li&gt;
&lt;li&gt;传播时延&lt;/li&gt;
&lt;li&gt;处理时延&lt;/li&gt;
&lt;li&gt;排队时延&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时延带宽积&lt;br&gt;
以比特为单位的链路长度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;往返时延RTT&lt;br&gt;
2*传播时延+题目给的其他的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信道利用率&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/07/0dCUNF.png&#34; alt=&#34;0dCUNF.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-osi七层模型tcpip模型&#34;&gt;2 OSI七层模型,TCP/IP模型&lt;/h2&gt;
&lt;h3 id=&#34;osi&#34;&gt;OSI&lt;/h3&gt;
&lt;h4 id=&#34;1-应用层&#34;&gt;1 应用层&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;用户与网络的界面,所有能和用户交互产生网络流量的程序&lt;/li&gt;
&lt;li&gt;协议:SMTP,FTP,HTTP&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;2-表示层&#34;&gt;2 表示层&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;主要处理在两个通信系统中交换信息的表示方式&lt;/li&gt;
&lt;li&gt;功能:
&lt;ol&gt;
&lt;li&gt;数据格式转化:01010001=&amp;gt;XXXX&lt;/li&gt;
&lt;li&gt;数据加解密&lt;/li&gt;
&lt;li&gt;数据压缩和恢复&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;主要协议:JPEG,ASCII&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;3-会话层&#34;&gt;3 会话层&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;向表示层实体/用户进程提供建立连接并在连接上有序地传输数据&lt;/li&gt;
&lt;li&gt;功能:
&lt;ol&gt;
&lt;li&gt;建立,管理,终止会话&lt;/li&gt;
&lt;li&gt;使用校验点使会话在通信失效时从校验点继续恢复通信,实现数据同步&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;协议:ADSP,ASP&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;4-传输层&#34;&gt;4 传输层&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;负责主机中两个&lt;strong&gt;进程间的&lt;/strong&gt;通信,即实现端到端的通信.传输单位是报文段或用户数据段.&lt;/li&gt;
&lt;li&gt;功能:
&lt;ol&gt;
&lt;li&gt;可靠传播,不可靠传播&lt;/li&gt;
&lt;li&gt;差错控制&lt;/li&gt;
&lt;li&gt;流量控制(速度时都匹配)&lt;/li&gt;
&lt;li&gt;复用分用
&lt;ol&gt;
&lt;li&gt;多个应用层进程同时使用传输层的服务&lt;/li&gt;
&lt;li&gt;传输层把收到的信息分别给应用层的相应进程&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;协议:TCP,UDP&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;5-网络层&#34;&gt;5 网络层&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;主要任务是把&lt;strong&gt;分组&lt;/strong&gt;从源端传到目的端,为分组交换网上的主机提供通信服务,传输单位是数据报&lt;/li&gt;
&lt;li&gt;功能:
&lt;ol&gt;
&lt;li&gt;路由选择(最佳路径)&lt;/li&gt;
&lt;li&gt;流量控制&lt;/li&gt;
&lt;li&gt;差错控制&lt;/li&gt;
&lt;li&gt;拥塞控制:拥塞状态:所有结点都来不及接受分组,而要丢弃大量分组的话,网络就处于拥塞状态&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;协议:IP,IPX,ICMP,IGMP,ARP,PARP,OSPF&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;6-数据链路层&#34;&gt;6 数据链路层&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;主要把网络层的数据报组装成帧&lt;/li&gt;
&lt;li&gt;功能:
&lt;ol&gt;
&lt;li&gt;成帧(定义帧的开始和结束)&lt;/li&gt;
&lt;li&gt;差错控制:帧错+位错&lt;/li&gt;
&lt;li&gt;流量控制&lt;/li&gt;
&lt;li&gt;访问(接入)控制:控制对信道的访问(广播式的网络中)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;协议:HDLC,SDLC,PPP,STP&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;7-物理层&#34;&gt;7 物理层&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;在物理媒体上实现比特流的&lt;strong&gt;透明传输&lt;/strong&gt;,传输单位是比特
&lt;ol&gt;
&lt;li&gt;透明传输:指不管所传数据是什么样的比特组合,都应当能在链路上传送&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;功能:
&lt;ol&gt;
&lt;li&gt;定义接口特性&lt;/li&gt;
&lt;li&gt;定义传输模式:单工,双工,半双工&lt;/li&gt;
&lt;li&gt;定义传输速率&lt;/li&gt;
&lt;li&gt;比特同步&lt;/li&gt;
&lt;li&gt;比特编码&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;协议:Rj45,802.3&lt;/li&gt;
&lt;li&gt;DCE/DTE[https://blog.csdn.net/kunkliu/article/details/79807673]&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;tcpip&#34;&gt;TCP/IP&lt;/h3&gt;
&lt;h4 id=&#34;概念&#34;&gt;概念&lt;/h4&gt;
&lt;h4 id=&#34;与osi相同&#34;&gt;与OSI相同&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;都分层&lt;/li&gt;
&lt;li&gt;都基于独立的协议栈的概念&lt;/li&gt;
&lt;li&gt;可以实现异构网络互联&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;与osi差异&#34;&gt;与OSI差异&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;OSI定义了:协议,接口,服务&lt;/li&gt;
&lt;li&gt;OSI先出现,参考模型先于协议发明,不偏向特定协议&lt;/li&gt;
&lt;li&gt;TCP/IP设计之初就考虑到异构网互联问题,将IP作为重要层次&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/08/0wTjje.png&#34; alt=&#34;0wTjje.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;五层参考模型&#34;&gt;五层参考模型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/08/0w7AgS.png&#34; alt=&#34;0w7AgS.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/08/0w7W5t.png&#34; alt=&#34;0w7W5t.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/08/0wHHSK.png&#34; alt=&#34;0wHHSK.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">计算机网络 第一章 计算机网络体系结构</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-san-zhang-nei-cun-guan-li-zhi-xu-ni-nei-cun-guan-li/"" data-c="
          &lt;h2 id=&#34;1-基本概念&#34;&gt;1 基本概念&lt;/h2&gt;
&lt;h3 id=&#34;总览&#34;&gt;总览&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/03/0329rn.png&#34; alt=&#34;0329rn.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;传统存储管理的特征&#34;&gt;传统存储管理的特征&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;一次性&lt;/li&gt;
&lt;li&gt;驻留性&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;局部性原理&#34;&gt;局部性原理&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;时间局部性原理&lt;/li&gt;
&lt;li&gt;空间局部性原理&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;虚拟存储器的定义和特征&#34;&gt;虚拟存储器的定义和特征&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;多次性&lt;/li&gt;
&lt;li&gt;对换性&lt;/li&gt;
&lt;li&gt;虚拟性&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;虚拟存储技术的实现&#34;&gt;虚拟存储技术的实现&lt;/h3&gt;
&lt;p&gt;需要的功能:请求调页(段)功能,页面置换功能&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;请求分页存储管理&lt;/li&gt;
&lt;li&gt;请求分段存储管理&lt;/li&gt;
&lt;li&gt;请求段页式存储管理&lt;br&gt;
注意前面传统的都叫&lt;strong&gt;基本XXXX&lt;/strong&gt;&lt;br&gt;
需要的支持:&lt;/li&gt;
&lt;li&gt;一定容量的内存和外存&lt;/li&gt;
&lt;li&gt;页表机制(或段表机制),作为主要数据结构&lt;/li&gt;
&lt;li&gt;中断机制&lt;/li&gt;
&lt;li&gt;地址变换机构&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;2-请求分页管理方式&#34;&gt;2 请求分页管理方式&lt;/h2&gt;
&lt;h3 id=&#34;1-页表机制&#34;&gt;1 页表机制&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/03/035VG6.png&#34; alt=&#34;035VG6.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-缺页中断机构&#34;&gt;2 缺页中断机构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/03/03omHH.png&#34; alt=&#34;03omHH.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/03/08pP1g.png&#34; alt=&#34;08pP1g.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-地址变换机构&#34;&gt;3 地址变换机构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/03/08pmNV.png&#34; alt=&#34;08pmNV.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/03/08pYAx.png&#34; alt=&#34;08pYAx.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/03/08pHU0.png&#34; alt=&#34;08pHU0.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/03/089A2D.png&#34; alt=&#34;089A2D.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注意:调页后还是再次查快表&lt;/p&gt;
&lt;h3 id=&#34;4-小结&#34;&gt;4 小结&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/03/08Cot0.png&#34; alt=&#34;08Cot0.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;3-页面置换算法&#34;&gt;3 页面置换算法&lt;/h2&gt;
&lt;h3 id=&#34;1-最佳opt置换算法&#34;&gt;1 最佳(OPT)置换算法&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0x9DdP&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0x9DdP.png&#34; alt=&#34;0x9DdP.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0x96JS&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0x96JS.png&#34; alt=&#34;0x96JS.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h3 id=&#34;2-先进先出fifo页面置换算法&#34;&gt;2 先进先出(FIFO)页面置换算法&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0xCQSg&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0xCQSg.png&#34; alt=&#34;0xCQSg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;p&gt;Belady异常:&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/0xC2tK&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0xC2tK.png&#34; alt=&#34;0xC2tK.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-最近最久未使用lru置换算法&#34;&gt;3 最近最久未使用(LRU)置换算法&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0xPSns&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0xPSns.png&#34; alt=&#34;0xPSns.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;算法的实现需要专门的硬件支持,性能好但是开销大,实现困难,性能是最接近最佳置换算法的&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;时钟clock置换算法&#34;&gt;时钟(CLOCK)置换算法&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0xeCf1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0xeCf1.png&#34; alt=&#34;0xeCf1.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h3 id=&#34;优化的clock&#34;&gt;优化的CLOCK&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0xuAXV&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0xuAXV.png&#34; alt=&#34;0xuAXV.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;自己的理解:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;(访问位,修改位):总是优先淘汰访问位是0的,修改位也是0的,也就是最近既未访问的也没有修改的&lt;br&gt;
优先淘汰未访问的显而易见,为何淘汰未修改的呢?&lt;br&gt;
因为修改过的淘汰了得往磁盘里写,产生I/O的开销,当然尽可能的先不淘汰它,如果你没修改丢了就丢了,也不用特地往磁盘写&lt;br&gt;
所以过程就是:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;扫描第一遍,淘汰(0,0)的,没有就继续第二遍,不用修改&lt;/li&gt;
&lt;li&gt;第一遍失败扫第二遍,淘汰(0,1)的(00没有,肯定没办法了,往磁盘写就往磁盘写吧,也得先淘汰最近没访问的).就这都还没的话(这时候肯定剩  (1,1)/(1,0) 这两种)就把扫过的访问位都改成0,下把肯定有(0,0)/(0,1)了&lt;/li&gt;
&lt;li&gt;第三遍肯定还是上来优先是(0,0)的,没有就说明只剩(0,1)了&lt;/li&gt;
&lt;li&gt;第四遍淘汰(0,1)的,这必然有了&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;也就是为了淘汰(0,0)的时候,啥也不用修改,为了淘汰(0,1)的时候,边扫边改访问位&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;五种算法的比较&#34;&gt;五种算法的比较&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0xQDj1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0xQDj1.png&#34; alt=&#34;0xQDj1.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h2 id=&#34;4-页面分配策略&#34;&gt;4 页面分配策略&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0xh2aq&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0xh2aq.png&#34; alt=&#34;0xh2aq.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0x4ItP&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0x4ItP.png&#34; alt=&#34;0x4ItP.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;p&gt;可变分配局部置换和可变分配全局置换的区别:&lt;br&gt;
局部的:物理块不够的时候,是从进程自己内部的物理块换出外存&lt;br&gt;
全局:不够的时候随便挑一个不一定是自己的进程里的换,也可能是拿别人的&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/0x51nH&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0x51nH.png&#34; alt=&#34;0x51nH.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;调入页面的时机&#34;&gt;调入页面的时机&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0xIebj&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0xIebj.png&#34; alt=&#34;0xIebj.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h3 id=&#34;何处调入页面&#34;&gt;何处调入页面&lt;/h3&gt;
&lt;h4 id=&#34;对换区足够&#34;&gt;对换区足够&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0xIvWV&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0xIvWV.png&#34; alt=&#34;0xIvWV.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;对换区不够&#34;&gt;对换区不够&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;15&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0xoVW6&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0xoVW6.png&#34; alt=&#34;0xoVW6.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h4 id=&#34;unix&#34;&gt;UNIX&lt;/h4&gt;
&lt;p&gt;&lt;a href=&#34;https://imgchr.com/i/0xILon&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0xILon.png&#34; alt=&#34;0xILon.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://imgchr.com/i/0xINZ9&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0xINZ9.png&#34; alt=&#34;0xINZ9.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;5-抖动&#34;&gt;5 抖动&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;16&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0x73xf&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0x73xf.png&#34; alt=&#34;0x73xf.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h2 id=&#34;6-工作集&#34;&gt;6 工作集&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;17&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0xzl7V&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0xzl7V.png&#34; alt=&#34;0xzl7V.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h2 id=&#34;小结&#34;&gt;小结&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;18&#34;&gt;&lt;a href=&#34;https://imgchr.com/i/0xzfBt&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/19/0xzfBt.png&#34; alt=&#34;0xzfBt.png&#34; loading=&#34;lazy&#34;&gt;&lt;/a&gt;&lt;/figure&gt;
&lt;h2 id=&#34;7-地址翻译&#34;&gt;7 地址翻译&lt;/h2&gt;
">第三章 内存管理之虚拟内存管理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-san-zhang-nei-cun-guan-li-ti-mu-ji-chong-dian/"" data-c="
          &lt;h2 id=&#34;1-概念&#34;&gt;1 概念&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;在虚拟内存管理中,地址板换机构将逻辑地址变换为物理地址,形成改逻辑地址的阶段为&lt;strong&gt;链接&lt;/strong&gt;,若是&amp;quot;完成该变化过程的阶段是&amp;quot;,则为装载&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/02/0l0JCq.png&#34; alt=&#34;0l0JCq.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/10/02/0l0kEd.png&#34; alt=&#34;0l0kEd.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;I/O操作时,进程不能交换出主存,但是如果有I/O缓冲则可以&lt;/li&gt;
&lt;li&gt;分区分配内存管理方式主要保护措施是界地址保护&lt;/li&gt;
&lt;li&gt;内存保护需要由操作系统和硬件机构完成&lt;/li&gt;
&lt;li&gt;单一连续存储管理和固定分区可以用覆盖技术&lt;/li&gt;
&lt;li&gt;紧凑技术就是拼接技术,采用拼接技术的目的是&lt;strong&gt;合并空闲区&lt;/strong&gt;,其实我觉得形式上也合并了分配区,这样才有了空闲的,手段是移动已用的部分,让空闲区得以合并,因此目的是合并空闲区&lt;/li&gt;
&lt;li&gt;动态重定位虽说是装入的手段,但是如果问是啥时候发生的,应该是&lt;strong&gt;运行时&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;固定分区可采用静态重定位,可变(动态)分区,页式和段式都不可以,页式段式显然不可以,动态分配是因为其中会使用交换技术&lt;/li&gt;
&lt;li&gt;由于分页和分段管理中页表和段表也占用物理空间,因此提供给用户的物理空间不知道&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;页面是为操作系统所感知的,用户,编译系统,连接装配程序都是上层应用,均不可感知,不要看到装配就是感觉很底层,相对操作系统还是高层&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;整个系统只设置一个重定位寄存器,运行的只会是一个进程,因此多的也没啥用,切换进程后重置寄存器即可&lt;/li&gt;
&lt;li&gt;分段是用户编程(或者说编译器完成的,总之是上层)时,按逻辑将程序划段&lt;/li&gt;
&lt;li&gt;程序的动态链接是和程序的逻辑结构有关的,而采用分段管理是按逻辑将程序分段,因此有利于程序的动态链接&lt;/li&gt;
&lt;li&gt;分区管理虽说利用率可能不高,但是代价小,没哟额外数据结构支持(段表,页表啥的),因为简单&lt;/li&gt;
&lt;li&gt;对外存对换区的管理以&lt;strong&gt;提高换入,换出速度&lt;/strong&gt;为主要目标,注意是对他的管理,而他自身目的肯定是提高存储空间利用率,因为换出换入很消耗处理机的时间,故而对其管理是为了节约时间成本&lt;/li&gt;
&lt;li&gt;注意问的是对内存的访问还是分配,如果是对内存的访问,是以字节或字为单位的,如果是对内存的分配是根据系统来的&lt;/li&gt;
&lt;li&gt;把作业空间中使用的逻辑地址变为内存中的物理地址称为&lt;strong&gt;重定位&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;注意分页管理的越界判断只有页号和页表长度的比较,而分段管理越界判断是两部分:段号和段表长度,偏移量和段长的比较&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;是否产生碎片&#34;&gt;是否产生碎片&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;通俗讲:内部碎片就是已经被分配出去（能明确指出属于哪个进程）却不能被利用的内存空间；外部碎片指的是还没有被分配出去（不属于任何进程），但由于太小了无法分配给申请内存空间的新进程的内存空闲区域。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分段式管理没有内部碎片,但是有外部碎片&lt;br&gt;
分页式管理有内部碎片,无外部碎片&lt;br&gt;
固定分区管理有内部碎片,无外部碎片&lt;br&gt;
动态无内部碎片,有外部碎片&lt;br&gt;
段页式管理有内部碎片,也有外部碎片&lt;/p&gt;
&lt;h3 id=&#34;地址结构&#34;&gt;地址结构&lt;/h3&gt;
&lt;p&gt;页式管理中的地址空间是一维的,给了一个整数(逻辑地址),就可以用整除和取余来找到对应的物理地址&lt;br&gt;
段式管理是二维的,一个数,你没办法通过什么办法得到段号和偏移量,即便说定了32位,前多少是段号,后面是偏移量,这也是二维的,而对于页式的地址虽说计算机实际使用的时候是前多少是页号,后面的是偏移量,可以直接得到实际物理地址,但这只是为了快点访问的,如果只是一个数,也可通过整除取余等操作找到,因此是一维的&lt;/p&gt;
">第三章 内存管理题目及重点</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/yue-du-de-yi-xie-si-lu/"" data-c="
          &lt;ol&gt;
&lt;li&gt;说XX失去XX或承担XX,一定要看清程度,或者是不是明确说了,可能前面有一些句子,别人说啊或者什么的&lt;/li&gt;
&lt;li&gt;取标题的&lt;strong&gt;不要&lt;/strong&gt;被最后一段作者升华的部分影响了,除非是全篇都有这个意味&lt;/li&gt;
&lt;/ol&gt;
">阅读的一些思路</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/zuo-ti-ci-hui-ji-lei-冲突-宋宇航_Win10/"" data-c="
          &lt;h2 id=&#34;超高频&#34;&gt;超高频&lt;/h2&gt;
&lt;p&gt;overwhelmingly:压倒性地,不可抵抗地&lt;br&gt;
recession&lt;br&gt;
prospect:前景,可能性,机会,希望&lt;br&gt;
exclude:排除在外的&lt;br&gt;
deny:否认&lt;br&gt;
statistically:统计地&lt;br&gt;
strikingly:惹人注目地&lt;br&gt;
descent:体面的&lt;br&gt;
engagement:&lt;strong&gt;参与度&lt;/strong&gt;订婚;订婚期间;(尤指正式的或与工作有关的)约定，约会，预约;战斗;交战&lt;br&gt;
disengage:脱离,不再感兴趣&lt;br&gt;
legacy:遗产&lt;br&gt;
ethos:精神特质,理念&lt;br&gt;
decline:抗拒&lt;br&gt;
squeeze:v.挤压;捏;(从某物中)榨出，挤出，拧出;(使)挤入;挤过;塞入n.挤压;捏;榨出的液体;小量挤出的汁;挤;塞&lt;br&gt;
supervise:监督&lt;br&gt;
exquisitely:精致地&lt;br&gt;
bid:努力,企图,争取&lt;br&gt;
perpetuate:使永久化,使持续&lt;br&gt;
misleading:误导,误人子弟&lt;br&gt;
prone:易于发生某事的,很有可能的&lt;br&gt;
budget:预算&lt;br&gt;
infrastructure:基础设施&lt;br&gt;
hazard:危险隐患&lt;br&gt;
landscape:地形,地貌&lt;br&gt;
corresponding:相应的,由此引起的&lt;br&gt;
equation:影响因素,综合体&lt;br&gt;
perspective:角度&lt;br&gt;
perception:认识,观念,看法&lt;br&gt;
interaction:相互作用,相互影响&lt;br&gt;
unleash:发泄,突然释放,使爆发&lt;br&gt;
unprecedented:空前的,史无前例的&lt;br&gt;
stiff:激烈的,严厉的&lt;br&gt;
--prone:有做...的倾向,易于遭受...的&lt;br&gt;
inclined:有..的倾向&lt;br&gt;
assessment:评价,评估&lt;br&gt;
prosocial:亲社会的,忠实于既定社会道德准则的&lt;br&gt;
appease:安抚,抚慰&lt;br&gt;
moral:道德的&lt;br&gt;
revival:复苏,复兴&lt;br&gt;
evolve:进化&lt;br&gt;
make up for:补偿&lt;br&gt;
deficiency:缺乏&lt;br&gt;
outcome:结果&lt;br&gt;
impulse:冲动&lt;br&gt;
rein:遏制&lt;br&gt;
anonymous:匿名的&lt;/p&gt;
&lt;h2 id=&#34;倒序17年开始&#34;&gt;倒序17年开始&lt;/h2&gt;
&lt;p&gt;norms:规范行为标准&lt;br&gt;
turn on sth:依靠取决于&lt;br&gt;
transgression:越轨,违背道德的&lt;br&gt;
vice versa:反之亦然&lt;br&gt;
shortfall:差额,不足&lt;/p&gt;
&lt;p&gt;pluck:拖,拉扯&lt;br&gt;
add up to:结果是&lt;br&gt;
outsourcing:外包&lt;/p&gt;
&lt;p&gt;upkeep:保养修护&lt;br&gt;
at the expense of:以...为代价&lt;br&gt;
tease:&lt;strong&gt;梳理&lt;/strong&gt;,挑逗&lt;br&gt;
do away with:终结&lt;br&gt;
come to terms with:与之妥协&lt;br&gt;
expenditure:开支,支出&lt;br&gt;
magnifying glass:放大镜&lt;/p&gt;
&lt;p&gt;lucrative:获利多的,赚大钱的&lt;br&gt;
acclimation:适应&lt;br&gt;
blunder:愚蠢错误&lt;br&gt;
blow:冲击&lt;br&gt;
mandatory:强制的,法定的,义务的&lt;br&gt;
inherent:内在的,固有的&lt;br&gt;
make up:补上&lt;br&gt;
be wired to:天生就会&lt;br&gt;
tablet:平板电脑&lt;br&gt;
maximal:最大的,最高的&lt;br&gt;
bleed-over:渗透,渗开&lt;br&gt;
staff:为...配备工作人员&lt;br&gt;
set off:启程出发&lt;br&gt;
pledge:发誓,保证&lt;br&gt;
lever:撬动&lt;br&gt;
fit:健壮的&lt;br&gt;
retrospection:回想,反思&lt;br&gt;
in the run-up to sth:重要事件前夕&lt;br&gt;
as to sth:关于&lt;br&gt;
shine:干的出色,出类拔萃&lt;br&gt;
bidder:投标人:Olympic~:奥运申办者&lt;br&gt;
dual:双重的&lt;br&gt;
intimidating:令人胆怯的&lt;br&gt;
puffed-out:气喘吁吁的,生气不接下气的&lt;br&gt;
stress on A over B:强调A胜过B&lt;br&gt;
time trial:计时赛&lt;br&gt;
first timer:第一次参赛的&lt;br&gt;
grassroots:pl.基层民众,草根&lt;br&gt;
successive:连续的&lt;br&gt;
wordyL冗长的&lt;br&gt;
preside over:主持,掌管&lt;/p&gt;
&lt;h2 id=&#34;10年开始的&#34;&gt;10年开始的&lt;/h2&gt;
&lt;p&gt;tropical:热带的&lt;br&gt;
soap habbit:用肥皂洗手的习惯;&lt;strong&gt;类似的组合词学会结合上下文翻译&lt;/strong&gt;&lt;br&gt;
wipe:抹,擦&lt;br&gt;
counter:柜台&lt;br&gt;
cue:暗示,提示&lt;br&gt;
turn to:求助于&lt;br&gt;
subtle:微妙的&lt;br&gt;
invest ... doing sth:投入...做某事&lt;br&gt;
routine:惯例&lt;br&gt;
shrewd:精明的&lt;br&gt;
scrub:n.擦洗&lt;br&gt;
sip:小口地喝&lt;br&gt;
primarily:首先地&lt;br&gt;
ritual:仪式&lt;br&gt;
viable:可行的&lt;br&gt;
ruthless:无情残忍的&lt;br&gt;
controversies...erupted:辩论争论爆发&lt;br&gt;
exempt....from...使...:免除豁免&lt;br&gt;
peer:同龄,同等地位的人;v.仔细看,端详&lt;br&gt;
ideal:理想&lt;br&gt;
landmark:里程碑&lt;br&gt;
unconstitutional:不符合宪法的&lt;br&gt;
discrimination:歧视&lt;br&gt;
antidiscrimination:反歧视&lt;br&gt;
usher:引导,~ sth in:开创,开启&lt;br&gt;
supposedly:据说,据传&lt;br&gt;
intentional:有意的,故意的&lt;br&gt;
blue-ribbon:一流头等的&lt;br&gt;
trumpet:v.大声宣告,大肆宣扬,吹嘘&lt;br&gt;
respectively:ad.分别地&lt;br&gt;
lightweight:a.比通常重量轻的&lt;br&gt;
composite:a.合成的,混合的,复合的;n.合成物,混合物,复合物&lt;br&gt;
make a difference:有作用,有影响&lt;br&gt;
naturalistic:自然的&lt;br&gt;
propel:推进&lt;br&gt;
substantially:ad.实质上,大体上&lt;br&gt;
unsubstantiated:未经证实的&lt;br&gt;
inverted:倒转的&lt;br&gt;
proceed:v.继续前进&lt;br&gt;
process:进程&lt;br&gt;
procedure:程序&lt;br&gt;
favorable:有利的,赞许的,令人愉快的,讨人喜欢的&lt;br&gt;
cruise:(汽车飞机等)以平稳速度行驶&lt;br&gt;
portion:部分&lt;br&gt;
perception:察觉,感知,洞察力,知觉&lt;br&gt;
nautical:航海的&lt;br&gt;
intimate:亲近的&lt;br&gt;
regulation:规定&lt;br&gt;
aviation:航空&lt;br&gt;
wake:航空轨迹&lt;br&gt;
diminish:变小,减小&lt;br&gt;
investigate:调查&lt;br&gt;
under fire:收到批评和攻击&lt;br&gt;
compensation:报酬薪水&lt;br&gt;
bonus payout:奖金支出&lt;br&gt;
presumably:ad.据推测,大概,可能&lt;br&gt;
weather:v.平安度过(难关),挨过,经受住&lt;br&gt;
a firm&#39;s board:公司董事会&lt;br&gt;
make one&#39;s wealth and reputations:功成名就&lt;br&gt;
executive:主管&lt;br&gt;
proxy:代表权,委托书&lt;br&gt;
subsequently:ad.其后,随后,接着&lt;br&gt;
restate:v.重申,重新申报:restate earnings:重申盈利&lt;br&gt;
depart a board:从董事会离职&lt;br&gt;
federal class-action lawsuit:联邦集体诉讼&lt;br&gt;
jump off a sinking ship:跳离沉船&lt;br&gt;
blow:打击,意外的灾害,摧毁&lt;br&gt;
incentive:动机,鼓励,刺激&lt;br&gt;
a blow to the reputations:有损名誉&lt;br&gt;
recession:n.经济衰退/萎缩,不景气&lt;br&gt;
chronicle:记录(大事)&lt;br&gt;
chronic:慢性的,长期的,习惯性的&lt;br&gt;
devaluation:(货币)贬值&lt;br&gt;
subsidize:v.以津贴补助&lt;br&gt;
inhabit:v.居住,在....出现,填满&lt;br&gt;
routine:常规,通常情况&lt;br&gt;
shrug off:对...满不在乎,不屑一顾&lt;br&gt;
afloat:ad.漂流着的,漂浮不定:stay ~:维持运营&lt;br&gt;
overboard:ad.越过船边坠入水中:push sth/sb overboard:抛弃,甩掉某人/某事&lt;br&gt;
whirlwind:旋风,猛烈的势力&lt;br&gt;
distinctive:有特色的,与众不同的&lt;br&gt;
savagely:野蛮地,残忍地,粗野地&lt;br&gt;
line up:排队&lt;br&gt;
common sense:常识&lt;br&gt;
stylish:时髦的,流行的,入时的&lt;br&gt;
take up posts:就职&lt;br&gt;
stimulus:刺激物,刺激因素&lt;br&gt;
exert:发挥,运用,使受(影响)&lt;br&gt;
signature:签名,署名,识别标志,鲜明特征:~ phrase:口头禅&lt;br&gt;
derive from:由...起源,取自&lt;br&gt;
laminated:由薄片叠成的,分层的&lt;br&gt;
symbolize:象征,用符号表现&lt;br&gt;
sophisticated:复杂的,精致的&lt;br&gt;
take for granted:认为...理所当然&lt;br&gt;
mask the fact:掩盖事实&lt;br&gt;
modest:适度的,适中的,端庄的&lt;br&gt;
desirable:令人满意的,可取的&lt;br&gt;
inevitable:不可避免的,必然发生的&lt;br&gt;
forthright:直率的,明确的&lt;br&gt;
disintegration:瓦解,崩溃&lt;br&gt;
stuck:动不了,被卡主的,被难住的&lt;br&gt;
dominant:占优势的,统治的,支配的,首要的&lt;br&gt;
harmonisation:和谐,协调,相称&lt;br&gt;
quasi-automatic:半自动的,准自动的&lt;br&gt;
mega:巨大的,极佳的&lt;br&gt;
suspension:悬挂,暂停&lt;br&gt;
rigour:严苛,严酷&lt;br&gt;
backed by:依靠,在...支持下&lt;br&gt;
intervene:介于..之间,干预,介入:~ in介入,干预&lt;br&gt;
murmur:咕哝,发牢骚,私下抱怨&lt;br&gt;
curb:制止,束缚,限制,抑制&lt;br&gt;
remarkably:引人注目地,明显地&lt;br&gt;
liberal:开明的,自由的&lt;br&gt;
blunt:使迟钝&lt;br&gt;
write off:认定...不重要/无用/无可救药&lt;br&gt;
weigh in:参加,加入(争论等)&lt;br&gt;
spiral:盘旋上升(或下降),(物价等)不断急剧上升(或下降)&lt;br&gt;
excessive:过度的,极度的,非常的&lt;br&gt;
inconceivable:不能想象的,不可思议的,难以置信的&lt;br&gt;
in respect of:关于,涉及&lt;br&gt;
inducement:诱导,诱惑,诱因&lt;br&gt;
lure:吸引,引诱&lt;br&gt;
up front:预先,在前面&lt;br&gt;
takeaway:外卖食品,外卖店&lt;br&gt;
centerpiece:最重要的项目(或物品)&lt;br&gt;
set out:陈述,列述&lt;br&gt;
deploy:展开,施展,部署&lt;br&gt;
abbreviation:缩写词,缩写形式&lt;br&gt;
article:文章,(成套的)五篇,物件,条款&lt;br&gt;
mindless:无头脑的,盲目的,无谓的&lt;br&gt;
tear away from ...:依依不舍离开..&lt;br&gt;
foxhole:散兵坑&lt;br&gt;
stick it/sth out:坚持到底,忍受下去&lt;br&gt;
up against:必须面对某人/某事&lt;br&gt;
hand out:分发&lt;br&gt;
turn over:移交,交托&lt;br&gt;
pass down:遗传,继承&lt;br&gt;
cover:报道的意思一定记住啊,经常用&lt;br&gt;
portray:扮演某角色&lt;br&gt;
civilization:文明,文明社会:注意和urbanization(城市化)区别开,总记错&lt;br&gt;
colony:殖民地,群体&lt;br&gt;
parallel:除了有平行,还有&lt;strong&gt;相似的意思啊注意注意&lt;/strong&gt;&lt;br&gt;
counteracted:抵消,中和&lt;br&gt;
duplicate:重复,复制&lt;br&gt;
duplex:双工&lt;br&gt;
disguised:伪装的,掩饰的&lt;br&gt;
disturbed:坎坷的,不幸的&lt;br&gt;
disputed:争论的,有争议的&lt;br&gt;
distinguished:卓越的,杰出的&lt;br&gt;
from the outset:从开始时&lt;br&gt;
revise:修正,改变&lt;br&gt;
ritual:惯例,老规矩,例行公事&lt;br&gt;
mandate:命令指示&lt;br&gt;
interpretation:n.理解;解释;说明;演绎;演奏方式;表演方式&lt;br&gt;
pastel:(色彩)淡的,柔和的&lt;br&gt;
dominant:adj.首要的;占支配地位的;占优势的;显著的;(基因)显性的，优势的n.[生]显性性状;显性基因;优势物种;[乐]全阶第五音;主因;要素&lt;br&gt;
come into its own:显示出用处&lt;br&gt;
across-the-board:一刀切的&lt;br&gt;
thorny:棘手的&lt;br&gt;
look into:调查&lt;br&gt;
put on hold:搁置,暂缓&lt;br&gt;
dictate:控制,支配,口述,...听写的动词&lt;br&gt;
consel:建议&lt;br&gt;
stepping stone:垫脚石,踏板&lt;br&gt;
pervasive:普遍的,无处不在的&lt;br&gt;
intrinsically:ad.从本质上(讲)&lt;br&gt;
singular:如初的,非凡的&lt;br&gt;
fuse .. to ..:把..和..熔合在一起&lt;br&gt;
be obsessed with:痴迷于&lt;br&gt;
domestic:adj.本国的;国内的;家用的;家庭的;家务的;喜爱家庭生活的;享受家庭乐趣的;乐于操持家务的n.家佣;佣人;家庭纠纷;家庭矛盾&lt;br&gt;
violently:激烈地,强烈地&lt;br&gt;
agitated:紧张不安的,焦虑的&lt;br&gt;
preliminary:初步的,预备的&lt;br&gt;
federal judge:联邦法官&lt;br&gt;
shake...to its core:彻底震惊&lt;br&gt;
suppress:压制,镇压,制止&lt;br&gt;
make arguments against:提出反对...的理由&lt;br&gt;
innovation:创新&lt;br&gt;
violate:侵犯,干扰&lt;br&gt;
session:(一系列会议中的一次)会议&lt;br&gt;
landscape:景色,形势&lt;br&gt;
packed:挤满人的,非常拥挤的&lt;br&gt;
alike:adv.同样都(用于强调刚刚提及的两者)&lt;br&gt;
over turn:使倾覆,打翻&lt;br&gt;
national polls:国内民意调查&lt;br&gt;
social fabric:社会结构&lt;br&gt;
discern:识别,看清,领悟&lt;br&gt;
resentment:怨气,怨恨,不满&lt;br&gt;
shrink:(使)缩小/收缩&lt;br&gt;
reinforce:加强,强化....&lt;strong&gt;不要老是记成限制(restrain)啊&lt;/strong&gt;&lt;br&gt;
lengthy:长时间的,过长的&lt;br&gt;
mean-spirited:心胸狭隘的&lt;br&gt;
inclusive:包容的&lt;br&gt;
sentiment:观点感想意见&lt;br&gt;
far off:遥远&lt;br&gt;
reckless:鲁莽轻率不顾后果的&lt;br&gt;
exemplary:模范的&lt;br&gt;
lining:n.衬层;内衬;衬里;(身体器官内壁的)膜v.(用…)做衬里;(在某物的内部)形成一层;沿…形成行(或列、排)&lt;br&gt;
rambling:讲话或文章杂乱无章的&lt;br&gt;
champion:除了冠军,还有捍卫维护的意思&lt;br&gt;
cunning:n.狡猾狡诈&lt;br&gt;
ruthlessness:无情冷酷&lt;br&gt;
furnish:v.提供,供应&lt;br&gt;
resolute:坚决的,坚定的&lt;br&gt;
steadfast:忠诚的,坚贞不渝的&lt;br&gt;
integrity:n.诚实正直;完整;完好&lt;br&gt;
beacon:引路人,指路明灯&lt;br&gt;
bourgeois:过分追求名利的,注意物质享受的;市侩的,庸俗的&lt;br&gt;
epochal:具有时代意义的&lt;br&gt;
bombast:空洞华丽的(言论)&lt;br&gt;
hitherto:ad.迄今,至今&lt;br&gt;
nurture:v.培养培育&lt;br&gt;
unpick:v.拆去针脚,撬开,引申为分析研究&lt;br&gt;
multiplicity:多样性&lt;br&gt;
downstairs:底层(阶级)&lt;br&gt;
upstairs:上层(阶级)&lt;br&gt;
fruition:n.(计划、过程或活动的)完成，实现，取得成果:come to fruition:完成实现&lt;br&gt;
revolutionize:v.彻底改革,彻底变革&lt;br&gt;
steady:稳定的,持续的&lt;br&gt;
telecommunication:电磁通信,远距离通信&lt;br&gt;
receipt:收据收条&lt;br&gt;
unauthorized:未被授权的,未经认可的&lt;br&gt;
fraud:欺诈,欺骗&lt;br&gt;
chunk:厚块,大块&lt;br&gt;
trail:踪迹,痕迹&lt;br&gt;
stubbornly:顽固地,倔强地&lt;br&gt;
make the point:表明观点&lt;br&gt;
automate:自动化&lt;br&gt;
relate:除了关联之外还有讲述叙述的意思&lt;br&gt;
look to do sh:寻找机会做某事&lt;br&gt;
for good:永久地,永远地,一劳永逸地&lt;br&gt;
birds of passage:候鸟,漂泊的人&lt;br&gt;
affectionate:深情的,充满深情的&lt;br&gt;
rigid:严格的,僵硬的死板的&lt;br&gt;
brand:打烙印于,印商标于&lt;br&gt;
paralysis:n.麻痹,无力,停顿(活动工作能力)完全丧失,瘫痪&lt;br&gt;
look beyond:超越...看问题&lt;br&gt;
in the making:在酝酿中,在形成中&lt;br&gt;
kick out:踢出&lt;br&gt;
hail ..as...:将..誉为...&lt;br&gt;
mightily:很,非常ad&lt;br&gt;
straddle:跨立于,跨越&lt;br&gt;
jurisdiction:管辖范围&lt;br&gt;
commit oneself to sth/doing sth:承诺&lt;br&gt;
in motion:在运动中的&lt;br&gt;
prone:有..倾向的,易于倾向于&lt;br&gt;
snap:仓促的,匆忙的,注意与nap(小憩)的区别&lt;br&gt;
hard-wired:(计算机系统中)硬件控制的,硬连线的,固有的,天生的(innate):be hard-wired to do sth:天生会做某事&lt;br&gt;
mechanism:机制&lt;br&gt;
assess:评估(哎,千万别忘了啊)&lt;br&gt;
preferably:ad.较好,更适宜&lt;br&gt;
sociable:好交际的,合群的,友好的&lt;br&gt;
stimuli:n.刺激(stimulus的复数)&lt;br&gt;
exclusive:独有的,独占的,专有的:be exclusive to:专为...独享&lt;br&gt;
prime:v.使准备好:prime sb to do sth:使某人准备好应付某种情况&lt;br&gt;
interpersonal:人际关系的,&lt;br&gt;
reverse:颠倒,逆转&lt;br&gt;
ground:v.使接触地面.打基础&lt;br&gt;
retreat:僻静处,隐居处,休息寓所&lt;br&gt;
mute:减弱...的声音,使...柔和(可以引申为控制,抑制)&lt;br&gt;
contemplate:沉思,深思熟虑,冥思苦想&lt;br&gt;
revitalize:使得到复兴&lt;br&gt;
weave:使组合,使交织&lt;br&gt;
paraphrase:意译,改述&lt;br&gt;
by virtue of:由于,因为&lt;br&gt;
disperse:使分散&lt;br&gt;
intervene:干预&lt;br&gt;
alternative:n.(两者或以上)择一&lt;br&gt;
deploy:利用&lt;br&gt;
profile:n.面部的侧影;侧面轮廓;概述;简介;传略;印象;形象v.扼要介绍;概述;写简介&lt;br&gt;
high-profile:高调的,备受瞩目的&lt;br&gt;
convert:除了动词转换转变还有名词:皈依者,改变信念的人&lt;br&gt;
indulgence:n.放纵溺爱&lt;br&gt;
momentum:势头声势&lt;br&gt;
coalition:联合联盟&lt;br&gt;
shave off:减少,剃掉&lt;br&gt;
skate by:轻松通过&lt;br&gt;
testimonial:推荐信,证明书&lt;br&gt;
curricular:课程的,extracurricular:课外的&lt;br&gt;
level:还有动词使平等的意思&lt;br&gt;
level the playing field:创造公平的竞争环境&lt;br&gt;
unveil:公布,为...揭幕&lt;br&gt;
speculative:猜测性的,投机的&lt;br&gt;
rigor:严格&lt;br&gt;
resistence:阻力,抵抗力&lt;br&gt;
demonstrate:[ˈdemənstreɪt] v.证明;证实;论证;说明;表达;表露;表现;显露;示范;演示&lt;br&gt;
compelling:英 [kəmˈpelɪŋ] 美 [kəmˈpelɪŋ]adj.引人入胜的;扣人心弦的;非常强烈的;不可抗拒的;令人信服的v.强迫;迫使;使必须;引起(反应)&lt;br&gt;
the best bits of:最好的部分&lt;br&gt;
come into force:生效,开始实施&lt;br&gt;
flaw:缺点,瑕疵&lt;br&gt;
premise:n.前提,假定&lt;br&gt;
levy:n.征收&lt;br&gt;
fine:罚款&lt;br&gt;
regulate:监管.self-regulatory:自我监管的&lt;br&gt;
spray around:分散,喷洒&lt;br&gt;
leak:泄露渗漏&lt;br&gt;
harmonise:使和谐&lt;br&gt;
embroil::v使卷入,使混乱&lt;br&gt;
template:模板样板&lt;br&gt;
overarching:包罗万象的&lt;br&gt;
dominoes[&#39;dominouz]n.多米诺骨牌（PlL1）&lt;br&gt;
slap on the wrist 象征性惩罚（P1L1）&lt;br&gt;
show the door 开除，扫地出门（P1L2）&lt;br&gt;
insensitive[in&#39;senstiv]a.缺乏同情心的,不敏感的（P1L3）&lt;br&gt;
misconduct[imis&#39;kondakt]n.不端行为（PlL4）&lt;br&gt;
integrity[un&#39;tegrtu]n.正直；诚实（P2L1）&lt;br&gt;
pragmatic[preg&#39;maetik]a.实用主义的（P21L3）&lt;br&gt;
course of action做法，行动步骤（P2L3）&lt;br&gt;
overlook A for the sake of B:为B忽略A（P3L2）&lt;br&gt;
ethical lapse 道德败坏，道德堕落（P3L3）&lt;br&gt;
accountable[a&#39;kauntobl]a.有责任的，负责的（P315）&lt;br&gt;
fallout[folaut]n.（尤指预料不到的）影响，结果&lt;br&gt;
harshly[ha:fu]ad.严厉地；严酷的（P5L1）&lt;br&gt;
toxic[&#39;toksik]a.有毒的；中毒的（P5L2）&lt;br&gt;
one-off[iwan&#39;of]n.一次性事物（P6L2）&lt;br&gt;
paper over 隐瞒（有争议或使人不愉快之事）&lt;br&gt;
bigwig[&#39;brgwrg]n.有重大影响的人（P1L3）&lt;br&gt;
gung-ho[&#39;gag&#39;hou]a.非常急切的（P7L1）&lt;br&gt;
errant:犯错误的;行为不当的;出格的;对配偶不忠的&lt;br&gt;
accountable:负责的&lt;br&gt;
inclusive:adj.包含全部费用;包括所提到的费用在内;包括提到的所有的天数(或月、数目等)在内;包容广阔的;范围广泛的&lt;br&gt;
fallout:后果,余波&lt;br&gt;
wicked:adj.邪恶的;缺德的;淘气的;调皮的;恶作剧的;危险的;有害的;强大的n恶人;邪恶的人&lt;br&gt;
revolutionise[.revallufanalz]v.彻底改变，使彻底变革&lt;br&gt;
star-up[&#39;statAp]n.初创公司&lt;br&gt;
gig worker零工，临时工（P2L1）&lt;br&gt;
reimagine[ria&#39;maedsin]v.重新构想&lt;br&gt;
benefit[&#39;benift]n.福利，补贴&lt;br&gt;
weather[&#39;we0].经受住，平安度过&lt;br&gt;
ensuing[in&#39;sjug]a.随后的&lt;br&gt;
select[silekt]a.精选的，挑选出的&lt;br&gt;
emerging[I&#39;msxd31g]a.新兴的，新出现的&lt;br&gt;
compromise[&#39;kompromalz]v.妥协，让步&lt;br&gt;
step in介入，干预（P3L1）&lt;br&gt;
on one&#39;s own terms按照某人自己的意愿&lt;br&gt;
climate[&#39;klatmt]n.氛围，形势&lt;br&gt;
opening[&#39;oupanig]n.机遇，良机&lt;br&gt;
tailor:定做，根据需要制作&lt;br&gt;
aggregate[egrg]a.总计的，合计的&lt;br&gt;
intermittent[inta&#39;mutant]a.断断续续的，间歇的&lt;br&gt;
trigger:n.(枪的)扳机;(尤指引发不良反应或发展的)起因，诱因;触发器;引爆器v.发动;引起;触发;开动;起动&lt;br&gt;
dignity:n.庄重;庄严;尊严;尊贵;高贵;高尚;自豪;自尊;自重&lt;br&gt;
rational[&#39;refnol]a.理性的；合理的（P3L1）&lt;br&gt;
fosil[&#39;fosl]n.化石（P513）&lt;br&gt;
auction[&#39;o.kJn]n.竞卖，拍卖（P3L4）&lt;br&gt;
shake off摆脱（P6L5）&lt;br&gt;
scheme[skim]n.（造福他人的）计划，方案（P3L4）&lt;br&gt;
onshore[&#39;on/]n.陆上的，朝岸的（P4L3）&lt;br&gt;
muster[&#39;masta]v.鼓起（勇气），积聚（信心），争取支持&lt;br&gt;
curb[katb]v.控制，抑制，束缚&lt;br&gt;
ideological[iaidia&#39;lodglkl]a.思想上的，意识形态&lt;br&gt;
shuter[Uata]u.便停止运行，关闭；装百页窗&lt;br&gt;
press ahead推进，加紧进行&lt;br&gt;
fury[&#39;fjuori]n.狂怒，暴怒&lt;br&gt;
infrastructure[nfrstraktfar]n.基础设施，基础&lt;br&gt;
arbitrary::任意的,专断的&lt;br&gt;
opaque:不透明的&lt;br&gt;
meritocracy:精英领导体制&lt;br&gt;
vice:副的&lt;br&gt;
evade:逃避&lt;br&gt;
summit:最高阶层,顶点&lt;br&gt;
overwhelmingly:压倒性地,不可抵抗地&lt;br&gt;
run counter to:与...背道而驰&lt;br&gt;
anonymity:匿名,不知名&lt;br&gt;
chiller:冷却装置&lt;br&gt;
greengrocer:蔬菜水果商&lt;br&gt;
come in handy:派的上用场&lt;br&gt;
on a budget:避免不必要的开支,节省费用&lt;br&gt;
burn out:出故障,烧尽,熄灭,精疲力尽&lt;br&gt;
chronicle:按事件发展顺序记载&lt;br&gt;
council flat:公营公寓(感觉是廉租房类似的)&lt;br&gt;
impulsive:冲动的,任性的&lt;br&gt;
ingredient:原料,材料,食材&lt;br&gt;
extra:额外的&lt;br&gt;
exact:精确的&lt;br&gt;
peasant:农民&lt;br&gt;
leftover:残羹剩饭&lt;br&gt;
stock:高汤&lt;br&gt;
surplus:过剩的,剩余的&lt;br&gt;
frugal:节俭的,朴素的&lt;br&gt;
deli:熟食店&lt;br&gt;
knuckle:关节骨&lt;br&gt;
carcass:尸体,兽体&lt;br&gt;
collegiate:学院的,学院学生的&lt;br&gt;
moderately:适度地,不过分地&lt;br&gt;
in turn:转而,相应的&lt;br&gt;
conservative:传统的,保守的&lt;br&gt;
in essence:本质上的,实质上的&lt;br&gt;
disgrace:耻辱,丢脸的事,出丑&lt;br&gt;
harbor:心怀,怀有(某种想法)&lt;br&gt;
stimulate:促进,刺激&lt;br&gt;
institute:开始(某进程),建立制定&lt;br&gt;
initiative:新倡议,行动方案&lt;br&gt;
obsolete:过时&lt;br&gt;
obsession:痴迷,着迷,注意和上一个区别&lt;br&gt;
rarity:稀缺,缺少&lt;br&gt;
submission:屈服,投降,提交&lt;br&gt;
scarcity:缺乏&lt;br&gt;
could do worse than:不妨试试&lt;br&gt;
doctor:篡改,伪造&lt;br&gt;
profound:tmd这个老师忘记,深刻的,极大的,严重的&lt;br&gt;
delusion:错觉,谬见,妄想&lt;br&gt;
make up for:弥补&lt;br&gt;
correspond with:符合一致&lt;br&gt;
oversea:监管,监督&lt;br&gt;
esteem:尊重尊敬&lt;br&gt;
stalk:高视阔步走&lt;br&gt;
hot stuff:奇才,非凡的人物&lt;br&gt;
deep-seated:深层的,根深蒂固的&lt;br&gt;
amass:聚集(由指大量)&lt;br&gt;
profile和profit别再混了:profile:印象,形象;profit:利益&lt;br&gt;
the cream of:...的精华部分&lt;br&gt;
cover up:掩饰&lt;br&gt;
instinctively:本能地&lt;br&gt;
withhold:掩藏&lt;br&gt;
review:复查;重新考虑;回顾;反思;写(关于书籍、戏剧、电影等的)评论;评介&lt;br&gt;
rectify:纠正&lt;br&gt;
be down to sb:是某人的责任&lt;br&gt;
grant:拨款&lt;br&gt;
expire:期满,终止&lt;br&gt;
hint:暗示&lt;br&gt;
comprehensive:综合的,全部的,详尽的&lt;br&gt;
comprehension:理解力,领悟力&lt;br&gt;
inevitable:看到好多次了,tmd总是忘:不可避免的,必然的&lt;br&gt;
reinvent:彻底改造&lt;br&gt;
formula:方案,方法&lt;br&gt;
reframe:重新组织&lt;br&gt;
vulnerable:易受攻击的,有弱点的&lt;br&gt;
hail from:来自&lt;br&gt;
lecture:演讲,讲座,上课&lt;br&gt;
literature:文学作品,文献,著作&lt;br&gt;
virtually:几乎&lt;br&gt;
weird:怪异的&lt;br&gt;
inherently:固有的,内在的&lt;br&gt;
perceive:察觉认识到&lt;br&gt;
unresonable:不可理喻的&lt;br&gt;
rip off:撕掉&lt;br&gt;
tuck:塞入&lt;br&gt;
kick back:放松&lt;br&gt;
nonparents:无子女者,不是无双亲&lt;br&gt;
cortisol:皮质醇&lt;br&gt;
refuge:避难,庇护&lt;br&gt;
blurring:模糊的&lt;br&gt;
life-sustaining:维持生命的&lt;br&gt;
bargain:协议&lt;br&gt;
pretty much:几乎,差不多是&lt;br&gt;
clinically:不偏不倚地&lt;br&gt;
methodically:有条不紊地&lt;br&gt;
talk into:说服&lt;br&gt;
apparently:显然地;似乎&lt;br&gt;
lingua franca:(母语不同的人之间使用的)通用语,交际语&lt;br&gt;
spin:旋转&lt;br&gt;
parachute:空投,空降&lt;br&gt;
explicitly:清楚地&lt;br&gt;
infuse:把...注入,灌输&lt;br&gt;
amid:在...中间,当中&lt;br&gt;
prompt:促进,激起&lt;br&gt;
buzzword:某一领域的时髦用语&lt;br&gt;
in its own right:凭自身的能力&lt;br&gt;
linguist:语言学家&lt;br&gt;
nonsense:无稽之谈,胡说,荒谬的想法&lt;br&gt;
buy into it:买账,认可&lt;br&gt;
irony:讽刺&lt;br&gt;
oriented:朝向,面向,导向,适应;确定方位;认识方向;熟悉;适应&lt;br&gt;
importation:引进,输入&lt;br&gt;
cover:投保&lt;br&gt;
sole:唯一的,仅有的&lt;br&gt;
coax:劝诱,哄劝&lt;br&gt;
bootcamp:训练营&lt;br&gt;
chunk:厚块&lt;br&gt;
brim:边缘&lt;br&gt;
gear:齿轮,使适合于&lt;br&gt;
curriculum:课程&lt;br&gt;
pack:挤满,塞满&lt;br&gt;
forge:形成,缔造(尤指与他人,团体或国家形成牢固的关系)&lt;br&gt;
confrontational:对抗性的,挑起冲突的&lt;br&gt;
designate:指定,认定&lt;br&gt;
crack down on:严厉打击,镇压&lt;br&gt;
prairie:(北美洲)大草原&lt;br&gt;
stretch:延伸,绵延&lt;br&gt;
prosecute:控告,指控&lt;br&gt;
interim:临时的.过渡期的,暂时的&lt;br&gt;
set aside:留出,省出&lt;br&gt;
in the driver&#39;s seat:处于控制地位,主导地位&lt;br&gt;
rhetoric:华而不实的言语,花言巧语,win-win ~:双赢的说辞&lt;br&gt;
give-in:屈服的&lt;br&gt;
mournfully:悲哀的,凄惨的&lt;br&gt;
sufficient:足够的,充足的:别tm再忘了&lt;br&gt;
cliché:陈词滥调,老生常谈&lt;br&gt;
thorny:棘手的&lt;br&gt;
odd:少量的,微少的&lt;br&gt;
flywheel:飞轮,惯性轮&lt;br&gt;
overwhelmingly:势不可挡地&lt;br&gt;
incline:倾斜,倾向于&lt;br&gt;
free up:腾出;时...可用&lt;br&gt;
maximise:充分利用&lt;br&gt;
instrumentally:起作用地,有帮助地&lt;br&gt;
immerse:沉浸式的&lt;br&gt;
conveyor belt:传送带&lt;br&gt;
mind-set:思想倾向&lt;br&gt;
slot in:安置,安排&lt;br&gt;
ritualistic:仪式的,例行的&lt;br&gt;
dip:浸,蘸&lt;br&gt;
backdrop:背景:against a backdrop of:在...背景之下&lt;br&gt;
poll:民意调查&lt;br&gt;
strikingly:惹人注目地&lt;br&gt;
generation line:代际线&lt;br&gt;
prize:珍视,高度重视&lt;br&gt;
prioritize:按优先顺序列出,确定(事项,问题)的优先顺序,优先考虑&lt;br&gt;
aftermath:(战争,风暴,事故的)后果,余波&lt;br&gt;
searing:炽热的,灼热的,剧痛的&lt;br&gt;
converge:(观点,目标)趋同&lt;br&gt;
somewhat:有点儿,有几分&lt;br&gt;
signpost:路标,标志物&lt;br&gt;
secure:(尤指经过努力)获得,取得,实现&lt;br&gt;
technician:技师,技术人员&lt;br&gt;
therapy:治疗,疗法&lt;br&gt;
wellbeing:幸福&lt;br&gt;
instinctively:本能地&lt;br&gt;
have/get sth down to an art/a fine art = do sth very well&lt;br&gt;
dictate:影响,决定,支配&lt;br&gt;
suppress:抑制(感情)&lt;br&gt;
take sth too far:将某事做的太过&lt;br&gt;
end up doing:最终处于&lt;br&gt;
brush/sweep sth under the carpet:掩盖某事,尤指错事&lt;br&gt;
fiver:五美元&lt;br&gt;
silver bullet:解决某一难题的良方,高招&lt;br&gt;
indulge:沉溺于,沉湎于,纵情于&lt;br&gt;
endorphin:内啡肽&lt;br&gt;
fight off:抵挡,击退,竭力摆脱&lt;br&gt;
spree:狂欢,作乐&lt;br&gt;
side effect:副作用&lt;br&gt;
an awful lot of:许多,多的可怕&lt;br&gt;
have the luxury of:难的能享受某种机会&lt;br&gt;
lure:诱使,引诱&lt;br&gt;
volume:体积&lt;br&gt;
sheer:十足的,彻底的,纯粹的&lt;br&gt;
speculate:推测&lt;br&gt;
capital:首都;国都;&lt;strong&gt;资本&lt;/strong&gt;;资金;启动资金;财富;财产adj.死刑的;大写的;顶好的;极好的&lt;br&gt;
impoverished:贫困的&lt;br&gt;
wasteland:荒地,不毛之地&lt;br&gt;
the masses:普通老百姓&lt;br&gt;
mutually exclusive:互相排斥&lt;br&gt;
mortality:死亡人数&lt;br&gt;
agonizing:痛苦难忍&lt;br&gt;
follow from:是..的必然结果&lt;br&gt;
vision:憧憬&lt;br&gt;
end:目的&lt;br&gt;
degrading:丧失体面的&lt;br&gt;
overblow:夸张,过分渲染&lt;br&gt;
lengthy:长时间的,冗长的&lt;br&gt;
tricky:狡猾的&lt;br&gt;
the demands of sth:困难的/烦人的/累人的事&lt;br&gt;
counterbalance:使平衡,抵消&lt;/p&gt;
">做题词汇积累</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/zuo-ti-ci-hui-ji-lei/"" data-c="
          &lt;h2 id=&#34;超高频&#34;&gt;超高频&lt;/h2&gt;
&lt;p&gt;overwhelmingly:压倒性地,不可抵抗地&lt;br&gt;
recession&lt;br&gt;
prospect:前景,可能性,机会,希望&lt;br&gt;
exclude:排除在外的&lt;br&gt;
deny:否认&lt;br&gt;
statistically:统计地&lt;br&gt;
strikingly:惹人注目地&lt;br&gt;
descent:体面的&lt;br&gt;
engagement:&lt;strong&gt;参与度&lt;/strong&gt;订婚;订婚期间;(尤指正式的或与工作有关的)约定，约会，预约;战斗;交战&lt;br&gt;
disengage:脱离,不再感兴趣&lt;br&gt;
legacy:遗产&lt;br&gt;
ethos:精神特质,理念&lt;br&gt;
decline:抗拒&lt;br&gt;
squeeze:v.挤压;捏;(从某物中)榨出，挤出，拧出;(使)挤入;挤过;塞入n.挤压;捏;榨出的液体;小量挤出的汁;挤;塞&lt;br&gt;
supervise:监督&lt;br&gt;
exquisitely:精致地&lt;br&gt;
bid:努力,企图,争取&lt;br&gt;
perpetuate:使永久化,使持续&lt;br&gt;
misleading:误导,误人子弟&lt;br&gt;
prone:易于发生某事的,很有可能的&lt;br&gt;
budget:预算&lt;br&gt;
infrastructure:基础设施&lt;br&gt;
hazard:危险隐患&lt;br&gt;
landscape:地形,地貌&lt;br&gt;
corresponding:相应的,由此引起的&lt;br&gt;
equation:影响因素,综合体&lt;br&gt;
perspective:角度&lt;br&gt;
perception:认识,观念,看法&lt;br&gt;
interaction:相互作用,相互影响&lt;br&gt;
unleash:发泄,突然释放,使爆发&lt;br&gt;
unprecedented:空前的,史无前例的&lt;br&gt;
stiff:激烈的,严厉的&lt;br&gt;
--prone:有做...的倾向,易于遭受...的&lt;br&gt;
inclined:有..的倾向&lt;br&gt;
assessment:评价,评估&lt;br&gt;
prosocial:亲社会的,忠实于既定社会道德准则的&lt;br&gt;
appease:安抚,抚慰&lt;br&gt;
moral:道德的&lt;br&gt;
revival:复苏,复兴&lt;br&gt;
evolve:进化&lt;br&gt;
make up for:补偿&lt;br&gt;
deficiency:缺乏&lt;br&gt;
outcome:结果&lt;br&gt;
impulse:冲动&lt;br&gt;
rein:遏制&lt;br&gt;
anonymous:匿名的&lt;/p&gt;
&lt;h2 id=&#34;倒序17年开始&#34;&gt;倒序17年开始&lt;/h2&gt;
&lt;p&gt;norms:规范行为标准&lt;br&gt;
turn on sth:依靠取决于&lt;br&gt;
transgression:越轨,违背道德的&lt;br&gt;
vice versa:反之亦然&lt;br&gt;
shortfall:差额,不足&lt;/p&gt;
&lt;p&gt;pluck:拖,拉扯&lt;br&gt;
add up to:结果是&lt;br&gt;
outsourcing:外包&lt;/p&gt;
&lt;p&gt;upkeep:保养修护&lt;br&gt;
at the expense of:以...为代价&lt;br&gt;
tease:&lt;strong&gt;梳理&lt;/strong&gt;,挑逗&lt;br&gt;
do away with:终结&lt;br&gt;
come to terms with:与之妥协&lt;br&gt;
expenditure:开支,支出&lt;br&gt;
magnifying glass:放大镜&lt;/p&gt;
&lt;p&gt;lucrative:获利多的,赚大钱的&lt;br&gt;
acclimation:适应&lt;br&gt;
blunder:愚蠢错误&lt;br&gt;
blow:冲击&lt;br&gt;
mandatory:强制的,法定的,义务的&lt;br&gt;
inherent:内在的,固有的&lt;br&gt;
make up:补上&lt;br&gt;
be wired to:天生就会&lt;br&gt;
tablet:平板电脑&lt;br&gt;
maximal:最大的,最高的&lt;br&gt;
bleed-over:渗透,渗开&lt;br&gt;
staff:为...配备工作人员&lt;br&gt;
set off:启程出发&lt;br&gt;
pledge:发誓,保证&lt;br&gt;
lever:撬动&lt;br&gt;
fit:健壮的&lt;br&gt;
retrospection:回想,反思&lt;br&gt;
in the run-up to sth:重要事件前夕&lt;br&gt;
as to sth:关于&lt;br&gt;
shine:干的出色,出类拔萃&lt;br&gt;
bidder:投标人:Olympic~:奥运申办者&lt;br&gt;
dual:双重的&lt;br&gt;
intimidating:令人胆怯的&lt;br&gt;
puffed-out:气喘吁吁的,生气不接下气的&lt;br&gt;
stress on A over B:强调A胜过B&lt;br&gt;
time trial:计时赛&lt;br&gt;
first timer:第一次参赛的&lt;br&gt;
grassroots:pl.基层民众,草根&lt;br&gt;
successive:连续的&lt;br&gt;
wordyL冗长的&lt;br&gt;
preside over:主持,掌管&lt;/p&gt;
&lt;h2 id=&#34;10年开始的&#34;&gt;10年开始的&lt;/h2&gt;
&lt;p&gt;tropical:热带的&lt;br&gt;
soap habbit:用肥皂洗手的习惯;&lt;strong&gt;类似的组合词学会结合上下文翻译&lt;/strong&gt;&lt;br&gt;
wipe:抹,擦&lt;br&gt;
counter:柜台&lt;br&gt;
cue:暗示,提示&lt;br&gt;
turn to:求助于&lt;br&gt;
subtle:微妙的&lt;br&gt;
invest ... doing sth:投入...做某事&lt;br&gt;
routine:惯例&lt;br&gt;
shrewd:精明的&lt;br&gt;
scrub:n.擦洗&lt;br&gt;
sip:小口地喝&lt;br&gt;
primarily:首先地&lt;br&gt;
ritual:仪式&lt;br&gt;
viable:可行的&lt;br&gt;
ruthless:无情残忍的&lt;br&gt;
controversies...erupted:辩论争论爆发&lt;br&gt;
exempt....from...使...:免除豁免&lt;br&gt;
peer:同龄,同等地位的人;v.仔细看,端详&lt;br&gt;
ideal:理想&lt;br&gt;
landmark:里程碑&lt;br&gt;
unconstitutional:不符合宪法的&lt;br&gt;
discrimination:歧视&lt;br&gt;
antidiscrimination:反歧视&lt;br&gt;
usher:引导,~ sth in:开创,开启&lt;br&gt;
supposedly:据说,据传&lt;br&gt;
intentional:有意的,故意的&lt;br&gt;
blue-ribbon:一流头等的&lt;br&gt;
trumpet:v.大声宣告,大肆宣扬,吹嘘&lt;br&gt;
respectively:ad.分别地&lt;br&gt;
lightweight:a.比通常重量轻的&lt;br&gt;
composite:a.合成的,混合的,复合的;n.合成物,混合物,复合物&lt;br&gt;
make a difference:有作用,有影响&lt;br&gt;
naturalistic:自然的&lt;br&gt;
propel:推进&lt;br&gt;
substantially:ad.实质上,大体上&lt;br&gt;
unsubstantiated:未经证实的&lt;br&gt;
inverted:倒转的&lt;br&gt;
proceed:v.继续前进&lt;br&gt;
process:进程&lt;br&gt;
procedure:程序&lt;br&gt;
favorable:有利的,赞许的,令人愉快的,讨人喜欢的&lt;br&gt;
cruise:(汽车飞机等)以平稳速度行驶&lt;br&gt;
portion:部分&lt;br&gt;
perception:察觉,感知,洞察力,知觉&lt;br&gt;
nautical:航海的&lt;br&gt;
intimate:亲近的&lt;br&gt;
regulation:规定&lt;br&gt;
aviation:航空&lt;br&gt;
wake:航空轨迹&lt;br&gt;
diminish:变小,减小&lt;br&gt;
investigate:调查&lt;br&gt;
under fire:收到批评和攻击&lt;br&gt;
compensation:报酬薪水&lt;br&gt;
bonus payout:奖金支出&lt;br&gt;
presumably:ad.据推测,大概,可能&lt;br&gt;
weather:v.平安度过(难关),挨过,经受住&lt;br&gt;
a firm&#39;s board:公司董事会&lt;br&gt;
make one&#39;s wealth and reputations:功成名就&lt;br&gt;
executive:主管&lt;br&gt;
proxy:代表权,委托书&lt;br&gt;
subsequently:ad.其后,随后,接着&lt;br&gt;
restate:v.重申,重新申报:restate earnings:重申盈利&lt;br&gt;
depart a board:从董事会离职&lt;br&gt;
federal class-action lawsuit:联邦集体诉讼&lt;br&gt;
jump off a sinking ship:跳离沉船&lt;br&gt;
blow:打击,意外的灾害,摧毁&lt;br&gt;
incentive:动机,鼓励,刺激&lt;br&gt;
a blow to the reputations:有损名誉&lt;br&gt;
recession:n.经济衰退/萎缩,不景气&lt;br&gt;
chronicle:记录(大事)&lt;br&gt;
chronic:慢性的,长期的,习惯性的&lt;br&gt;
devaluation:(货币)贬值&lt;br&gt;
subsidize:v.以津贴补助&lt;br&gt;
inhabit:v.居住,在....出现,填满&lt;br&gt;
routine:常规,通常情况&lt;br&gt;
shrug off:对...满不在乎,不屑一顾&lt;br&gt;
afloat:ad.漂流着的,漂浮不定:stay ~:维持运营&lt;br&gt;
overboard:ad.越过船边坠入水中:push sth/sb overboard:抛弃,甩掉某人/某事&lt;br&gt;
whirlwind:旋风,猛烈的势力&lt;br&gt;
distinctive:有特色的,与众不同的&lt;br&gt;
savagely:野蛮地,残忍地,粗野地&lt;br&gt;
line up:排队&lt;br&gt;
common sense:常识&lt;br&gt;
stylish:时髦的,流行的,入时的&lt;br&gt;
take up posts:就职&lt;br&gt;
stimulus:刺激物,刺激因素&lt;br&gt;
exert:发挥,运用,使受(影响)&lt;br&gt;
signature:签名,署名,识别标志,鲜明特征:~ phrase:口头禅&lt;br&gt;
derive from:由...起源,取自&lt;br&gt;
laminated:由薄片叠成的,分层的&lt;br&gt;
symbolize:象征,用符号表现&lt;br&gt;
sophisticated:复杂的,精致的&lt;br&gt;
take for granted:认为...理所当然&lt;br&gt;
mask the fact:掩盖事实&lt;br&gt;
modest:适度的,适中的,端庄的&lt;br&gt;
desirable:令人满意的,可取的&lt;br&gt;
inevitable:不可避免的,必然发生的&lt;br&gt;
forthright:直率的,明确的&lt;br&gt;
disintegration:瓦解,崩溃&lt;br&gt;
stuck:动不了,被卡主的,被难住的&lt;br&gt;
dominant:占优势的,统治的,支配的,首要的&lt;br&gt;
harmonisation:和谐,协调,相称&lt;br&gt;
quasi-automatic:半自动的,准自动的&lt;br&gt;
mega:巨大的,极佳的&lt;br&gt;
suspension:悬挂,暂停&lt;br&gt;
rigour:严苛,严酷&lt;br&gt;
backed by:依靠,在...支持下&lt;br&gt;
intervene:介于..之间,干预,介入:~ in介入,干预&lt;br&gt;
murmur:咕哝,发牢骚,私下抱怨&lt;br&gt;
curb:制止,束缚,限制,抑制&lt;br&gt;
remarkably:引人注目地,明显地&lt;br&gt;
liberal:开明的,自由的&lt;br&gt;
blunt:使迟钝&lt;br&gt;
write off:认定...不重要/无用/无可救药&lt;br&gt;
weigh in:参加,加入(争论等)&lt;br&gt;
spiral:盘旋上升(或下降),(物价等)不断急剧上升(或下降)&lt;br&gt;
excessive:过度的,极度的,非常的&lt;br&gt;
inconceivable:不能想象的,不可思议的,难以置信的&lt;br&gt;
in respect of:关于,涉及&lt;br&gt;
inducement:诱导,诱惑,诱因&lt;br&gt;
lure:吸引,引诱&lt;br&gt;
up front:预先,在前面&lt;br&gt;
takeaway:外卖食品,外卖店&lt;br&gt;
centerpiece:最重要的项目(或物品)&lt;br&gt;
set out:陈述,列述&lt;br&gt;
deploy:展开,施展,部署&lt;br&gt;
abbreviation:缩写词,缩写形式&lt;br&gt;
article:文章,(成套的)五篇,物件,条款&lt;br&gt;
mindless:无头脑的,盲目的,无谓的&lt;br&gt;
tear away from ...:依依不舍离开..&lt;br&gt;
foxhole:散兵坑&lt;br&gt;
stick it/sth out:坚持到底,忍受下去&lt;br&gt;
up against:必须面对某人/某事&lt;br&gt;
hand out:分发&lt;br&gt;
turn over:移交,交托&lt;br&gt;
pass down:遗传,继承&lt;br&gt;
cover:报道的意思一定记住啊,经常用&lt;br&gt;
portray:扮演某角色&lt;br&gt;
civilization:文明,文明社会:注意和urbanization(城市化)区别开,总记错&lt;br&gt;
colony:殖民地,群体&lt;br&gt;
parallel:除了有平行,还有&lt;strong&gt;相似的意思啊注意注意&lt;/strong&gt;&lt;br&gt;
counteracted:抵消,中和&lt;br&gt;
duplicate:重复,复制&lt;br&gt;
duplex:双工&lt;br&gt;
disguised:伪装的,掩饰的&lt;br&gt;
disturbed:坎坷的,不幸的&lt;br&gt;
disputed:争论的,有争议的&lt;br&gt;
distinguished:卓越的,杰出的&lt;br&gt;
from the outset:从开始时&lt;br&gt;
revise:修正,改变&lt;br&gt;
ritual:惯例,老规矩,例行公事&lt;br&gt;
mandate:命令指示&lt;br&gt;
interpretation:n.理解;解释;说明;演绎;演奏方式;表演方式&lt;br&gt;
pastel:(色彩)淡的,柔和的&lt;br&gt;
dominant:adj.首要的;占支配地位的;占优势的;显著的;(基因)显性的，优势的n.[生]显性性状;显性基因;优势物种;[乐]全阶第五音;主因;要素&lt;br&gt;
come into its own:显示出用处&lt;br&gt;
across-the-board:一刀切的&lt;br&gt;
thorny:棘手的&lt;br&gt;
look into:调查&lt;br&gt;
put on hold:搁置,暂缓&lt;br&gt;
dictate:控制,支配,口述,...听写的动词&lt;br&gt;
consel:建议&lt;br&gt;
stepping stone:垫脚石,踏板&lt;br&gt;
pervasive:普遍的,无处不在的&lt;br&gt;
intrinsically:ad.从本质上(讲)&lt;br&gt;
singular:如初的,非凡的&lt;br&gt;
fuse .. to ..:把..和..熔合在一起&lt;br&gt;
be obsessed with:痴迷于&lt;br&gt;
domestic:adj.本国的;国内的;家用的;家庭的;家务的;喜爱家庭生活的;享受家庭乐趣的;乐于操持家务的n.家佣;佣人;家庭纠纷;家庭矛盾&lt;br&gt;
violently:激烈地,强烈地&lt;br&gt;
agitated:紧张不安的,焦虑的&lt;br&gt;
preliminary:初步的,预备的&lt;br&gt;
federal judge:联邦法官&lt;br&gt;
shake...to its core:彻底震惊&lt;br&gt;
suppress:压制,镇压,制止&lt;br&gt;
make arguments against:提出反对...的理由&lt;br&gt;
innovation:创新&lt;br&gt;
violate:侵犯,干扰&lt;br&gt;
session:(一系列会议中的一次)会议&lt;br&gt;
landscape:景色,形势&lt;br&gt;
packed:挤满人的,非常拥挤的&lt;br&gt;
alike:adv.同样都(用于强调刚刚提及的两者)&lt;br&gt;
over turn:使倾覆,打翻&lt;br&gt;
national polls:国内民意调查&lt;br&gt;
social fabric:社会结构&lt;br&gt;
discern:识别,看清,领悟&lt;br&gt;
resentment:怨气,怨恨,不满&lt;br&gt;
shrink:(使)缩小/收缩&lt;br&gt;
reinforce:加强,强化....&lt;strong&gt;不要老是记成限制(restrain)啊&lt;/strong&gt;&lt;br&gt;
lengthy:长时间的,过长的&lt;br&gt;
mean-spirited:心胸狭隘的&lt;br&gt;
inclusive:包容的&lt;br&gt;
sentiment:观点感想意见&lt;br&gt;
far off:遥远&lt;br&gt;
reckless:鲁莽轻率不顾后果的&lt;br&gt;
exemplary:模范的&lt;br&gt;
lining:n.衬层;内衬;衬里;(身体器官内壁的)膜v.(用…)做衬里;(在某物的内部)形成一层;沿…形成行(或列、排)&lt;br&gt;
rambling:讲话或文章杂乱无章的&lt;br&gt;
champion:除了冠军,还有捍卫维护的意思&lt;br&gt;
cunning:n.狡猾狡诈&lt;br&gt;
ruthlessness:无情冷酷&lt;br&gt;
furnish:v.提供,供应&lt;br&gt;
resolute:坚决的,坚定的&lt;br&gt;
steadfast:忠诚的,坚贞不渝的&lt;br&gt;
integrity:n.诚实正直;完整;完好&lt;br&gt;
beacon:引路人,指路明灯&lt;br&gt;
bourgeois:过分追求名利的,注意物质享受的;市侩的,庸俗的&lt;br&gt;
epochal:具有时代意义的&lt;br&gt;
bombast:空洞华丽的(言论)&lt;br&gt;
hitherto:ad.迄今,至今&lt;br&gt;
nurture:v.培养培育&lt;br&gt;
unpick:v.拆去针脚,撬开,引申为分析研究&lt;br&gt;
multiplicity:多样性&lt;br&gt;
downstairs:底层(阶级)&lt;br&gt;
upstairs:上层(阶级)&lt;br&gt;
fruition:n.(计划、过程或活动的)完成，实现，取得成果:come to fruition:完成实现&lt;br&gt;
revolutionize:v.彻底改革,彻底变革&lt;br&gt;
steady:稳定的,持续的&lt;br&gt;
telecommunication:电磁通信,远距离通信&lt;br&gt;
receipt:收据收条&lt;br&gt;
unauthorized:未被授权的,未经认可的&lt;br&gt;
fraud:欺诈,欺骗&lt;br&gt;
chunk:厚块,大块&lt;br&gt;
trail:踪迹,痕迹&lt;br&gt;
stubbornly:顽固地,倔强地&lt;br&gt;
make the point:表明观点&lt;br&gt;
automate:自动化&lt;br&gt;
relate:除了关联之外还有讲述叙述的意思&lt;br&gt;
look to do sh:寻找机会做某事&lt;br&gt;
for good:永久地,永远地,一劳永逸地&lt;br&gt;
birds of passage:候鸟,漂泊的人&lt;br&gt;
affectionate:深情的,充满深情的&lt;br&gt;
rigid:严格的,僵硬的死板的&lt;br&gt;
brand:打烙印于,印商标于&lt;br&gt;
paralysis:n.麻痹,无力,停顿(活动工作能力)完全丧失,瘫痪&lt;br&gt;
look beyond:超越...看问题&lt;br&gt;
in the making:在酝酿中,在形成中&lt;br&gt;
kick out:踢出&lt;br&gt;
hail ..as...:将..誉为...&lt;br&gt;
mightily:很,非常ad&lt;br&gt;
straddle:跨立于,跨越&lt;br&gt;
jurisdiction:管辖范围&lt;br&gt;
commit oneself to sth/doing sth:承诺&lt;br&gt;
in motion:在运动中的&lt;br&gt;
prone:有..倾向的,易于倾向于&lt;br&gt;
snap:仓促的,匆忙的,注意与nap(小憩)的区别&lt;br&gt;
hard-wired:(计算机系统中)硬件控制的,硬连线的,固有的,天生的(innate):be hard-wired to do sth:天生会做某事&lt;br&gt;
mechanism:机制&lt;br&gt;
assess:评估(哎,千万别忘了啊)&lt;br&gt;
preferably:ad.较好,更适宜&lt;br&gt;
sociable:好交际的,合群的,友好的&lt;br&gt;
stimuli:n.刺激(stimulus的复数)&lt;br&gt;
exclusive:独有的,独占的,专有的:be exclusive to:专为...独享&lt;br&gt;
prime:v.使准备好:prime sb to do sth:使某人准备好应付某种情况&lt;br&gt;
interpersonal:人际关系的,&lt;br&gt;
reverse:颠倒,逆转&lt;br&gt;
ground:v.使接触地面.打基础&lt;br&gt;
retreat:僻静处,隐居处,休息寓所&lt;br&gt;
mute:减弱...的声音,使...柔和(可以引申为控制,抑制)&lt;br&gt;
contemplate:沉思,深思熟虑,冥思苦想&lt;br&gt;
revitalize:使得到复兴&lt;br&gt;
weave:使组合,使交织&lt;br&gt;
paraphrase:意译,改述&lt;br&gt;
by virtue of:由于,因为&lt;br&gt;
disperse:使分散&lt;br&gt;
intervene:干预&lt;br&gt;
alternative:n.(两者或以上)择一&lt;br&gt;
deploy:利用&lt;br&gt;
profile:n.面部的侧影;侧面轮廓;概述;简介;传略;印象;形象v.扼要介绍;概述;写简介&lt;br&gt;
high-profile:高调的,备受瞩目的&lt;br&gt;
convert:除了动词转换转变还有名词:皈依者,改变信念的人&lt;br&gt;
indulgence:n.放纵溺爱&lt;br&gt;
momentum:势头声势&lt;br&gt;
coalition:联合联盟&lt;br&gt;
shave off:减少,剃掉&lt;br&gt;
skate by:轻松通过&lt;br&gt;
testimonial:推荐信,证明书&lt;br&gt;
curricular:课程的,extracurricular:课外的&lt;br&gt;
level:还有动词使平等的意思&lt;br&gt;
level the playing field:创造公平的竞争环境&lt;br&gt;
unveil:公布,为...揭幕&lt;br&gt;
speculative:猜测性的,投机的&lt;br&gt;
rigor:严格&lt;br&gt;
resistence:阻力,抵抗力&lt;br&gt;
demonstrate:[ˈdemənstreɪt] v.证明;证实;论证;说明;表达;表露;表现;显露;示范;演示&lt;br&gt;
compelling:英 [kəmˈpelɪŋ] 美 [kəmˈpelɪŋ]adj.引人入胜的;扣人心弦的;非常强烈的;不可抗拒的;令人信服的v.强迫;迫使;使必须;引起(反应)&lt;br&gt;
the best bits of:最好的部分&lt;br&gt;
come into force:生效,开始实施&lt;br&gt;
flaw:缺点,瑕疵&lt;br&gt;
premise:n.前提,假定&lt;br&gt;
levy:n.征收&lt;br&gt;
fine:罚款&lt;br&gt;
regulate:监管.self-regulatory:自我监管的&lt;br&gt;
spray around:分散,喷洒&lt;br&gt;
leak:泄露渗漏&lt;br&gt;
harmonise:使和谐&lt;br&gt;
embroil::v使卷入,使混乱&lt;br&gt;
template:模板样板&lt;br&gt;
overarching:包罗万象的&lt;br&gt;
dominoes[&#39;dominouz]n.多米诺骨牌（PlL1）&lt;br&gt;
slap on the wrist 象征性惩罚（P1L1）&lt;br&gt;
show the door 开除，扫地出门（P1L2）&lt;br&gt;
insensitive[in&#39;senstiv]a.缺乏同情心的,不敏感的（P1L3）&lt;br&gt;
misconduct[imis&#39;kondakt]n.不端行为（PlL4）&lt;br&gt;
integrity[un&#39;tegrtu]n.正直；诚实（P2L1）&lt;br&gt;
pragmatic[preg&#39;maetik]a.实用主义的（P21L3）&lt;br&gt;
course of action做法，行动步骤（P2L3）&lt;br&gt;
overlook A for the sake of B:为B忽略A（P3L2）&lt;br&gt;
ethical lapse 道德败坏，道德堕落（P3L3）&lt;br&gt;
accountable[a&#39;kauntobl]a.有责任的，负责的（P315）&lt;br&gt;
fallout[folaut]n.（尤指预料不到的）影响，结果&lt;br&gt;
harshly[ha:fu]ad.严厉地；严酷的（P5L1）&lt;br&gt;
toxic[&#39;toksik]a.有毒的；中毒的（P5L2）&lt;br&gt;
one-off[iwan&#39;of]n.一次性事物（P6L2）&lt;br&gt;
paper over 隐瞒（有争议或使人不愉快之事）&lt;br&gt;
bigwig[&#39;brgwrg]n.有重大影响的人（P1L3）&lt;br&gt;
gung-ho[&#39;gag&#39;hou]a.非常急切的（P7L1）&lt;br&gt;
errant:犯错误的;行为不当的;出格的;对配偶不忠的&lt;br&gt;
accountable:负责的&lt;br&gt;
inclusive:adj.包含全部费用;包括所提到的费用在内;包括提到的所有的天数(或月、数目等)在内;包容广阔的;范围广泛的&lt;br&gt;
fallout:后果,余波&lt;br&gt;
wicked:adj.邪恶的;缺德的;淘气的;调皮的;恶作剧的;危险的;有害的;强大的n恶人;邪恶的人&lt;br&gt;
revolutionise[.revallufanalz]v.彻底改变，使彻底变革&lt;br&gt;
star-up[&#39;statAp]n.初创公司&lt;br&gt;
gig worker零工，临时工（P2L1）&lt;br&gt;
reimagine[ria&#39;maedsin]v.重新构想&lt;br&gt;
benefit[&#39;benift]n.福利，补贴&lt;br&gt;
weather[&#39;we0].经受住，平安度过&lt;br&gt;
ensuing[in&#39;sjug]a.随后的&lt;br&gt;
select[silekt]a.精选的，挑选出的&lt;br&gt;
emerging[I&#39;msxd31g]a.新兴的，新出现的&lt;br&gt;
compromise[&#39;kompromalz]v.妥协，让步&lt;br&gt;
step in介入，干预（P3L1）&lt;br&gt;
on one&#39;s own terms按照某人自己的意愿&lt;br&gt;
climate[&#39;klatmt]n.氛围，形势&lt;br&gt;
opening[&#39;oupanig]n.机遇，良机&lt;br&gt;
tailor:定做，根据需要制作&lt;br&gt;
aggregate[egrg]a.总计的，合计的&lt;br&gt;
intermittent[inta&#39;mutant]a.断断续续的，间歇的&lt;br&gt;
trigger:n.(枪的)扳机;(尤指引发不良反应或发展的)起因，诱因;触发器;引爆器v.发动;引起;触发;开动;起动&lt;br&gt;
dignity:n.庄重;庄严;尊严;尊贵;高贵;高尚;自豪;自尊;自重&lt;br&gt;
rational[&#39;refnol]a.理性的；合理的（P3L1）&lt;br&gt;
fosil[&#39;fosl]n.化石（P513）&lt;br&gt;
auction[&#39;o.kJn]n.竞卖，拍卖（P3L4）&lt;br&gt;
shake off摆脱（P6L5）&lt;br&gt;
scheme[skim]n.（造福他人的）计划，方案（P3L4）&lt;br&gt;
onshore[&#39;on/]n.陆上的，朝岸的（P4L3）&lt;br&gt;
muster[&#39;masta]v.鼓起（勇气），积聚（信心），争取支持&lt;br&gt;
curb[katb]v.控制，抑制，束缚&lt;br&gt;
ideological[iaidia&#39;lodglkl]a.思想上的，意识形态&lt;br&gt;
shuter[Uata]u.便停止运行，关闭；装百页窗&lt;br&gt;
press ahead推进，加紧进行&lt;br&gt;
fury[&#39;fjuori]n.狂怒，暴怒&lt;br&gt;
infrastructure[nfrstraktfar]n.基础设施，基础&lt;br&gt;
arbitrary::任意的,专断的&lt;br&gt;
opaque:不透明的&lt;br&gt;
meritocracy:精英领导体制&lt;br&gt;
vice:副的&lt;br&gt;
evade:逃避&lt;br&gt;
summit:最高阶层,顶点&lt;br&gt;
overwhelmingly:压倒性地,不可抵抗地&lt;br&gt;
run counter to:与...背道而驰&lt;br&gt;
anonymity:匿名,不知名&lt;br&gt;
chiller:冷却装置&lt;br&gt;
greengrocer:蔬菜水果商&lt;br&gt;
come in handy:派的上用场&lt;br&gt;
on a budget:避免不必要的开支,节省费用&lt;br&gt;
burn out:出故障,烧尽,熄灭,精疲力尽&lt;br&gt;
chronicle:按事件发展顺序记载&lt;br&gt;
council flat:公营公寓(感觉是廉租房类似的)&lt;br&gt;
impulsive:冲动的,任性的&lt;br&gt;
ingredient:原料,材料,食材&lt;br&gt;
extra:额外的&lt;br&gt;
exact:精确的&lt;br&gt;
peasant:农民&lt;br&gt;
leftover:残羹剩饭&lt;br&gt;
stock:高汤&lt;br&gt;
surplus:过剩的,剩余的&lt;br&gt;
frugal:节俭的,朴素的&lt;br&gt;
deli:熟食店&lt;br&gt;
knuckle:关节骨&lt;br&gt;
carcass:尸体,兽体&lt;br&gt;
collegiate:学院的,学院学生的&lt;br&gt;
moderately:适度地,不过分地&lt;br&gt;
in turn:转而,相应的&lt;br&gt;
conservative:传统的,保守的&lt;br&gt;
in essence:本质上的,实质上的&lt;br&gt;
disgrace:耻辱,丢脸的事,出丑&lt;br&gt;
harbor:心怀,怀有(某种想法)&lt;br&gt;
stimulate:促进,刺激&lt;br&gt;
institute:开始(某进程),建立制定&lt;br&gt;
initiative:新倡议,行动方案&lt;br&gt;
obsolete:过时&lt;br&gt;
obsession:痴迷,着迷,注意和上一个区别&lt;br&gt;
rarity:稀缺,缺少&lt;br&gt;
submission:屈服,投降,提交&lt;br&gt;
scarcity:缺乏&lt;br&gt;
could do worse than:不妨试试&lt;br&gt;
doctor:篡改,伪造&lt;br&gt;
profound:tmd这个老师忘记,深刻的,极大的,严重的&lt;br&gt;
delusion:错觉,谬见,妄想&lt;br&gt;
make up for:弥补&lt;br&gt;
correspond with:符合一致&lt;br&gt;
oversea:监管,监督&lt;br&gt;
esteem:尊重尊敬&lt;br&gt;
stalk:高视阔步走&lt;br&gt;
hot stuff:奇才,非凡的人物&lt;br&gt;
deep-seated:深层的,根深蒂固的&lt;br&gt;
amass:聚集(由指大量)&lt;br&gt;
profile和profit别再混了:profile:印象,形象;profit:利益&lt;br&gt;
the cream of:...的精华部分&lt;br&gt;
cover up:掩饰&lt;br&gt;
instinctively:本能地&lt;br&gt;
withhold:掩藏&lt;br&gt;
review:复查;重新考虑;回顾;反思;写(关于书籍、戏剧、电影等的)评论;评介&lt;br&gt;
rectify:纠正&lt;br&gt;
be down to sb:是某人的责任&lt;br&gt;
grant:拨款&lt;br&gt;
expire:期满,终止&lt;br&gt;
hint:暗示&lt;br&gt;
comprehensive:综合的,全部的,详尽的&lt;br&gt;
comprehension:理解力,领悟力&lt;br&gt;
inevitable:看到好多次了,tmd总是忘:不可避免的,必然的&lt;br&gt;
reinvent:彻底改造&lt;br&gt;
formula:方案,方法&lt;br&gt;
reframe:重新组织&lt;br&gt;
vulnerable:易受攻击的,有弱点的&lt;br&gt;
hail from:来自&lt;br&gt;
lecture:演讲,讲座,上课&lt;br&gt;
literature:文学作品,文献,著作&lt;br&gt;
virtually:几乎&lt;br&gt;
weird:怪异的&lt;br&gt;
inherently:固有的,内在的&lt;br&gt;
perceive:察觉认识到&lt;br&gt;
unresonable:不可理喻的&lt;br&gt;
rip off:撕掉&lt;br&gt;
tuck:塞入&lt;br&gt;
kick back:放松&lt;br&gt;
nonparents:无子女者,不是无双亲&lt;br&gt;
cortisol:皮质醇&lt;br&gt;
refuge:避难,庇护&lt;br&gt;
blurring:模糊的&lt;br&gt;
life-sustaining:维持生命的&lt;br&gt;
bargain:协议&lt;br&gt;
pretty much:几乎,差不多是&lt;br&gt;
clinically:不偏不倚地&lt;br&gt;
methodically:有条不紊地&lt;br&gt;
talk into:说服&lt;br&gt;
apparently:显然地;似乎&lt;br&gt;
lingua franca:(母语不同的人之间使用的)通用语,交际语&lt;br&gt;
spin:旋转&lt;br&gt;
parachute:空投,空降&lt;br&gt;
explicitly:清楚地&lt;br&gt;
infuse:把...注入,灌输&lt;br&gt;
amid:在...中间,当中&lt;br&gt;
prompt:促进,激起&lt;br&gt;
buzzword:某一领域的时髦用语&lt;br&gt;
in its own right:凭自身的能力&lt;br&gt;
linguist:语言学家&lt;br&gt;
nonsense:无稽之谈,胡说,荒谬的想法&lt;br&gt;
buy into it:买账,认可&lt;br&gt;
irony:讽刺&lt;br&gt;
oriented:朝向,面向,导向,适应;确定方位;认识方向;熟悉;适应&lt;br&gt;
importation:引进,输入&lt;br&gt;
cover:投保&lt;br&gt;
sole:唯一的,仅有的&lt;br&gt;
coax:劝诱,哄劝&lt;br&gt;
bootcamp:训练营&lt;br&gt;
chunk:厚块&lt;br&gt;
brim:边缘&lt;br&gt;
gear:齿轮,使适合于&lt;br&gt;
curriculum:课程&lt;br&gt;
pack:挤满,塞满&lt;br&gt;
forge:形成,缔造(尤指与他人,团体或国家形成牢固的关系)&lt;br&gt;
confrontational:对抗性的,挑起冲突的&lt;br&gt;
designate:指定,认定&lt;br&gt;
crack down on:严厉打击,镇压&lt;br&gt;
prairie:(北美洲)大草原&lt;br&gt;
stretch:延伸,绵延&lt;br&gt;
prosecute:控告,指控&lt;br&gt;
interim:临时的.过渡期的,暂时的&lt;br&gt;
set aside:留出,省出&lt;br&gt;
in the driver&#39;s seat:处于控制地位,主导地位&lt;br&gt;
rhetoric:华而不实的言语,花言巧语,win-win ~:双赢的说辞&lt;br&gt;
give-in:屈服的&lt;br&gt;
mournfully:悲哀的,凄惨的&lt;br&gt;
sufficient:足够的,充足的:别tm再忘了&lt;br&gt;
cliché:陈词滥调,老生常谈&lt;br&gt;
thorny:棘手的&lt;br&gt;
odd:少量的,微少的&lt;br&gt;
flywheel:飞轮,惯性轮&lt;br&gt;
overwhelmingly:势不可挡地&lt;br&gt;
incline:倾斜,倾向于&lt;br&gt;
free up:腾出;时...可用&lt;br&gt;
maximise:充分利用&lt;br&gt;
instrumentally:起作用地,有帮助地&lt;br&gt;
immerse:沉浸式的&lt;br&gt;
conveyor belt:传送带&lt;br&gt;
mind-set:思想倾向&lt;br&gt;
slot in:安置,安排&lt;br&gt;
ritualistic:仪式的,例行的&lt;br&gt;
dip:浸,蘸&lt;br&gt;
backdrop:背景:against a backdrop of:在...背景之下&lt;br&gt;
poll:民意调查&lt;br&gt;
strikingly:惹人注目地&lt;br&gt;
generation line:代际线&lt;br&gt;
prize:珍视,高度重视&lt;br&gt;
prioritize:按优先顺序列出,确定(事项,问题)的优先顺序,优先考虑&lt;br&gt;
aftermath:(战争,风暴,事故的)后果,余波&lt;br&gt;
searing:炽热的,灼热的,剧痛的&lt;br&gt;
converge:(观点,目标)趋同&lt;br&gt;
somewhat:有点儿,有几分&lt;br&gt;
signpost:路标,标志物&lt;br&gt;
secure:(尤指经过努力)获得,取得,实现&lt;br&gt;
technician:技师,技术人员&lt;br&gt;
therapy:治疗,疗法&lt;br&gt;
wellbeing:幸福&lt;br&gt;
instinctively:本能地&lt;br&gt;
have/get sth down to an art/a fine art = do sth very well&lt;br&gt;
dictate:影响,决定,支配&lt;br&gt;
suppress:抑制(感情)&lt;br&gt;
take sth too far:将某事做的太过&lt;br&gt;
end up doing:最终处于&lt;br&gt;
brush/sweep sth under the carpet:掩盖某事,尤指错事&lt;br&gt;
fiver:五美元&lt;br&gt;
silver bullet:解决某一难题的良方,高招&lt;br&gt;
indulge:沉溺于,沉湎于,纵情于&lt;br&gt;
endorphin:内啡肽&lt;br&gt;
fight off:抵挡,击退,竭力摆脱&lt;br&gt;
spree:狂欢,作乐&lt;br&gt;
side effect:副作用&lt;br&gt;
an awful lot of:许多,多的可怕&lt;br&gt;
have the luxury of:难的能享受某种机会&lt;br&gt;
lure:诱使,引诱&lt;br&gt;
volume:体积&lt;br&gt;
sheer:十足的,彻底的,纯粹的&lt;br&gt;
speculate:推测&lt;br&gt;
capital:首都;国都;&lt;strong&gt;资本&lt;/strong&gt;;资金;启动资金;财富;财产adj.死刑的;大写的;顶好的;极好的&lt;br&gt;
impoverished:贫困的&lt;br&gt;
wasteland:荒地,不毛之地&lt;br&gt;
the masses:普通老百姓&lt;br&gt;
mutually exclusive:互相排斥&lt;br&gt;
mortality:死亡人数&lt;br&gt;
agonizing:痛苦难忍&lt;br&gt;
follow from:是..的必然结果&lt;br&gt;
vision:憧憬&lt;br&gt;
end:目的&lt;br&gt;
degrading:丧失体面的&lt;br&gt;
overblow:夸张,过分渲染&lt;br&gt;
lengthy:长时间的,冗长的&lt;br&gt;
tricky:狡猾的&lt;br&gt;
the demands of sth:困难的/烦人的/累人的事&lt;br&gt;
counterbalance:使平衡,抵消&lt;/p&gt;
">做题词汇积累</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/nei-cun-guan-li-gai-nian-bu-fen/"" data-c="
          &lt;h2 id=&#34;1-基本原理和要求&#34;&gt;1 基本原理和要求&lt;/h2&gt;
&lt;h3 id=&#34;1-内存管理的功能&#34;&gt;1 内存管理的功能&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;内存空间的分配与回收&lt;/li&gt;
&lt;li&gt;地址转换&lt;/li&gt;
&lt;li&gt;内存空间的扩充&lt;/li&gt;
&lt;li&gt;存储保护&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/26/0PHSu4.png&#34; alt=&#34;0PHSu4.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/26/0P7j3T.png&#34; alt=&#34;0P7j3T.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-程序装入和链接&#34;&gt;2 程序装入和链接&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;静态链接&lt;/li&gt;
&lt;li&gt;装入时动态链接&lt;/li&gt;
&lt;li&gt;运行时动态链接&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-装入内存的三种方式&#34;&gt;3 装入内存的三种方式&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;绝对装入
&lt;ul&gt;
&lt;li&gt;编译时,编译程序产生绝对地址的目标代码,&lt;/li&gt;
&lt;li&gt;只适用于单道程序环境&lt;/li&gt;
&lt;li&gt;绝对地址可在编译或汇编时给出,也可由程序员直接赋予&lt;/li&gt;
&lt;li&gt;通常情况下,程序中采用的是符号地址,然后再转换为绝对地址&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可重定位装入
&lt;ul&gt;
&lt;li&gt;指令中使用的地址,数据的地址都是相对于起始地址的逻辑地址&lt;/li&gt;
&lt;li&gt;装入时才重新定位,将逻辑地址转换为物理地址(地址变换是在装入时一次完成的)&lt;/li&gt;
&lt;li&gt;一个作业装入内存时必须分配完所有的内存空间,若果不足,就不能装入&lt;/li&gt;
&lt;li&gt;在运行期间不能移动,也不可再申请新的内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态运行时装入
&lt;ul&gt;
&lt;li&gt;编译链接后的装入模块的地址都是从0开始的&lt;/li&gt;
&lt;li&gt;装入模块装入内存后不会立刻把逻辑地址转换为物理地址,而是把逻辑地址转换为物理地址的过程推迟到程序真正运行时&lt;/li&gt;
&lt;li&gt;需要重定位寄存器,存放装入模块存放的起始地址&lt;/li&gt;
&lt;li&gt;允许程序在内存中移动&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-关于链接和装入的理解&#34;&gt;4 关于链接和装入的理解(☆)&lt;/h3&gt;
&lt;p&gt;不是说上面的链接和装入是一一对应的,静态链接不是说就非得和静态装入(绝对装入)是一块儿的,绝对装入现在都不用了,但是静态链接我们还是用的就可以说明这一问题.&lt;br&gt;
链接是针对程序在磁盘中的,比如静态链接的程序是用到的模块已经固定好啥样了,就像这样&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/26/0P2zTS.png&#34; alt=&#34;0P2zTS.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
然后怎么装入就看哪种方式,现在的应该都是动态装入&lt;br&gt;
静态装入:&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/26/0PWWVK.png&#34; alt=&#34;0PWWVK.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
假设有一个没有错误(err.o),使用动态装入:&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/26/0PWqqP.png&#34; alt=&#34;0PWqqP.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如果动态链接:&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/26/0PoVgg.png&#34; alt=&#34;0PoVgg.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
装入后:&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/26/0Po3CT.png&#34; alt=&#34;0Po3CT.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
装入是怎样将链接好后的程序装入到内存里,当然也可能是没有链接好,但是编译通过了(毕竟动态链接)&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/26/0PTcWT.png&#34; alt=&#34;0PTcWT.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-覆盖和交换&#34;&gt;2 覆盖和交换&lt;/h2&gt;
&lt;p&gt;覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/26/0POkee.png&#34; alt=&#34;0POkee.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/26/0PLbsU.png&#34; alt=&#34;0PLbsU.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-连续分配管理方式&#34;&gt;3 连续分配管理方式&lt;/h2&gt;
&lt;p&gt;连续分配:系统为用户进程分配的必须是一个连续的内存空间&lt;/p&gt;
&lt;h3 id=&#34;1-单一连续分配&#34;&gt;1 单一连续分配&lt;/h3&gt;
&lt;p&gt;一般无需内存保护&lt;br&gt;
优点:简单,无外部碎片,可采用覆盖技术,不需要额外的技术支持&lt;br&gt;
缺点:只适用于单用户,单任务,有内部碎片,利用率低&lt;/p&gt;
&lt;h3 id=&#34;2-固定分区分配&#34;&gt;2 固定分区分配&lt;/h3&gt;
&lt;p&gt;分类:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分区大小相等&lt;/li&gt;
&lt;li&gt;分区大小不等&lt;br&gt;
优点:可用于多道程序的最简单的存储分配,无外部碎片&lt;br&gt;
缺点:不能实现多进程共享一个主存区,所以利用率低,存在内部碎片(当程序小于固定分区大小,也占用一个完整的内存分区,这样分区内部就存在空间浪费,这种现象称为内部碎片);程序可能太大而放不进任意一个分区中,此时用户不得不使用覆盖技术来使用内存空间&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-动态分区分配&#34;&gt;3 动态分区分配&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/09/26/0it6pD.png&#34; alt=&#34;0it6pD.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;内部碎片外部碎片&#34;&gt;内部碎片,外部碎片&lt;/h4&gt;
&lt;p&gt;动态分配没有内部碎片&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/26/0ikxxg.png&#34; alt=&#34;0ikxxg.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
当剩余的内存空间可以满足某进程,但是由于是不连续的碎片,可以采用紧凑(拼凑Compaction)技术来解决&lt;/p&gt;
&lt;h4 id=&#34;1-使用的数据结构&#34;&gt;1 使用的数据结构&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;空闲分区表&lt;/li&gt;
&lt;li&gt;空闲分区链&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/26/0iFZkV.png&#34; alt=&#34;0iFZkV.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;2-分配与回收&#34;&gt;2 分配与回收&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;分配
&lt;ol&gt;
&lt;li&gt;如果那一块未满就更新一下&lt;/li&gt;
&lt;li&gt;如果恰好那一块一样大,就删除表项或结点&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;回收
&lt;ol&gt;
&lt;li&gt;回收区前面有就俩合并,后面有也是,如果前后都有,就三个都合并&lt;/li&gt;
&lt;li&gt;前后都没,插入一个表项&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;适合重定位装入方式,因为连续,且可以移动&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;动态分区分配算法&#34;&gt;动态分区分配算法&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/09/26/0iaEY6.png&#34; alt=&#34;0iaEY6.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;4-非连续分配管理方式&#34;&gt;4 非连续分配管理方式&lt;/h2&gt;
&lt;h3 id=&#34;1-基本分页存储管理方式&#34;&gt;1 基本分页存储管理方式&lt;/h3&gt;
&lt;h4 id=&#34;1-分页存储知识点&#34;&gt;1 分页存储知识点:&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/09/26/0iIUiV.png&#34; alt=&#34;0iIUiV.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/26/0i4neI.png&#34; alt=&#34;0i4neI.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/26/0i48Sg.png&#34; alt=&#34;0i48Sg.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/26/0i4Nmn.png&#34; alt=&#34;0i4Nmn.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/26/0i4BfU.png&#34; alt=&#34;0i4BfU.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/26/0i4fk6.png&#34; alt=&#34;0i4fk6.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;2-基本地址变换机构&#34;&gt;2 基本地址变换机构&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/09/28/0A4sr4.png&#34; alt=&#34;0A4sr4.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h4 id=&#34;3-具有块表的地址变换机构&#34;&gt;3 具有块表的地址变换机构&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;进程切换时,快表被清楚&lt;/li&gt;
&lt;li&gt;查询未命中,访问两次内存,查询命中访问一次&lt;/li&gt;
&lt;li&gt;快慢表同时注意以下:&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/28/0A73He.png&#34; alt=&#34;0A73He.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;局部性原理&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/28/0A7oE4.png&#34; alt=&#34;0A7oE4.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;总结&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/28/0AHkxP.png&#34; alt=&#34;0AHkxP.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;4-两级页表&#34;&gt;4 两级页表&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;单级页表的问题
&lt;ol&gt;
&lt;li&gt;页表必须连续分配,当页表过大时,需要占用过多的连续页框&lt;/li&gt;
&lt;li&gt;没有必要让整个页表常驻内存,进程在一段时间内的运行可能只访问几个特定的页面&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;访问次数(没有块表机构):
&lt;ol&gt;
&lt;li&gt;n级页表,访问n+1次内存,如只有一个页表,则先访问页表,得到块号再访问内存单元(这个别忘了),如果2级则访问顶级页表一次,找到下一级页表所在的块号,访问该块号得到二级页表,找到要访问的内存块号,最后访问内存单元&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;一个页表最多只能占用一个页面,两级不够就继续分&lt;/li&gt;
&lt;li&gt;总结&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/30/0uzIaQ.png&#34; alt=&#34;0uzIaQ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-基本分段存储管理&#34;&gt;2 基本分段存储管理&lt;/h3&gt;
&lt;h4 id=&#34;1-逻辑地址结构&#34;&gt;1 逻辑地址结构&lt;/h4&gt;
&lt;p&gt;段号 段内偏移量&lt;/p&gt;
&lt;h4 id=&#34;2-表项结构&#34;&gt;2 表项结构&lt;/h4&gt;
&lt;p&gt;段号 段长 本段在主存的始址&lt;/p&gt;
&lt;h4 id=&#34;3-寻址过程&#34;&gt;3 寻址过程&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/02/0lZdBQ.png&#34; alt=&#34;0lZdBQ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;3-段页式管理方式&#34;&gt;3 段页式管理方式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/09/30/0uzIaQ.png&#34; alt=&#34;0uzIaQ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">第三章 内存管理概念部分</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/si-suo-bu-fen-de-ti-mu/"" data-c="
          &lt;ol&gt;
&lt;li&gt;死锁的四个必要条件中无法破坏的是&lt;strong&gt;互斥使用资源&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/25/0CBkjg.png&#34; alt=&#34;0CBkjg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;引入多道程序技术的前提条件之一是系统具有&lt;strong&gt;中断功能&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;资源分配图中无法判断是否处于死锁状态:
&lt;ul&gt;
&lt;li&gt;出现了环路(只满足了循环等待这一必要条件,不是充分条件)&lt;/li&gt;
&lt;li&gt;每个进程结点至少有一条请求边(资源数未知因此不可以判断是否为死锁状态)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接上,可以用于判断是否处于死锁状态
&lt;ul&gt;
&lt;li&gt;没有环路(破坏了必要条件因此可以知道是非死锁的)&lt;/li&gt;
&lt;li&gt;每种资源只有一个,且出现环路(充要条件可知为死锁)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;关于定量判断是否发生死锁的题&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;不会发生死锁的最少资源数&lt;/li&gt;
&lt;li&gt;不会发生死锁的最大进程数&lt;/li&gt;
&lt;li&gt;公式:资源m个,n个进程,每个最大需求k,m≥n(k-1)+1时不会死锁&lt;/li&gt;
&lt;li&gt;解法都是先给到每个进程比最大请求量少一个的资源数,如果是求最少资源,则是刚刚分配的加上1(3个进程,每个都要四个资源,分成3,3,3,然后再来一个给谁都能安全),如果是求进程数,则看能分成几块(比如11个资源,X个进程,每个最多3个,则分成2,2,2,2,2,余一个,给谁都能安全)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;限制用户申请资源的顺序的只有死锁预防,死锁避免和死锁检测与解除都不会限制&lt;/li&gt;
&lt;li&gt;死锁检测和解除时,系统为进程分配资源时不会采取任何措施来限制&lt;/li&gt;
&lt;li&gt;关于三种策略对进程并发性的影响:并发性由大到小::无策略&amp;gt;死锁检测与解除&amp;gt;死锁避免&amp;gt;死锁预防,是与对分配干预的程度相一致的&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
">死锁部分的题目</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/si-suo-de-chu-li-ce-lue/"" data-c="
          &lt;h2 id=&#34;1-总览&#34;&gt;1 总览&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/09/24/wzjCQg.png&#34; alt=&#34;wzjCQg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;2-死锁预防&#34;&gt;2 死锁预防&lt;/h2&gt;
&lt;h3 id=&#34;1-破坏互斥条件&#34;&gt;1 破坏互斥条件&lt;/h3&gt;
&lt;p&gt;使用SPOOLing技术&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/24/wzvK4P.png&#34; alt=&#34;wzvK4P.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
缺点:并不是所有资源都可以改成可共享的资源,并且为了系统安全,很多时候必须保持这种互斥性,因此很多时候都无法破坏互斥条件&lt;/p&gt;
&lt;h3 id=&#34;2-破坏不剥夺条件&#34;&gt;2 破坏不剥夺条件&lt;/h3&gt;
&lt;p&gt;两种策略:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我得不到想要的,就把我占有的释放(无私,成全别人)&lt;/li&gt;
&lt;li&gt;借助操作系统协助,将想要的资源强行抢来,一般需要考虑各进程的优先级&lt;br&gt;
缺点:&lt;/li&gt;
&lt;li&gt;实现起来比较复杂&lt;/li&gt;
&lt;li&gt;释放已获得的资源可能会造成前一阶段工作的失效,因此这种方法只适用于易保存和恢复状态的资源,如cpu&lt;/li&gt;
&lt;li&gt;反复申请和释放资源会增加系统开销,降低系统吞吐量&lt;/li&gt;
&lt;li&gt;若采用方案一,意味着只要暂时得不到某个资源,之前获得的都要放弃,以后重新申请,如果一直发生就会导致进程饥饿&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;3-破坏请求并保持条件&#34;&gt;3 破坏请求并保持条件&lt;/h3&gt;
&lt;p&gt;策略:&lt;br&gt;
进程在运行之前一次申请完所有需要的资源,在资源未满足之前不让它投入运行,一旦运行,这些字眼就一直归他所有,&lt;strong&gt;该进程就不会申请别的任何资源&lt;/strong&gt;&lt;br&gt;
缺点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有些资源可能只要使用很短的时间,因此如果进程的整个运行期间都一直保持着所有资源,就会造成严重的资源浪费,&lt;strong&gt;资源利用率低&lt;/strong&gt;,也可能导致某些进程饥饿&lt;br&gt;
造成饥饿:A类用R1,B类用R2,C类俩都用,AB的不断用,C的就可能弄不着用&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;4-破坏循环等待条件&#34;&gt;4 破坏循环等待条件&lt;/h3&gt;
&lt;p&gt;策略:&lt;br&gt;
顺序资源分配法:先给系统中的资源编号,规定每个进程必须按编号递增的顺序请求资源,同类资源(即编号相同的资源)一次申请完&lt;br&gt;
一个进程只有已占有小编号的资源时,才有资格申请更大编号的资源,按此规则,已持有大编号资源的进程不可能逆向回来申请小编号的资源,从而就不会产生循环等待的现象&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/24/0SF9N4.png&#34; alt=&#34;0SF9N4.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
缺点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不方便添加新的设备,因为可能需要重新分配所有的编号&lt;/li&gt;
&lt;li&gt;进程实际使用资源的顺序可能和编号递增的顺序不一直,会导致资源的浪费,如,我要先用5,很久后用3,只能把3先申请占着,就浪费了.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;5-总结&#34;&gt;5 总结&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/09/24/0SAA0K.png&#34; alt=&#34;0SAA0K.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
注意去分析哲学家进餐中策略避免死锁所对应的方法&lt;/p&gt;
&lt;h2 id=&#34;3-死锁避免&#34;&gt;3 死锁避免&lt;/h2&gt;
&lt;h3 id=&#34;1-安全序列不安全状态死锁的联系&#34;&gt;1 安全序列,不安全状态,死锁的联系&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;安全序列:指系统如果按照这种序列分配资源,则每个进程都能顺利完成&lt;/li&gt;
&lt;li&gt;只要能找到一个安全序列,系统就是安全状态,安全序列可能有多个&lt;/li&gt;
&lt;li&gt;在分配了资源后,系统找不到任何一个安全序列,系统就进入不安全状态,意味着之后&lt;strong&gt;可能&lt;/strong&gt;所有进程都无法顺利的执行下去,但如果有进程提前归还一些资源,&lt;strong&gt;系统有可能回到安全状态&lt;/strong&gt;,不过分配钱总是要考虑最坏情况&lt;br&gt;
&lt;strong&gt;注:1. 如果系统处于安全状态,就一定不会发生死锁&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;2. 如果系统进入不安全状态,就可能发生死锁&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;3. 处于不安全状态未必就是发生了死锁(可能还没有去竞争某一资源),但死锁发生时一定是不安全状态&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;4. 银行家算法的核心思想:在资源分配前预先判断这次分配是否会导致系统进入不安全状态,以此来决定是否答应资源分配请求&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;2-银行家算法&#34;&gt;2 银行家算法&lt;/h3&gt;
&lt;h2 id=&#34;4-死锁检测和解除&#34;&gt;4 死锁检测和解除&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;S为死锁的条件是当且仅当S的状态的资源分配图是不可完全花间的,该条件为死锁定理&lt;/li&gt;
&lt;li&gt;化简之后还连着边的是死锁进程&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;死锁解除&#34;&gt;死锁解除:&lt;/h3&gt;
&lt;p&gt;方法:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;资源剥夺法&lt;/li&gt;
&lt;li&gt;撤销进程法&lt;/li&gt;
&lt;li&gt;进程回退法&lt;br&gt;
对谁动手相对而言:&lt;/li&gt;
&lt;li&gt;优先级低的&lt;/li&gt;
&lt;li&gt;已执行时间短的&lt;/li&gt;
&lt;li&gt;还有较长时间才能完成的&lt;/li&gt;
&lt;li&gt;持有资源多的&lt;/li&gt;
&lt;li&gt;交互式的先不干掉,批处理的先&lt;br&gt;
注意点:&lt;/li&gt;
&lt;li&gt;死锁检测时检查的是资源有向图&lt;/li&gt;
&lt;li&gt;死锁定理是用于处理死锁的&lt;strong&gt;检测死锁&lt;/strong&gt;的方法&lt;/li&gt;
&lt;/ol&gt;
"> 死锁的处理策略</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/zheng-zhi-zhi-shi-dian-sui-shou-ji/"" data-c="
          &lt;ul&gt;
&lt;li&gt;机械唯物主义和形而上学唯物主义是一个,庸俗唯物主义(把意识直接归于物质)是一个&lt;/li&gt;
&lt;li&gt;有一元论也有二元论(认为世界的本质有物质和意识两种)&lt;/li&gt;
&lt;li&gt;唯心主义分为客观(归结为超自然的超人类的客观精神)和主观(把本源归结为个人的感觉或意识)的&lt;/li&gt;
&lt;li&gt;人的本质属性是社会属性,不是什么创造性之类的&lt;/li&gt;
&lt;li&gt;人是不能摆脱必然性的制约,不能超出必然性规定的范围去寻找自由,这是人的自由的限度&lt;/li&gt;
&lt;li&gt;感性认识和理性认识都是人的主观世界所特有的,说什么人工智能可以认识都是错的&lt;/li&gt;
&lt;li&gt;实践也是人所特有的对象化活动,说别的动物,人工智能都是错的&lt;/li&gt;
&lt;li&gt;静止是运动的衡量尺度,注意不要反了&lt;/li&gt;
&lt;li&gt;运动是物质的根本属性和存在方式,不要看到存在方式就感觉错了&lt;/li&gt;
&lt;li&gt;物质的唯一特性是客观实在性&lt;/li&gt;
&lt;li&gt;意识是连接主体和客体的中介&lt;strong&gt;是错的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;唯心主义有辩证的,也有不辩证的,旧唯物主义是不辩证的,完全的形而上学&lt;/li&gt;
&lt;li&gt;实践是马哲独有的,旧唯物没有&lt;/li&gt;
&lt;li&gt;旧唯物在自然观上唯物,历史观上唯心&lt;/li&gt;
&lt;li&gt;发展不是绝对的,无条件的,但发展是永恒的&lt;/li&gt;
&lt;li&gt;新事物一定产生于旧事物之前是错的,但换成&lt;strong&gt;往往&lt;/strong&gt;是对的&lt;/li&gt;
&lt;li&gt;前后相继未必是因果,因为我发生在你之前未必是我导致的你&lt;/li&gt;
&lt;li&gt;闪电和打雷不是因果关系,大气摩擦导致闪电和打雷&lt;/li&gt;
&lt;li&gt;有其因必有其果是错的,有因必有果是对的&lt;/li&gt;
&lt;li&gt;真和假象都是客观存在的,就&lt;strong&gt;不能用正确和错误来形容&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;错觉是错误的观念是对的,但真象是正确的现象是错的&lt;/li&gt;
&lt;li&gt;真象和假象都是现象,因此都是外露的,说任意一个是隐藏的都是错的&lt;/li&gt;
&lt;li&gt;辩证否定是是&lt;strong&gt;自我否定&lt;/strong&gt;,形而上学是外部力量对事物的否定和消灭&lt;/li&gt;
&lt;li&gt;辩证否定的实质是扬弃,形而上学要么肯定一切要么否定一切&lt;/li&gt;
&lt;li&gt;时空是事物存在的形式,但如果说:时间是物质存在的形式也是对的,或者说是空间也对,尤其是结合实例(很多时间变化的词)&lt;/li&gt;
&lt;li&gt;不能将客观辩证法等同唯物辩证法,将主观辩证法等同唯心,两个都是唯物的&lt;/li&gt;
&lt;li&gt;凡事预则立,不预则废:原因与结果&lt;/li&gt;
&lt;li&gt;主体是人,但不是所有的人都是主体&lt;/li&gt;
&lt;li&gt;认识总是滞后于实践是&lt;strong&gt;错误的&lt;/strong&gt;,错在总是,实践,-&amp;gt;认识-&amp;gt;实践&lt;/li&gt;
&lt;li&gt;实践先于认识是对的,但是不能说实践是认识的先导,因为先导是指导,实践并不能指导认识,而是认识指导实践&lt;/li&gt;
&lt;li&gt;实践和认识是合一的:错误,合一是知行合一,是王阳明的唯心主义,应该是同一,但是今天看到知行合一不能算错,因为总书记在16年讲过,题目中如果特地强调是王阳明说的,就是错的,如果只是简单提一下就是对的&lt;/li&gt;
&lt;li&gt;无论是虚幻的还是真实的观念都是对事物的反映,但如果说是&lt;strong&gt;事物本质&lt;/strong&gt;的反映就是错的&lt;/li&gt;
&lt;li&gt;任何观念都能在现实世界中找到物质&amp;quot;原型&amp;quot;是对的&lt;/li&gt;
&lt;li&gt;空口说感性认识和理性认识哪个更更重要是不对的,如果给了一个案例说反映了哪个更重要是可以的&lt;/li&gt;
&lt;li&gt;有用即真理是错的,但说真理一定是有用的是正确的&lt;/li&gt;
&lt;li&gt;有价值的就是真理是错的,真理一定有价值是对的&lt;/li&gt;
&lt;li&gt;实践是客观规律性与主观能动性统一的基础,而不是认识&lt;/li&gt;
&lt;li&gt;实践是认识的起点也是认识的归宿,不要后一句记反了&lt;/li&gt;
&lt;li&gt;不论是感性认识还是理性认识,他们的来源都是实践&lt;/li&gt;
&lt;li&gt;感性认识反映事物的现象,理性认识反映事物的本质&lt;/li&gt;
&lt;li&gt;切记不要看到实践是检验真理的唯一标准就选,尤其是题目前面还有限定的
&lt;ul&gt;
&lt;li&gt;如:在真理标准问题上坚持辩证法,就是要坚持&lt;strong&gt;实践标准的确定性与不确定性的统一&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实践之所以成为检验真理的唯一标准是因为&lt;strong&gt;真理的本性和实践的特点所决定的&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;说的是&lt;strong&gt;本性&lt;/strong&gt;,不是属性啥的,本性在于主观和客观相符合&lt;/li&gt;
&lt;li&gt;特点是直接现实性&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;真理是一元的,价值是多元的&lt;/li&gt;
&lt;li&gt;所有的意识&lt;strong&gt;都是&lt;/strong&gt;物质的反映&lt;/li&gt;
&lt;li&gt;生产力中包含科技是对的,但说科技是生产力中的独立要素是错的,生产力的要素只有3个:劳动资料,劳动对象,劳动者&lt;/li&gt;
&lt;li&gt;说科技是生产劳动中的决定性因素是对的,说是社会历史中的决定性因素是错的&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/12/024O1A.png&#34; alt=&#34;024O1A.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;属于上层建筑的社会意识就是意识形态&lt;/li&gt;
&lt;li&gt;判断生产关系是不是先进就看能不能适应生产力发展,而&lt;strong&gt;判断上层建筑是不是先进要看他服务的经济基础是否适应生产力发展,如果适应,它就是先进的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;不能说社会规律与自然规律都是自觉的
&lt;ul&gt;
&lt;li&gt;社会规律是自觉的&lt;/li&gt;
&lt;li&gt;自然规律是&lt;strong&gt;自发的&lt;/strong&gt;,没有人参与其中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;人类的总体历史进程是不可超越的(不要觉得是错的)&lt;/li&gt;
&lt;li&gt;剥削阶级也可以是人名群众&lt;/li&gt;
&lt;li&gt;各种社会关系中，生产关系属于社会存在，政治关系、思想关系是社会存在的反映，不能列为社会存在
&lt;ul&gt;
&lt;li&gt;因此说社会存在不包括社会关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/10/13/0fDQHJ.png&#34; alt=&#34;0fDQHJ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;物质资料的&lt;strong&gt;生产方式&lt;/strong&gt;构成了人类社会存在和发展的基础,集中体现着人类社会的&lt;strong&gt;物质性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;区分社会经济时代的客观依据是生产工具的状况&lt;/li&gt;
&lt;li&gt;社会发展是由多种力量决定的是错的,社会发展的决定力量是生产力&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;政经&#34;&gt;政经&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;价格由价值决定,反映价值&lt;strong&gt;并反映供求&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;资本的周转速度与周转时间成反比,周转次数成正比(转的次数多了,积累地就多,再转就快了),与固定资产占比成反比,流动资产占比成正比&lt;/li&gt;
&lt;li&gt;简单商品经济发展到资本主义商品生产的新阶段的标志是&lt;strong&gt;劳动力成为商品&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;商品一定是劳动产品&lt;/li&gt;
&lt;li&gt;价值实体就是价值&lt;/li&gt;
&lt;li&gt;商品的使用价值在质上是不同的,价值在质上是同的&lt;/li&gt;
&lt;li&gt;使用价值是商品的自然属性,价值是社会属性&lt;/li&gt;
&lt;li&gt;价值以使用价值为前提&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;具体劳动:1. 创造使用价值;2. &lt;strong&gt;转移生产资料的价值&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;抽象劳动:1. 创造商品的价值;2. &lt;strong&gt;把劳动力商品的价值再生产出来&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;劳动力自身的价值不是由具体劳动转移/创造的,而是&lt;strong&gt;抽象劳动新创造的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;充当贮藏手段的货币必须是&lt;strong&gt;足值的金属货币&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;观念上的货币:符合流通手段&lt;/li&gt;
&lt;li&gt;现实的货币(无论是否足值)符合流通手段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;说XX工具产生剩余价值是错的,例如纺纱机产生剩余价值&lt;/li&gt;
&lt;li&gt;资本积累是指剩余价值资本化&lt;/li&gt;
&lt;li&gt;剩余价值与利润在量上是相等的&lt;/li&gt;
&lt;li&gt;利润掩盖了剩余价值与可变资本的关系
&lt;ul&gt;
&lt;li&gt;利润率=m/(c+v)&lt;/li&gt;
&lt;li&gt;剩余价值率=m/v:反映了剥削程度&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;生产价格=生产成本+平均利润&lt;/li&gt;
&lt;li&gt;资本主义工资的本质是劳动力的价值或价格
&lt;ul&gt;
&lt;li&gt;之所以掩盖了剥削是因为&lt;strong&gt;工资表现为&amp;quot;劳动的价格&amp;quot;&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;经济危机在形式上的可能性是由&lt;strong&gt;货币作为流通和支付手段引起的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;垄断资本的实质在于获得垄断利润&lt;/li&gt;
&lt;li&gt;资本集中实质大吃小,小合并&lt;/li&gt;
&lt;li&gt;国家垄断资本主义的实质都是&lt;strong&gt;私人垄断资本利用国家机器为其服务的手段&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;金融寡头
&lt;ul&gt;
&lt;li&gt;在经济领域实现统治的形式是:参与制&lt;/li&gt;
&lt;li&gt;对国家机器额控制是:同政府的&amp;quot;个人联合&amp;quot;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;马哲&#34;&gt;马哲&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;共性和个性,普遍性和特殊性,一般和个别视为同一层次的,整体和局部不是他们这一层次&lt;/li&gt;
&lt;li&gt;社会基本矛盾是社会发展的根本动力&lt;/li&gt;
&lt;li&gt;实践是社会发展的动力源泉
&lt;ul&gt;
&lt;li&gt;不是什么科技创新啊,或者例子给的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;自然规律创造和改造都不可以&lt;/li&gt;
&lt;li&gt;运动是物质的存在方式和根本属性,时空是物质运动的存在形式&lt;/li&gt;
&lt;li&gt;可能有:
&lt;ul&gt;
&lt;li&gt;可能与不可能&lt;/li&gt;
&lt;li&gt;现实的可能与抽象的可能&lt;/li&gt;
&lt;li&gt;好的可能与坏的可能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;同一内容有多种形式,一个形式也可以反映多种内容&lt;/li&gt;
&lt;li&gt;唯物辩证法认为凡是存在的都是应当灭亡的&lt;/li&gt;
&lt;li&gt;调和论否认对立双方的斗争,一般看到调和是错的&lt;/li&gt;
&lt;li&gt;不包含内部差别的事物就不能存在和发展&lt;/li&gt;
&lt;li&gt;偶然为必然开辟道路&lt;/li&gt;
&lt;li&gt;解决矛盾的形式:
&lt;ul&gt;
&lt;li&gt;矛盾双方同归于尽&lt;/li&gt;
&lt;li&gt;矛盾一方克服另一方&lt;/li&gt;
&lt;li&gt;双方形成协同运动的新形式&lt;/li&gt;
&lt;li&gt;矛盾双方融合成一个新的事物&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;区分质是认识量的前提,考查量是认识质的深化&lt;/li&gt;
&lt;li&gt;共性寓于个性之中,不要记反了&lt;/li&gt;
&lt;li&gt;任何个别都是一般的,任何一般都是个别的&lt;/li&gt;
&lt;li&gt;形而上学只承认克服不承认保留,就是否定一切&lt;/li&gt;
&lt;li&gt;一种活动是否被称为实践是看它
&lt;ul&gt;
&lt;li&gt;是否超出纯粹的意识活动&lt;/li&gt;
&lt;li&gt;是否改变了除实践主体的意识状态之外的其他存在物的状态&lt;/li&gt;
&lt;li&gt;注意目的性和以客观世界作为客体是意识活动也具有的，不可作为区分的标志&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;认识的能动反映的特性：摹写性和创造性&lt;/li&gt;
&lt;li&gt;已经确定的真理是不能推翻的，实践是检验真理的唯一标准是这个还没有变成真理，来看看它是否是真理&lt;/li&gt;
&lt;li&gt;认识世界是为了改造世界&lt;/li&gt;
&lt;li&gt;唯物主义和旧唯物主义都坚持反映论（物到感觉思想的认识路线），但旧唯物主义没有实践和辩证法&lt;/li&gt;
&lt;li&gt;割裂感性理性：唯理论，经验论&lt;/li&gt;
&lt;li&gt;运动静止：诡辩论&lt;/li&gt;
&lt;li&gt;感性认识是理性认识的基础&lt;/li&gt;
&lt;li&gt;真理的内容是主管的,形式是客观的&lt;/li&gt;
&lt;li&gt;事物的性质是由主要矛盾的主要方面决定的&lt;/li&gt;
&lt;li&gt;价值的基本特性:
&lt;ul&gt;
&lt;li&gt;客观性&lt;/li&gt;
&lt;li&gt;主体性(不是主观)&lt;/li&gt;
&lt;li&gt;社会历史性&lt;/li&gt;
&lt;li&gt;多维性&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;没有能动性&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;真理可以说对谁有价值,但不可以说对谁是真理
&lt;ul&gt;
&lt;li&gt;脱离了价值尺度,真理就失去了主体意义是对的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;实践创新才有基础性意义&lt;/li&gt;
&lt;li&gt;实践的主体和客体具有的关系:
&lt;ul&gt;
&lt;li&gt;实践关系:最基本的&lt;/li&gt;
&lt;li&gt;认识关系&lt;/li&gt;
&lt;li&gt;价值关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;价值是一种客观存在,独立于人的认识和评价之外&lt;/li&gt;
&lt;li&gt;实践并不一定总是先于认识&lt;/li&gt;
&lt;li&gt;真理既是相对的也是绝对的,但从真理的发展过程看,任何真理都是由相对真理向绝对真理的转化的一个环节&lt;/li&gt;
&lt;li&gt;真理中包含着某种以后会暴露出来的错误的方面或因素,发展就是在不断排除谬误实现的&lt;/li&gt;
&lt;li&gt;意识形态=观念上层建筑;政治形态=政治上层建筑;经济基础(生产关系)=经济形态;
&lt;ul&gt;
&lt;li&gt;社会形态是经济基础与上层建筑的统一体&lt;/li&gt;
&lt;li&gt;社会制度被视为经济形态的同义语&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;生产关系才是社会存在的范畴,不是所有社会关系都是社会存在&lt;/li&gt;
&lt;li&gt;自然环境正是由人来改变的(并不是说人不能改变自然环境)&lt;/li&gt;
&lt;li&gt;政治法律思想是属于观念上层建筑的,不要一看到政治法律就是政治上层建筑&lt;/li&gt;
&lt;li&gt;社会存在的核心是国家政权,并不是国家
&lt;ul&gt;
&lt;li&gt;国家是一个历史范畴&lt;/li&gt;
&lt;li&gt;是阶级矛盾不可调和的产物&lt;/li&gt;
&lt;li&gt;是一个阶级统治另一个阶级的工具&lt;/li&gt;
&lt;li&gt;社会发展不是一个自发的过程
&lt;ul&gt;
&lt;li&gt;自然规律是自发的&lt;/li&gt;
&lt;li&gt;社会规律是自觉的,必须通过有目的有意识的人的活动才能起作用并表现出来&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;历史有时会向后作巨大的跳跃&lt;/li&gt;
&lt;li&gt;阶级首先是一个&lt;strong&gt;经济实体&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;是历史范畴&lt;/li&gt;
&lt;li&gt;经济范畴&lt;/li&gt;
&lt;li&gt;划分阶级的基础是生产资料的占有关系不同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;劳动是人的存在方式&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
"> 政治知识点随手记</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/si-suo-gai-nian-bu-fen/"" data-c="
          &lt;h2 id=&#34;1-死锁饥饿死循环的区别&#34;&gt;1 死锁,饥饿,死循环的区别&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;死锁的定义:多个进程因竞争资源而造成的一种僵局(互相等待),若无外力作用,这些进程多无法向前推进&lt;/strong&gt;&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/09/25/0CFrmq.png&#34; alt=&#34;0CFrmq.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;2-死锁产生的必要条件&#34;&gt;2 死锁产生的必要条件&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;互斥条件&lt;/li&gt;
&lt;li&gt;不剥夺条件&lt;/li&gt;
&lt;li&gt;请求并保持条件&lt;/li&gt;
&lt;li&gt;循环等待条件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;循环等待条件不是充要条件的原因是:即使循环等待,但其中一个可能需要的资源可以来自链里,也可以来自链外,此时如果链外的那个资源释放了,就不用等待了,但是死锁的时候,一定在循环等待&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;3-死锁产生的原因&#34;&gt;3 死锁产生的原因&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;系统资源的竞争:只有对不可剥夺的资源竞争才会产生死锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程推进顺序非法:请求和释放资源的顺序不当,P1,P2分别保持R1,R2,P1申请R2,P2申请R1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号量使用不当:进程间彼此互等对方发来消息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总之对不可剥夺的资源分配不合理时就会导致死锁&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;4-死锁的处理策略&#34;&gt;4 死锁的处理策略&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;死锁预防&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;避免死锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;死锁的检测和解除&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注:前两种不会产生死锁,后一种是死锁产生后的解决&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;5-总结&#34;&gt;5 总结&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/09/24/wzXPV1.png&#34; alt=&#34;wzXPV1.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">死锁概念部分</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/bfsdfs-de-yi-xie-ti-he-zhi-shi-dian/"" data-c="
          &lt;h2 id=&#34;bfsdfs的算法开销&#34;&gt;BFS/DFS的算法开销&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;时间复杂度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;来源:访问顶点以及查找顶点的邻接点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于BFS/DFS,如果邻接矩阵表示,则访问顶点为O(|V|),查找顶点邻接点(需要遍历整个矩阵)为O(|V|²)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果是邻接表,则前者为O(|V|),后者为2|E|,也就是O(|E|)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;分析的时候不要一味的看代码找循环&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;空间复杂度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;BFS:O(|V|):最坏发散的&lt;/p&gt;
&lt;p&gt;DFS:O(|V|):最坏连着一串的,最好发散的&lt;/p&gt;
&lt;h2 id=&#34;bfsdfs调用次数&#34;&gt;BFS/DFS调用次数&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;无向图:&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;几个连通分量就调用几次&lt;/p&gt;
&lt;p&gt;若是连通图,则调用一次即可&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;有向图:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;具体分析&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果起始顶点到其他顶点都有路径,则只调用一次&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果是强连通图,则从任意顶点出发都只调用一次&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意:DFS可以用于判断G是否有环:无向图在DFS中遇到回边则说明有环,有向图中回边可能是生成树森林中别的树指向的,也可能是环,因此需要判断一下,但是可以用&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;&#34;&gt;&lt;/h2&gt;
&lt;p&gt;2 判断无向图为树&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool isTree(Graph G)
{
    for(v=0;v&amp;lt;G.vexnum;v++)
        visited[v]=false;
    int c=0;
    int flag=0;
    for(v=0;v&amp;lt;G.vexnum;v++)
    {
        if(!visited[v])
        {
            if(c=1)//说明调用过一次了,再调用就是非连通的,不是一棵树
                return false;
            else
            {
                DFS(G,v,&amp;amp;flag);
                c++;
            }
        }
    }
    if(flag==1) return false;
    return true;
}
void DFS(Graph G,int v,int &amp;amp;flag)
{
    visit(v);
    visited[v]=true;
    for(w=FirstNeighbor(G,v);w&amp;gt;=0;w=NextNeighbor(G,v,w))
    {
        if(visited[w])//访问过,说明有环
        {
            flag=1;
        }
        else
        {
            DFS(G,w,flag);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;3-dfs的非递归实现&#34;&gt;3 DFS的非递归实现&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void DFS_NotRC(Graph G,int v)
{
    int w;
    Stack S;
    for(w=0;w&amp;lt;G.vexnum;w++)
        visited[w]=false;
    S.Push(v);visited[v]=true;
    while(!S.Isempty())
    {
        int k=S.Pop();
        for(w=FirstNeighbor(G,k);w&amp;gt;=0;w=NextNeighbor(G,k,w))
        {
            if(!visited[w])//未被访问过,入栈,置位true
            {
                S.Push(w);
                visited[w]=true;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
">BFS/DFS的一些题和知识点</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/tu-de-ying-yong/"" data-c="
          &lt;h2 id=&#34;1-最小生成树&#34;&gt;1 最小生成树&lt;/h2&gt;
&lt;h3 id=&#34;1-概念及注意&#34;&gt;1 概念及注意&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;针对的是带权无向图&lt;/li&gt;
&lt;li&gt;如果本身就是一棵树,则它的最小生成树就是本身&lt;/li&gt;
&lt;li&gt;只有连通图才有生成树,非连通图只有生成森林&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2-实现算法&#34;&gt;2 实现算法&lt;/h2&gt;
&lt;h3 id=&#34;1-prim算法&#34;&gt;1 Prim算法&lt;/h3&gt;
&lt;p&gt;从某一顶点开始构建生成树;每次将代价最小的新顶点纳入生成树,直到所有顶点都纳入为止&lt;/p&gt;
&lt;p&gt;时间复杂度:O(|V|²)&lt;/p&gt;
&lt;p&gt;适合边稠密的图&lt;/p&gt;
&lt;h3 id=&#34;2-kruskal算法&#34;&gt;2 Kruskal算法&lt;/h3&gt;
&lt;p&gt;每次选择一条权值最小的边,使这条边的两头连通(已经连通的就不选)直到所有的结点都连通&lt;/p&gt;
&lt;p&gt;时间复杂度:O(|E|log&lt;sub&gt;2&lt;/sub&gt;|E|)&lt;/p&gt;
&lt;p&gt;适合边稀疏而顶点较多的图&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/09/21/wbOhBF.png&#34; alt=&#34;wbOhBF.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/09/21/wbOXnO.png&#34; alt=&#34;wbOXnO.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;2-最短路径&#34;&gt;2 最短路径&lt;/h2&gt;
&lt;h3 id=&#34;分类&#34;&gt;分类&lt;/h3&gt;
&lt;p&gt;单源最短路径:BFS(无权图),Dijkstra算法(无权/带权)&lt;/p&gt;
&lt;p&gt;各顶点之间的最短路径:Floyd算法(无权/带权)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当图是带权图时,一条路径上所有边的权值之和称为带权路径长度&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;1-bfs求最短路径&#34;&gt;1 BFS求最短路径&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void BFS_Min_Distance(Graph G,int u)
{
    for(int i=0;i&amp;lt;G.vexnum;i++)
    {
        visited[i]=false;
        d[i]=∞;
        p[i]=-1;
    }
    d[u]=0;visited[u]=true;
    Queue Q;
    EnQueue(Q,u);
    for(w=FirstNeighbor(G,u);w&amp;gt;=0;w=NextNeighbor(G,u,w))
    {
        DeQueue(Q,u);
        if(!visited[u])
        {
            d[w]=d[u]+1;
            p[w]=u;
            visited=true;
            EnQueue(Q,w);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;2-dijkstra算法&#34;&gt;2 DijKstra算法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;不适用于带有负权值的图&lt;/li&gt;
&lt;li&gt;时间复杂度O(|V|²)&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/09/21/wqe4bQ.png&#34; alt=&#34;wqe4bQ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-floyd算法&#34;&gt;3 Floyd算法&lt;/h3&gt;
&lt;p&gt;若 A&lt;sup&gt;(k-1)&lt;/sup&gt;[i] [j]&amp;gt; A&lt;sup&gt;(k-1)&lt;/sup&gt;[i] [k]+ A&lt;sup&gt;(k-1)&lt;/sup&gt;[k] [j]&lt;/p&gt;
&lt;p&gt;则 A&lt;sup&gt;(k)&lt;/sup&gt;[i] [j]=A&lt;sup&gt;(k-1)&lt;/sup&gt;[i] [k]+ A&lt;sup&gt;(k-1)&lt;/sup&gt;[k] [j]&lt;/p&gt;
&lt;p&gt;Path&lt;sup&gt;(k)&lt;/sup&gt;=k&lt;/p&gt;
&lt;p&gt;否则A&lt;sup&gt;(k)&lt;/sup&gt;[i] [j]和Path&lt;sup&gt;(k)&lt;/sup&gt;保持原值&lt;/p&gt;
&lt;h4 id=&#34;算法代码实现&#34;&gt;算法代码实现&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;void Floyd_Min_Distance(Graph G)
{
    for(k=0;k&amp;lt;n;k++)
        for(i=0;i&amp;lt;n;i++)
            for(j=0;j&amp;lt;n;j++)
            {
                if(A[i][j]&amp;gt;A[i][k]+A[k][j])
                    A[i][j]=A[i][k]+A[k][j];
            }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开销:&lt;/p&gt;
&lt;p&gt;时间复杂度:O(|V|³)&lt;/p&gt;
&lt;p&gt;空间复杂度:O(|V|²)&lt;/p&gt;
&lt;p&gt;可以用于负权值的图,但是&lt;strong&gt;不可以用于&lt;/strong&gt;带负权值的回路&lt;/p&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/09/23/wjiWfx.png&#34; alt=&#34;wjiWfx.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;4-总结&#34;&gt;4 总结&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/09/23/wjFwEd.png&#34; alt=&#34;wjFwEd.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;5-有向无环图dagdirected-acyclic-graph描述表达式&#34;&gt;5 有向无环图(DAG:Directed Acyclic Graph)描述表达式&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/09/23/wjmgWd.png&#34; alt=&#34;wjmgWd.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;6-拓扑排序&#34;&gt;6 拓扑排序&lt;/h3&gt;
&lt;h4 id=&#34;1aov网activity-on-vertex-network用顶点表示活动的网&#34;&gt;1.AOV网(Activity On Vertex Network):用顶点表示活动的网&lt;/h4&gt;
&lt;h4 id=&#34;2-拓扑排序代码实现&#34;&gt;2. 拓扑排序代码实现&lt;/h4&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool TopoLogicalSort(Graph G)
{
    Stack S;
    for(int i=0;i&amp;lt;G.vexnum;i++)
    {
        if(indegree[i]==0)//入度为0的进栈
            S.Push(i);
    }
    int count=0;
    while(!S.isEmpty())
    {
        i=S.Pop();//栈顶元素出栈
        print[count++]=i;//记录出栈序列,即为拓扑排序
        for(p=G.verticle[i].firstarc;p;p=p-&amp;gt;nextarc)//遍历所有与i顶点所连的边
        {
            v=p-&amp;gt;adjvex;//v是顶点i指向的点
            if(!(--index[v]))//所有i指向的点的入度都减一
            {
                S.Push(v);//减完之后入度为0的说明又可以作为下一个入栈的点
            }
            
        }//for
    }//while
    if(count&amp;lt;G.vexnum)//手动画一遍即可知如果有环,会在遍历完所有结点前,栈就空了,因此会提前跳出while循环而导致count值小于G.vexnum
    {
        return false;//有环
    }
    else
        return true;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是邻接表存储的,时间复杂度为O(|V|+|E|);&lt;/p&gt;
&lt;p&gt;如果采用的是邻接矩阵存储则为O(|V|²);&lt;/p&gt;
&lt;h4 id=&#34;3逆拓扑排序&#34;&gt;3.逆拓扑排序&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;倒过来,找出度为0的,用临界矩阵或逆邻接表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DFS(不咋对,别看了)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不带判断环的只要在DFS的最后打印顶点就行&lt;/li&gt;
&lt;li&gt;带判断的&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&#34;language-c&#34;&gt;bool isTree(Graph G)
{
    for(v=0;v&amp;lt;G.vexnum;v++)
        visited[v]=false;
    int c=0;
    int flag=0;
    for(v=0;v&amp;lt;G.vexnum;v++)
    {
        if(!visited[v])
        {
            if(c=1)//说明调用过一次了,再调用就是非连通的,不是一棵树
                return false;
            else
            {
                DFS(G,v,&amp;amp;flag);
                c++;
            }
        }
    }
    if(flag==1) return false;
    return true;
}
void DFS(Graph G,int v,int &amp;amp;flag)
{
    //visit(v);
    visited[v]=true;
    for(w=FirstNeighbor(G,v);w&amp;gt;=0;w=NextNeighbor(G,v,w))
    {
        if(visited[w])//访问过,说明有环
        {
            flag=1;
        }
        else
        {
            DFS(G,w,flag);
        }
    }
    print(v);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/09/25/0CkpHP.png&#34; alt=&#34;0CkpHP.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;7-关键路径&#34;&gt;7 关键路径&lt;/h3&gt;
&lt;h3 id=&#34;1-aoe网&#34;&gt;1 AOE网&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/09/23/wvft0J.png&#34; alt=&#34;wvft0J.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/09/23/wvfBp6.png&#34; alt=&#34;wvfBp6.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
"> 图的应用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-wu-zhang-er-cha-shu-ji-xian-suo-er-cha-shu-de-chong-dian-ji-cuo-ti-zheng-li/"" data-c="
          &lt;h2 id=&#34;1-概念&#34;&gt;1 概念&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;线索二叉树是一种物理结构&lt;/li&gt;
&lt;li&gt;后序线索二叉树无法很好的用于寻找后继结点,例如右子树最右下脚的有左右孩子结点的结点,它的后继应该指向根结点,但是没有空的链域了,&lt;strong&gt;因此需要借助栈来实现,也是三种线索二叉树中唯一一个在遍历时需要借助栈的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;先序和后续序列正好相反的条件是只有一个叶子结点,也即结点个数就是树的高度&lt;/li&gt;
&lt;/ol&gt;
">第五章 二叉树及线索二叉树的重点及错题整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/guan-yu-han-shu-de-can-shu-shi-shi-shi-yong-zhi-zhen-huan-shi-zhi-zhen-de-yin-yong-zhi-zhen-de-zhi-zhen-er-ji-zhi-zhen/"" data-c="
          &lt;ol&gt;
&lt;li&gt;当只修改p指向的对象(对象的内容啥的)&lt;br&gt;
例如:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;typedef struct node{
    int data;
    struct node next;
}Node,List*;//再用List p就相当于Node *p;
List p=(Node*)malloc(sizeof(Node));
List q=(Node*)malloc(sizeof(Node));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指针p和q分别指向了两个不同的Node对象&lt;br&gt;
如果一个函数fun()要改变p的data或next指向的对象,直接传递p即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void fun(List p)
{
    p-&amp;gt;data=xx;
    p-&amp;gt;next=p;//或者NULL,啥别的都行
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是要修改p指向q的对象,就得引用了,因为只是指针的话,参数的传递实际上传的是指针变量里那个地址(对象的地址),而如果要改变指向(就是改变指针变量的值),必须是引用指针,就好比传一个int类型,你是没法改变传值进去的那个变量的值的,指针变量也是一个道理,改变不了那个地址,因此要用引用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void fun2(List &amp;amp;p,List q)
{
    p=q;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面是C语言的测试(C语言没得引用就用了二级指针)&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/23/dBQiad.png&#34; alt=&#34;dBQiad.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
void fun(int *p)
{
    *p=100;
}
void fun2(int **p,int *q)
{
    printf(&amp;quot;infun2  %p\n&amp;quot;,q);
    *p=q;
    printf(&amp;quot;in fun2  *p     %p\n&amp;quot;,*p);
}
int main()
{
    int a=1;
    int b=2;
    int *p=&amp;amp;a;
    int *q=&amp;amp;b;
    printf(&amp;quot;p: %p\n&amp;quot;,p);
    printf(&amp;quot;&amp;amp;a: %p\n&amp;quot;,&amp;amp;a);
    printf(&amp;quot;&amp;amp;p:  %p\n&amp;quot;,&amp;amp;p);
    printf(&amp;quot;q:  %p\n&amp;quot;,q);
    printf(&amp;quot;&amp;amp;b: %p\n&amp;quot;,&amp;amp;b);
    printf(&amp;quot;&amp;amp;q: %p\n&amp;quot;,&amp;amp;q);
    fun(p);
    printf(&amp;quot;%d\n&amp;quot;,*p);
    printf(&amp;quot;%p\n&amp;quot;,p);
    fun2(&amp;amp;p,q);
    printf(&amp;quot;%d\n&amp;quot;,*p);
    printf(&amp;quot;%p\n&amp;quot;,p);
    printf(&amp;quot;Hello world!\n&amp;quot;);
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面是c++的测试,使用了引用&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/23/dB3uqO.png&#34; alt=&#34;dB3uqO.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;iostream&amp;gt;

using namespace std;
typedef struct node{
    int data;
    struct node *next;
}Node,*List;
void ChangeData(List l)
{
    l-&amp;gt;data=100;
}
void NotYingyong(List l,List j)
{
    cout&amp;lt;&amp;lt;&amp;quot;In NOtYingyong:&amp;quot;&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;l-&amp;gt;data=: &amp;quot;&amp;lt;&amp;lt;l-&amp;gt;data&amp;lt;&amp;lt;endl;
    l=j;
    cout&amp;lt;&amp;lt;&amp;quot;After change: &amp;quot;&amp;lt;&amp;lt;l-&amp;gt;data&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;Finish NotYingyong&amp;quot;&amp;lt;&amp;lt;endl;
}
void Yingyong(List &amp;amp;l,List j)
{
    l=j;
}
int main()
{
    Node n1,n2,n3;
    n1.data=1;
    n1.next=&amp;amp;n3;
    n2.data=2;
    n2.next=&amp;amp;n3;
    n3.data=3;
    n3.next=NULL;
    List l1=&amp;amp;n1;
    List l2=&amp;amp;n2;
    List l3=&amp;amp;n3;
    cout&amp;lt;&amp;lt;&amp;quot;l1: &amp;quot;&amp;lt;&amp;lt;l1&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;&amp;quot;l2: &amp;quot;&amp;lt;&amp;lt;l2&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;&amp;quot;l3: &amp;quot;&amp;lt;&amp;lt;l3&amp;lt;&amp;lt;endl;
    ChangeData(l3);
    cout&amp;lt;&amp;lt;&amp;quot;l3 change:  &amp;quot;&amp;lt;&amp;lt;l3-&amp;gt;data&amp;lt;&amp;lt;endl;
    NotYingyong(l1,l3);
    cout&amp;lt;&amp;lt;&amp;quot;after NotYingyong l1: &amp;quot;&amp;lt;&amp;lt;l1-&amp;gt;data&amp;lt;&amp;lt;endl;
    Yingyong(l2,l3);
    cout&amp;lt;&amp;lt;&amp;quot;after Yingyong l2: &amp;quot;&amp;lt;&amp;lt;l2-&amp;gt;data&amp;lt;&amp;lt;endl;
    cout&amp;lt;&amp;lt;&amp;quot;after change&amp;quot;&amp;lt;&amp;lt;&amp;quot;l1: &amp;quot;&amp;lt;&amp;lt;l1&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;&amp;quot;l2: &amp;quot;&amp;lt;&amp;lt;l2&amp;lt;&amp;lt;endl&amp;lt;&amp;lt;&amp;quot;l3: &amp;quot;&amp;lt;&amp;lt;l3&amp;lt;&amp;lt;endl;
    cout &amp;lt;&amp;lt; &amp;quot;Hello world!&amp;quot; &amp;lt;&amp;lt; endl;
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
">关于函数的参数是是使用指针,还是指针的引用(指针的指针,二级指针)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-wu-zhang-xian-suo-er-cha-shu/"" data-c="
          &lt;h2 id=&#34;11-线索二叉树&#34;&gt;1.1 线索二叉树&lt;/h2&gt;
&lt;h3 id=&#34;111-基本概念&#34;&gt;1.1.1 基本概念&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/08/23/d0VWvj.png&#34; alt=&#34;d0VWvj.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;记录前驱和后继是针对某一种遍历来的,不同的遍历方式对某一结点有不同的前驱后继&lt;/li&gt;
&lt;li&gt;结点结构&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/23/d0kq8H.png&#34; alt=&#34;d0kq8H.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;标志域含义&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/23/d0kxqP.png&#34; alt=&#34;d0kxqP.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;结点存储结构的代码描述&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;typedef struct ThreadNode{
    ElemType data;  //数据元素
    struct ThreadNode *lchild,rchild;  //左右孩子指针
    int ltag,rtag;   //左右线索标志
}ThreadNode ,*ThreadTree;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;以这种结点构成的二叉链表作为二叉树的存储结构,称为&lt;strong&gt;线索链表&lt;/strong&gt;,指向前驱和后继的指针称为线索,加了线索的二叉树叫做线索二叉树&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;112-构造&#34;&gt;1.1.2 构造&lt;/h3&gt;
&lt;h4 id=&#34;1121-中序线索二叉树的构造&#34;&gt;1.1.2.1 中序线索二叉树的构造&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/08/23/d0E4AK.png&#34; alt=&#34;d0E4AK.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;中序遍历找某一结点的前驱&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;BiNode *pre=NULL;//遍历时的前驱结点
BiNode *final=NULL;//最终的前驱
BiNode * p;//目标结点
void FindPre(BiNode *q)
{
    if(q=p)
        final=pre;找到了
    else
        pre=q;//往下走
}
void InOrder(Bitree T)
{
    InOrder(T-&amp;gt;lchild);
    FindPre(T);
    InOrder(T-&amp;gt;rchild);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;中序线索二叉树的构造(实质就是再遍历一遍,然后找符合条件的连一连线)&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;ThreadNode * pre=NULL;
void visist(ThreadNode *q)//对遍历到的每个结点处理前驱后继
{
    if(q-&amp;gt;lchild==NULL)//当前结点的左孩子为空,指向左孩子
    {
        q-&amp;gt;child=pre;
        q-&amp;gt;ltag=1;
    }
    if(pre!=NULL&amp;amp;&amp;amp;pre-&amp;gt;rchild==NULL)//前驱的右孩子为空
    {
        pre-&amp;gt;rchild=q;
        pre-&amp;gt;rtag=1;
    }
    pre=q;
}
void InThread(ThreadTree T)//中序遍历
{
    InThread(T-&amp;gt;lchild);
    visit(T);
    InThread(T-&amp;gt;rchild);
}
void CreateThreadTree(Thread T)//中序遍历构造线索二叉树
{
    pre=NULL;
    if(T!=NULL)
    {
        InThread(T);
        pre-&amp;gt;rchild=NULL;//处理最后一个结点
        pre-&amp;gt;rtag=1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1122-先序&#34;&gt;1.1.2.2 先序&lt;/h4&gt;
&lt;p&gt;和中序的区别不大,但是到最左下角的时候,如果没有左子树了,会指向前驱,但是再到PreThread函数中时,往下执行,会再次返回到他的前驱,然后又到他,死循环&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/23/d06wtI.png&#34; alt=&#34;d06wtI.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
因此需要在其中判断是不是真的指向左子树if(T-&amp;gt;ltag==0)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ThreadNode * pre=NULL;
/********visit()函数是一毛一样的****/
void visist(ThreadNode *q)//对遍历到的每个结点处理前驱后继
{
    if(q-&amp;gt;lchild==NULL)//当前结点的左孩子为空,指向左孩子
    {
        q-&amp;gt;child=pre;
        q-&amp;gt;ltag=1;
    }
    if(pre!=NULL&amp;amp;&amp;amp;pre-&amp;gt;rchild==NULL)//前驱的右孩子为空
    {
        pre-&amp;gt;rchild=q;
        pre-&amp;gt;rtag=1;
    }
    pre=q;
}
void PreThread(ThreadTree T)//序遍历
{
    visit(T);
    if(T-&amp;gt;ltag==0)//lchild指向的不是线索而是真正的左孩子
        InThread(T-&amp;gt;lchild);
    InThread(T-&amp;gt;rchild);
}
void CreateThreadTree(Thread T)//先序遍历构造线索二叉树
{
    pre=NULL;
    if(T!=NULL)
    {
        InThread(T);
        pre-&amp;gt;rchild=NULL;//处理最后一个结点
        pre-&amp;gt;rtag=1;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1123-后序线索二叉树&#34;&gt;1.1.2.3 后序线索二叉树&lt;/h4&gt;
&lt;p&gt;visit()一毛一样&lt;br&gt;
PostThread()里顺序改改就行&lt;br&gt;
不同:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void PostThread(ThreadTree T)
{
    PostThread(T-&amp;gt;lchild);
    PostThread(T-&amp;gt;rchild);
    visit(T);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;1124-小结&#34;&gt;1.1.2.4 小结&lt;/h4&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/08/23/d0vmuD.png&#34; alt=&#34;d0vmuD.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;113-线索二叉树的遍历&#34;&gt;1.1.3 线索二叉树的遍历&lt;/h3&gt;
&lt;h4 id=&#34;1131-中序&#34;&gt;1.1.3.1 中序&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;找某一中序序列下的第一个结点,其实就是给了个子树的根,一直往左下跑&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;ThreadNode *FirstNode(ThreadNode *p)
{
    while(p-&amp;gt;ltag==0)
    {
        p=p-&amp;gt;lchild;
    }
    return p;
}
&lt;/code&gt;&lt;/pre&gt;
">第五章 线索二叉树</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-wu-zhang-er-cha-shu-de-bian-li-he-xian-suo-er-cha-shu/"" data-c="
          &lt;h2 id=&#34;11-二叉树的遍历&#34;&gt;1.1 二叉树的遍历&lt;/h2&gt;
&lt;h3 id=&#34;111-深度遍历递归算法&#34;&gt;1.1.1 深度遍历递归算法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;PreOrder&lt;br&gt;
顺序:根-&amp;gt;左子树-&amp;gt;右子树&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;void PreOrder(BiTree T)
{
    if(T!=NULL)
    {
        visit(T);
        PreOrder(T-&amp;gt;lchild);
        PreOrder(T-&amp;gt;rchild);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;InOrder&lt;br&gt;
顺序:左子树-&amp;gt;根-&amp;gt;右子树&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;void InOrder(BiTree T)
{
    if(T!=NULL)
    {
        InOrder(T-&amp;gt;lchild);
        visit(T);
        InOrder(T-&amp;gt;rchild);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;PostOrder&lt;br&gt;
顺序:左子树-&amp;gt;右子树-&amp;gt;根&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;void PostOrder(BiTree T)
{
    if(T!=NULL)
    {
        PostOrder(T-&amp;gt;lchild);
        PostOrder(T-&amp;gt;rchild);
        visit(T);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;112-深度遍历非递归算法&#34;&gt;1.1.2 深度遍历非递归算法&lt;/h3&gt;
&lt;p&gt;难就难在递归到非递归的转换&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;PreOrder&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;void PreOrder(BiTree T)
{
    Stack s;
    BiTree p=T;
    while(p||!IsEmpty(s))
    {
        if(p)
        {
            visit(p);
            Push(s,p);
            p=p-&amp;gt;leftchild;
        }
        else
        {
            Pop(s,p);
            p=p-&amp;gt;rchild;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;InOrder&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;void InOrder(BiTree T)
{
    Stack s;
    BiTree p=T;
    while(p||!IsEmpty(s))
    {
        if(p)
        {
            Push(p);
            p=p-&amp;gt;lchild;
        }
        else
        {
            Pop(p);
            visit(p);
            p=p-&amp;gt;rchild;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;PostOrder&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;void PostOrder(BiTree T)
{
    Stack s;
    BiTree p=T;
    BiTree r=NULL;
    while(p||!sEmpty(s))
    {
        if(p)
        {
            Push(s,p);
            p=p-&amp;gt;lchild;
        }
        else//没得左子树了
        {
            Top(s,p);//栈顶元素
            if(p-&amp;gt;rchild&amp;amp;&amp;amp;p-&amp;gt;rchild!=r)//右子树如果存在且没有被访问过
            {
                p=p-&amp;gt;rchild;//把右子树的根结点入栈
                Push(s,p);
                p=p-&amp;gt;lchild;继续转向左子树
            }
            else//右子树访问过或者不存在右子树,就可以安心地访问这个根结点了
            {
                Pop(s,p);
                visit(p);
                r=p;//记录一哈这个访问过了,万一是右子树的根的话,他的老头就会知道自己的右子树访问过了
                p=NULL;//p不空的唯一用途就是一直往下寻找左子树,因此置空则是为了表明可以回退去找右子树了
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;113-一些总结&#34;&gt;1.1.3 一些总结&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;三种遍历算法中,递归遍历左子树,右子树都是固定的,只是访问根结点的顺序不同,不管哪种方式,根结点都访问且仅访问一次,&lt;strong&gt;时间复杂度为O(n)&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;空间复杂度和栈的深度有关,最坏是O(n)(一条从上到下)
&lt;ol&gt;
&lt;li&gt;栈的深度是树的深度&lt;/li&gt;
&lt;li&gt;递归工作栈和非递归用的栈都是&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用途(☆):访问p的时候,此时栈内恰好是p结点的所有祖先,从栈底到栈顶再加上p正好构成从根结点到p结点的一条路径.&lt;/p&gt;
&lt;h3 id=&#34;114-广度层次遍历&#34;&gt;1.1.4 广度(层次)遍历&lt;/h3&gt;
&lt;p&gt;自上而下,自左向右的遍历&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void LevelOrder(BiTree T)
{
    Queue q;
    BiTree p=T;
    EnQueue(q,p);
    while(!IsEmpty(q))//队列非空
    {
        DeQueue(q,p);
        visit(p);
        if(p-&amp;gt;lchild)
            EnQueue(q,p-&amp;gt;lchild);
        if(p-&amp;gt;rchild)
            EnQueue(q,p-&amp;gt;rchild);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;115-由遍历序列构造二叉树&#34;&gt;1.1.5 由遍历序列构造二叉树&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;先序和中序唯一确定一棵二叉树
&lt;blockquote&gt;
&lt;p&gt;在先序遍历序列中，第一个结点一定是二叉树的根结点；而在中序遍历中，根结点必然将中序序列分割成两个子序列，前一个子序列是根结点的左子树的中序序列，后一个子序列是根结点的右子树的中序序列。根据这两个子序列，在先序序列中找到对应的左子序列和右子序列。在先序序列中，左子序列的第一个结点是左子树的根结点，右子序列的第一个结点是右子树的根结点。如此递归地进行下去，便能唯一地确定这棵二叉树。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;先序序列的第一个是根结点(老祖宗),然后在中序序列中从前到后找到老祖宗,根据老祖宗将中序队列划成左子树和右子树的序列&lt;/li&gt;
&lt;li&gt;左子树再从先序序列找到根(小祖宗了),依次进行,右子树也是......&lt;/li&gt;
&lt;li&gt;以先序(ABCDEFGHI),中序(BCAEDGHFI)为例&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;先序中,第一个A,老祖宗,在中序中发现A将BC,EDGHFI隔开,因此左子树是BC,右子树是EDGHFI&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/23/dw5kPH.png&#34; alt=&#34;dw5kPH.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
再看BC,先序BC,因此B是根结点,而中序中也是BC,故而C是右子树的&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/23/dw5msP.png&#34; alt=&#34;dw5msP.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
再看右子树EDGHFI,先序是DEFGHI,故而D是根结点,因此在中序中看,D将EDGHFI分成了E和GHFI,E是左子树了&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/23/dw51iQ.png&#34; alt=&#34;dw51iQ.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
再看GHFI,先序为FGHI,故而F为其根,因此,GH为左子树,I为右子树&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/23/dw58Rs.png&#34; alt=&#34;dw58Rs.png&#34; loading=&#34;lazy&#34;&gt;      &lt;img src=&#34;https://s1.ax1x.com/2020/08/23/dw5YMq.png&#34; alt=&#34;dw5YMq.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
先序后序中GH都是GH的顺序(和刚刚BC的理解一样),因此,G为根,H为右子树&lt;br&gt;
完整是:&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/23/dw5szR.png&#34; alt=&#34;dw5szR.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;后序和中序确定一棵二叉树&lt;br&gt;
和前序中序是差不多的,只是倒过来了,这两种本质都是从先序或后序找到根结点,再到相应的中序中划分成左子树对应的序列,右子树对应的序列,将分好的左右子树序列再带入到先序或后序找到对应的序列,先序就是最左边的是左/右子树的根结点,而后序就是最右边的是左/右子树的根结点&lt;/li&gt;
&lt;li&gt;层序序列和中序也可以确定&lt;br&gt;
慢慢分析吧,比前面的简单,跟着序列画几个就出来了&lt;/li&gt;
&lt;li&gt;先序后后序无法确定一棵树&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/23/dwTSrq.png&#34; alt=&#34;dwTSrq.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
">第五章 二叉树的遍历</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-wu-zhang-er-cha-shu/"" data-c="
          &lt;h2 id=&#34;11-注意点&#34;&gt;1.1 注意点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;不存在度大于2的结点&lt;/li&gt;
&lt;li&gt;子树有左右之分,次序不可任意颠倒&lt;/li&gt;
&lt;li&gt;以递归的形式定义:&lt;br&gt;
二叉树是n(n≥0)个结点的有限集合:
&lt;ol&gt;
&lt;li&gt;或者为空二叉树:n=0;&lt;/li&gt;
&lt;li&gt;或者由一个根节点和两个互不相交的被称为根的左子树和右子树组成,左子树和右子树又分别是一棵二叉树&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;二叉树是有序树,左右子树颠倒,就不是同一棵树了,五种形态&lt;br&gt;
空  只有根结点   只有左子树   只有右子树   左右子树都有&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;与度为2的有序树的区别:&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;度为2的树至少有3个结点,而二叉树可以为空&lt;/li&gt;
&lt;li&gt;度为2的有序树的孩子的左右次序是相对的,若某结点只有一个孩子,则不需区分左右次序;而二叉树无论是否俩孩子都要确定左右次序,因此是绝对的而不是相对的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;12-几个特殊的二叉树&#34;&gt;1.2 几个特殊的二叉树&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;满二叉树&lt;br&gt;
一棵高度为h，且含有2&lt;sup&gt;h&lt;/sup&gt;-1个结点的二叉树称为满二又树，即树中的每层都含有最多的结点，如图所示。满二叉树的叶子结点都集中在二叉树的最下一层，并且除叶子结点之外的每个结点度数均为2。&lt;br&gt;
可以对满二叉树按层序编号：约定编号从根结点（根结点编号为1）起，自上而下，自左向右。这样，每个结点对应一个编号，对于编号为i的结点，若有双亲，则其双亲为Li/2，若有左孩子，则左孩子为2i；若有右孩子，则右孩子为2i+1。&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/21/dYGF0I.png&#34; alt=&#34;dYGF0I.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;完全二叉树&lt;br&gt;
高度为h、有n个结点的二叉树，当且仅当其每个结点都与高度为h的满二叉树中编号为1～n的结点一一对应时，称为完全二又树，如图所示。&lt;strong&gt;就是相同高度的满二叉树缺失最下层最右边的一些连续的叶子结点&lt;/strong&gt;其特点如下：&lt;br&gt;
①若i≤n/2(向下取整)，则结点i为分支结点，否则为叶子结点。&lt;br&gt;
②叶子结点只可能在层次最大的两层上出现。对于最大层次中的叶子结点，都依次排列在该层最左边的位置上。&lt;br&gt;
③若有度为1的结点，则只可能有一个，且该结点只有左孩子而无右孩子（重要特征）。&lt;br&gt;
④按层序编号后，一旦出现某结点（编号为i）为叶子结点或只有左孩子，则编号大于i的结点均为叶子结点。&lt;br&gt;
⑤若n为奇数，则每个分支结点都有左孩子和右孩子；若n为偶数，则编号最大的分支结点（编号为n/2）只有左孩子，没有右孩子，其余分支结点左、右孩子都有。&lt;/li&gt;
&lt;li&gt;二叉排序树&lt;br&gt;
左子树所有结点关键字&amp;lt;根结点的关键字&amp;lt;右子树所有结点的关键字&lt;br&gt;
左子树和右子树又各是一棵二叉排序树&lt;/li&gt;
&lt;li&gt;平衡二叉树&lt;br&gt;
任意结点的左子树和右子树的深度之差不超过1&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;13-二叉树的性质&#34;&gt;1.3 二叉树的性质&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;非空二叉树上的叶子结点数等于度为2的结点数加1:n&lt;sub&gt;0&lt;/sub&gt;=n&lt;sub&gt;2&lt;/sub&gt;+1&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;证明:&lt;br&gt;
上一节可知:总的度+1=各种结点数量之和&lt;br&gt;
这里有1+0*n&lt;sub&gt;0&lt;/sub&gt;+1n&lt;sub&gt;1&lt;/sub&gt;+2n&lt;sub&gt;2&lt;/sub&gt;=n&lt;sub&gt;0&lt;/sub&gt;+n&lt;sub&gt;1&lt;/sub&gt;+n&lt;sub&gt;2&lt;/sub&gt;&lt;br&gt;
得到:n&lt;sub&gt;0&lt;/sub&gt;=n&lt;sub&gt;2&lt;/sub&gt;+1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;非空二叉树上第k层至多有2&lt;sup&gt;k-1&lt;/sup&gt;个结点(不证了,显然)&lt;/li&gt;
&lt;li&gt;高度为h的二叉树至多有2&lt;sup&gt;h&lt;/sup&gt;-1个结点(h≥1):满二叉树前n项和&lt;/li&gt;
&lt;li&gt;对完全二叉树按从上到下、从左到右的顺序依次编号1，2…，n，则有以下关系：&lt;br&gt;
①当i&amp;gt;1时，结点i的双亲的编号为i/2(下取整)，即当i为偶数时，其双亲的编号为i/2，它是双亲的左孩子；当i为奇数时，其双亲的编号为（i-1）/2，它是双亲的右孩子。&lt;br&gt;
②当2i≤n时，结点i的左孩子编号为2i，否则无左孩子。&lt;br&gt;
③当2i+1≤n时，结点i的右孩子编号为2i+1，否则无右孩子。&lt;br&gt;
④结点i所在层次（深度）为log&lt;sub&gt;2&lt;/sub&gt;i(下取整)+1。&lt;/li&gt;
&lt;li&gt;具有n个（n&amp;gt;0）结点的完全二叉树的高度为log&lt;sub&gt;2&lt;/sub&gt;(n+1)(上取整)或log&lt;sub&gt;2&lt;/sub&gt;n(下取整)+1。&lt;br&gt;
设高度为h，根据性质3和完全二又树的定义有&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/21/dtMZGQ.png&#34; alt=&#34;dtMZGQ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;14-二叉树的存储结构&#34;&gt;1.4 二叉树的存储结构&lt;/h2&gt;
&lt;h3 id=&#34;141顺序存储结构&#34;&gt;1.4.1顺序存储结构&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;定义:&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;二叉树的顺序存储是指用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素，即将完全二叉树上编号为i的结点元素存储在一维数组下标为i-1的分量中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;依据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中结点的序号可以唯一地反映结点之间的逻辑关系，这样既能最大可能地节省存储空间，又能利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。&lt;/li&gt;
&lt;li&gt;对于一般的二叉树，为了让数组下标能反映二叉树中结点之间的逻辑关系，只能添加一些并不存在的空结点，让其每个结点与完全二叉树上的结点相对照，再存储到一维数组的相应分量中。然而，在最坏情况下，一个高度为h且只有h个结点的单支树却需要占据近2&lt;sup&gt;h&lt;/sup&gt;-1个存储单元。二叉树的顺序存储结构如图5.4所示，其中0表示并不存在的空结点。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：这种存储结构建议从数组下标1开始存储树中的结点，若从数组下标0开始存储，则不满足性质4的描述（比如结点A存储在0下标位置上时，无法根据性质4来计算出其孩子结点在数组中的位置），这是考生在书写程序时容易忽略的。&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/21/dt81C8.png&#34; alt=&#34;dt81C8.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;142链式存储结构&#34;&gt;1.4.2链式存储结构&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;由于顺序存储的空间利用率比较低,一般采用链式存储结构.&lt;/li&gt;
&lt;li&gt;结点结构通常包含若干数据域和若干指针域
&lt;ol&gt;
&lt;li&gt;至少包含3个域:数据域data,左指针域lchild,右指针域rchild&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;在某些应用中还可加入指向父亲结点的指针,变成三叉链表的存储结构&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/21/dtJvjg.png&#34; alt=&#34;dtJvjg.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/21/dtYnb9.png&#34; alt=&#34;dtYnb9.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;链式存储结构描述&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;typdef struct BiTNode{
    ElemType data;  //数据域
    struct BiTNode *lchild,*rchild;  //左右子树
}BiTNode,*BiTree;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;注意:含有n个结点的二叉链表中,含有n+1个空链域&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;n个结点可以带有2n个指针,除去根结点外,每个都消耗掉1个,故而:2n-(n-1)=n+1;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;15-错题及重点整理&#34;&gt;1.5 错题及重点整理&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;4.设高度为h的二又树上只有度为0和度为2的结点，则此类二又树中所包含的结点数至少为（）。&lt;br&gt;
&lt;strong&gt;2h-1&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/22/daxW38.png&#34; alt=&#34;daxW38.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;经常要注意这种特殊情况&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;满二叉树和完全二叉树的几个层与结点个数的性质一定要记牢&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;满k叉树的性质&lt;/strong&gt;
&lt;ol&gt;
&lt;li&gt;各层的结点个数:k&lt;sup&gt;i-1&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;编号为i的孩子结点&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/22/ddixWn.png&#34; alt=&#34;ddixWn.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
可以观察到第i个结点的底下的最左边的结点为:k(i-1)+2&lt;br&gt;
最右边为:k(i-1)+2+k-1=ki+1&lt;br&gt;
第j个子女:k(i-1)+j+1&lt;/li&gt;
&lt;li&gt;根据孩子结点反推双亲结点(若存在):j=k(i-1)+2 ==&amp;gt; i=(j-2)/k+1 ==&amp;gt; ((j-2)/k)下取整+1&lt;/li&gt;
&lt;li&gt;i有右兄弟的条件&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/22/ddAOoD.png&#34; alt=&#34;ddAOoD.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
">第五章 二叉树</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-wu-zhang-shu-de-ji-ben-gai-nian-ji-cuo-ti-chong-dian-zheng-li/"" data-c="
          &lt;h2 id=&#34;11-基本的一些概念&#34;&gt;1.1 基本的一些概念&lt;/h2&gt;
&lt;p&gt;不写了,太基本了&lt;/p&gt;
&lt;h2 id=&#34;12-性质&#34;&gt;1.2 性质&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;结点数=所有结点度数+1&lt;/li&gt;
&lt;li&gt;度为m的树中,第i层&lt;strong&gt;至多&lt;/strong&gt;有m&lt;sup&gt;i-1&lt;/sup&gt;个结点(i≥1)
&lt;ul&gt;
&lt;li&gt;树中结点最大的度数叫树的度&lt;/li&gt;
&lt;li&gt;度为m,第2层最多m个,第3层最多m²个....第i层m&lt;sup&gt;i-1&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;高度为h的m叉树至多有(m&lt;sup&gt;h&lt;/sup&gt;-1)/(m-1)个结点
&lt;ul&gt;
&lt;li&gt;1层:1&lt;br&gt;
2层最多:m&lt;br&gt;
3层最多:m²&lt;br&gt;
....&lt;br&gt;
累加:S=m&lt;sup&gt;h-1&lt;/sup&gt;+m&lt;sup&gt;h-2&lt;/sup&gt;+m&lt;sup&gt;h-3&lt;/sup&gt;+...+m+1=(m&lt;sup&gt;h&lt;/sup&gt;-1)/(m-1)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有n个结点的m叉树(最大结点数是m就行)最小高度:log&lt;sub&gt;m&lt;/sub&gt;(n(m-1)+1)向上取整&lt;br&gt;
最大高度:好像不咋求,有说是串成链了(n层),也有说最后一层m个,前面是链(n-m+1)层
&lt;ul&gt;
&lt;li&gt;最小高度,则每层铺满了,根据第3点:n=(m&lt;sup&gt;h&lt;/sup&gt;-1)/(m-1),可以推导出这里h=log&lt;sub&gt;m&lt;/sub&gt;(n(m-1)+1),再向上取个整,因为如果有零头,说明最后一层有结点但是没满,故而再加一层&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;错题重点&#34;&gt;错题重点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;树的路径长度是指&lt;strong&gt;树根到每个结点的路径长的总和&lt;/strong&gt;,根到每个结点的路径长度的最大值是高度减1&lt;/li&gt;
&lt;li&gt;结点总数n=分支数(度的和)+1,即&lt;strong&gt;n=1+n&lt;sub&gt;1&lt;/sub&gt;+2n&lt;sub&gt;2&lt;/sub&gt;+3n&lt;sub&gt;3&lt;/sub&gt;+4n&lt;sub&gt;4&lt;/sub&gt;+……=n&lt;sub&gt;0&lt;/sub&gt;+n&lt;sub&gt;1&lt;/sub&gt;+n&lt;sub&gt;2&lt;/sub&gt;+……&lt;/strong&gt;&lt;br&gt;
求叶子结点就是求n&lt;sub&gt;0&lt;/sub&gt;&lt;/li&gt;
&lt;/ol&gt;
">第五章 树的基本概念及错题重点整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/guan-yu-dui-zhan-de-jiang-jie/"" data-c="
          &lt;p&gt;&lt;a href=&#34;https://blog.csdn.net/yingms/article/details/53188974&#34;&gt;链接转自CSDN只挑了感兴趣的&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;一内存的分配&#34;&gt;一.内存的分配&lt;/h2&gt;
&lt;p&gt;一个由c/C++编译的程序占用的内存分为以下几个部分&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。&lt;/li&gt;
&lt;li&gt;堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表，呵呵。&lt;/li&gt;
&lt;li&gt;全局区（静态区）（static）—，全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。 - 程序结束后有系统释放&lt;/li&gt;
&lt;li&gt;文字常量区—常量字符串就是放在这里的。 程序结束后由系统释放&lt;/li&gt;
&lt;li&gt;程序代码区—存放函数体的二进制代码。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;二示例程序&#34;&gt;二.示例程序&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;//main.cpp
int a = 0; //全局初始化区
int a = 0; //全局初始化区
char *p1; //全局未初始化区
main() {
    int b; //栈
    char s[] = &amp;quot;abc&amp;quot;; //栈
    char *p2; //栈
    char *p3 = &amp;quot;123456&amp;quot;; //123456\0在常量区，p3在栈上。
    static int c = 0; //全局（静态）初始化区
    p1 = (char *)malloc(10);
    p2 = (char *)malloc(20);
    //分配得来得10和20字节的区域就在堆区。
    strcpy(p1, &amp;quot;123456&amp;quot;); //123456\0放在常量区，编译器可能会将它与p3所指向的&amp;quot;123456&amp;quot;优化成一个地方。
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;三堆和栈的理论知识&#34;&gt;三.堆和栈的理论知识&lt;/h2&gt;
&lt;h3 id=&#34;31申请方式&#34;&gt;3.1申请方式&lt;/h3&gt;
&lt;p&gt;stack:&lt;br&gt;
由系统自动分配。 例如，声明在函数中一个局部变量 int b; 系统自动在栈中为b开辟空间&lt;br&gt;
heap:&lt;br&gt;
需要程序员自己申请，并指明大小，在c中malloc函数&lt;br&gt;
如p1 = (char *)malloc(10);&lt;br&gt;
在C++中用new运算符&lt;br&gt;
如p2 = (char *)malloc(10);&lt;br&gt;
但是注意p1、p2本身是在栈中的。&lt;/p&gt;
&lt;h3 id=&#34;32-申请后系统的响应&#34;&gt;3.2 申请后系统的响应&lt;/h3&gt;
&lt;p&gt;栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。&lt;br&gt;
堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，&lt;br&gt;
会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。&lt;/p&gt;
&lt;h3 id=&#34;33-申请大小的限制&#34;&gt;3.3 申请大小的限制&lt;/h3&gt;
&lt;p&gt;栈：在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。&lt;br&gt;
堆：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。&lt;/p&gt;
&lt;h3 id=&#34;34-申请效率的比较&#34;&gt;3.4 申请效率的比较：&lt;/h3&gt;
&lt;p&gt;栈由系统自动分配，速度较快。但程序员是无法控制的。&lt;br&gt;
堆是由new分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便.&lt;br&gt;
另外，在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是在栈是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。&lt;/p&gt;
&lt;h3 id=&#34;35-堆和栈中的存储内容&#34;&gt;3.5 堆和栈中的存储内容&lt;/h3&gt;
&lt;p&gt;栈： 在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。&lt;br&gt;
当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。&lt;br&gt;
堆：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。&lt;/p&gt;
&lt;h3 id=&#34;36-存取效率的比较&#34;&gt;3.6 存取效率的比较&lt;/h3&gt;
&lt;p&gt;char s1[] = &amp;quot;aaaaaaaaaaaaaaa&amp;quot;;&lt;br&gt;
char *s2 = &amp;quot;bbbbbbbbbbbbbbbbb&amp;quot;;&lt;br&gt;
aaaaaaaaaaa是在运行时刻赋值的；&lt;br&gt;
而bbbbbbbbbbb是在编译时就确定的；&lt;br&gt;
但是，在以后的存取中，在栈上的数组比指针所指向的字符串(例如堆)快。&lt;br&gt;
比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;＃include
void main() {
    char a = 1;
    char c[] = &amp;quot;1234567890&amp;quot;;
    char *p =&amp;quot;1234567890&amp;quot;;
    a = c[1];
    a = p[1];
    return;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对应汇编的代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;10: a = c[1];
00401067 8A 4D F1 mov cl,byte ptr [ebp-0Fh]
0040106A 88 4D FC mov byte ptr [ebp-4],cl
11: a = p[1];
0040106D 8B 55 EC mov edx,dword ptr [ebp-14h]
00401070 8A 42 01 mov al,byte ptr [edx+1]
00401073 88 45 FC mov byte ptr [ebp-4],al
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第一种在读取时直接就把字符串中的元素读到寄存器cl中，而第二种则要先把指针值读到edx中，在根据edx读取字符，显然慢了。&lt;/p&gt;
&lt;h3 id=&#34;37小结&#34;&gt;3.7小结：&lt;/h3&gt;
&lt;p&gt;堆和栈的区别可以用如下的比喻来看出：&lt;br&gt;
使用栈就象我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。&lt;br&gt;
使用堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。&lt;/p&gt;
">关于堆栈的讲解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-er-zhang-jin-cheng-tong-bu-bu-fen-de-ti-mu-ji-chong-dian-zheng-li/"" data-c="
          &lt;ul&gt;
&lt;li&gt;临界区是指进程中&lt;strong&gt;访问临界资源&lt;/strong&gt;的那部分&lt;strong&gt;代码&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;信号量为负值时,绝对值就是阻塞(等待)的进程数
&lt;ul&gt;
&lt;li&gt;当前信号量大于0,则说明没有进程处于等待状态,且为多少就有多少资源&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程处于临界区允许其他进程抢占(☆)
&lt;ul&gt;
&lt;li&gt;进程在操作系统内核程序临界区时不能发生调度与切换,原因是&lt;strong&gt;内核程序临界区一般是用来访问某种内核数据结构的,如果不尽快释放,有可能导致操作系统内核的其他管理工作&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;情景类问题,如不同旅行社为为旅客到某航空公司顶机票,机票是临界资源
&lt;ul&gt;
&lt;li&gt;这里就注意对应关系,一张机票对应的都只能是一个人,而旅行社可以对应不同旅客,航空公司也可以对应不同旅行社&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;要对并发进程同步的原因是并发进程是异步的&lt;/li&gt;
&lt;li&gt;关于PV操作的概念
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;是低级进程通信原语&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不是系统调用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;是由&lt;strong&gt;两个不可被中断&lt;/strong&gt;的过程组成,因为分别是P和V所以俩&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关于互斥和同步信号量的初值
&lt;ul&gt;
&lt;li&gt;互斥信号量的初值是1,固定的&lt;/li&gt;
&lt;li&gt;同步信号量的初值是由用户决定的
&lt;ul&gt;
&lt;li&gt;若期望的消息未产生设置为0,若期望的消息已存在,则信号量的初值设置为一个非0的正整数,就像生产者消费者中的缓冲区容量以及数据数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;若代码可被多个进程在任意时刻共享，则要求任一个进程在调用此段代码时都以同样的方式运行；而且进程在运行过程中被中断后再继续执行，其执行结果不受影响。这必然要求代码&lt;strong&gt;不能被任何进程修改&lt;/strong&gt;，否则无法满足共享的要求。这样的代码就是&lt;strong&gt;可重入代码，也称纯代码&lt;/strong&gt;，即允许多个进程同时访问的代码。&lt;/li&gt;
&lt;li&gt;共享程序段必须用可重入编码编写&lt;/li&gt;
&lt;li&gt;注意:管程的signal操作和信号量机制中的V操作不同,V操作会改变信号量的值S=S+1;管程中的signal操作是针对某个条件变量,若不存在因该条件而阻塞的进程,则signal不会产生任何影响
&lt;ul&gt;
&lt;li&gt;考察的就是条件变量与信号量的区别,条件变量是没有值的,剩余资源数是用共享数据结构记录的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;管程是被进程调用的,是语法范围,无法创建和销毁\&lt;/li&gt;
&lt;li&gt;关于TSL
&lt;ul&gt;
&lt;li&gt;当进程退出临界区时置lock为FALSE，会负责唤醒处于就绪态的进程&lt;/li&gt;
&lt;li&gt;等待进入临界区的进程会一直停留在执行while（TSL（&amp;amp;lock）的循环中，不会主动放弃CPU.让权等待，即进程不能进入临界区时，应立即释放处理器，防止进程忙等待。并不满足“让权等待”的同步准则while（TSL（&amp;amp;lock））在关中断状态下执行时，若TSL（&amp;amp;lock）一直为true，不再开中断，则系统可能会因此终止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;信箱通信是一种间接通信方式&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
">第二章 进程同步部分的题目及重点整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-er-zhang-jin-cheng-tong-bu-zhi-jing-dian-tong-bu-wen-ti-chong-dian/"" data-c="
          &lt;h2 id=&#34;生产者-消费者问题&#34;&gt;生产者-消费者问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;问题分析&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/30/auN1MR.png&#34; alt=&#34;auN1MR.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;解决&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/30/aua8UK.png&#34; alt=&#34;aua8UK.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;mutex的p操作不能放到前面,否则会造成死锁&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/30/audco6.png&#34; alt=&#34;audco6.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;实现互斥的P操作一定要放到实现同步的P操作之后&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;V操作不会导致进程阻塞,因此两个V操作顺序可以互换&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;生产产品的过程和使用产品的过程,会较长,为了避免降低效率(减少上锁时间),不建议将这两个过程放到产品放入缓冲区和从缓冲区取产品的部分&lt;/li&gt;
&lt;li&gt;小结&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/30/au0wr9.png&#34; alt=&#34;au0wr9.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;多生产者-多消费者问题&#34;&gt;多生产者-多消费者问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;问题分析&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/30/auf2zn.png&#34; alt=&#34;auf2zn.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/30/auh56I.png&#34; alt=&#34;auh56I.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;实现&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;有mutex&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/30/au4wE8.png&#34; alt=&#34;au4wE8.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;这里可以去掉mutex,plate作为互斥信号量&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/30/au4bK1.png&#34; alt=&#34;au4bK1.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;这里可以是因为缓冲区大小为1,当然加上mutex肯定没错&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;当缓冲区大小大于1时,要加上mutex互斥信号量&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/30/au5YiF.png&#34; alt=&#34;au5YiF.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;小结&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/30/au5rdK.png&#34; alt=&#34;au5rdK.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/30/auID6s.png&#34; alt=&#34;auID6s.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;注:不要从单个进程的角度来看问题,要从事件的角度&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;读者写者问题&#34;&gt;读者写者问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;问题分析&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/01/a3XIET.png&#34; alt=&#34;a3XIET.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;实现&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/01/a3jaiF.png&#34; alt=&#34;a3jaiF.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;避免写进程饥饿&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/01/a3xy4O.png&#34; alt=&#34;a3xy4O.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;小结&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;遇到同步问题一般是生产者-消费者问题&lt;/li&gt;
&lt;li&gt;遇到包含互斥的一般是复杂的读者-写者问题&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/01/a3z0zQ.png&#34; alt=&#34;a3z0zQ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;哲学家进餐问题&#34;&gt;哲学家进餐问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;问题分析&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/01/a8kg8x.png&#34; alt=&#34;a8kg8x.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;造成死锁的方法&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/01/a8kbGt.png&#34; alt=&#34;a8kbGt.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;解决思索的方法
&lt;ol&gt;
&lt;li&gt;至多允许四个哲学家拿起筷子&lt;/li&gt;
&lt;li&gt;仅当一名哲学家左右两边的筷子都可以用时,才抓起筷子&lt;/li&gt;
&lt;li&gt;对哲学家顺序编号,奇数号先拿左边筷子,再拿右边,偶数号先拿右边筷子再拿左边&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/01/a8M7mq.png&#34; alt=&#34;a8M7mq.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;小结&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/01/a8QmjA.png&#34; alt=&#34;a8QmjA.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;吸烟者问题&#34;&gt;吸烟者问题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;问题分析&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/01/a8tifP.png&#34; alt=&#34;a8tifP.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;实现&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/01/a8tMYq.png&#34; alt=&#34;a8tMYq.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;小结&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/01/a8t86U.png&#34; alt=&#34;a8t86U.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
">第二章 进程同步之经典同步问题(重点)</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-er-zhang-jin-cheng-tong-bu/"" data-c="
          &lt;h2 id=&#34;基本概念&#34;&gt;基本概念&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/22/UHlPR1.png&#34; alt=&#34;UHlPR1.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;实现临界区互斥的基本方法&#34;&gt;实现临界区互斥的基本方法&lt;/h2&gt;
&lt;h3 id=&#34;软件方法&#34;&gt;软件方法&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/22/UHNoIf.png&#34; alt=&#34;UHNoIf.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;turn变量理解&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;由于在自己进程内的执行时,turn的赋值始终为&lt;strong&gt;turn=别的进程号&lt;/strong&gt;,因此可以理解为谦让给别人&lt;/li&gt;
&lt;li&gt;那么在单标志法中,检查的就是对面有没有谦让回给我,&lt;br&gt;
P0:&lt;br&gt;
while(turn!=0);//没有让给我,那就等着&lt;br&gt;
critical section;&lt;br&gt;
turn =1;//我用完了,谦让给你&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;flag[ ]的理解&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;flag[]表示自己的意愿,flag[i]=true:i说我想要,flag[i]=false,i说我不想要
&lt;ul&gt;
&lt;li&gt;双标志先检查法那就是在自己的进程里,先检查别人想不想,他想我就等着,他不想了,我就表示想,他就会检查到我想,然后等着,我用完了,就说不想了,他查到我不想了,就表示自己想,然后执行&lt;/li&gt;
&lt;li&gt;缺点就是我看他不想要,刚准备说想要,tmd那傻b又看到我是不想要,就想要了,然后我俩都想要,就一起用了...违背了忙则等待&lt;/li&gt;
&lt;li&gt;但是如果检查和表示自己想要可以一气呵成,那么就没有问题了&lt;/li&gt;
&lt;li&gt;双标志后检查法,就是在自己的进程里,先不管别人想不想要,直接表示自己想要,然后检查有没有人表示过想要,有就等着,没有就用,用完说自己不用了&lt;/li&gt;
&lt;li&gt;缺点是我说完老子想用,还没来得及检查,有人说想用了,然后我检查,发现有人想用,就等着,tmd别人检查发现我想用,就也等着,违背了有限等待,空闲让进&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;peterson 算法&lt;br&gt;
我先表示我想用,然后谦让给你&lt;br&gt;
&lt;code&gt;flag[i]=true;turn=j;&lt;/code&gt;&lt;br&gt;
然后检查你想不想用并且有没有让给我,如果你想用&lt;strong&gt;并且&lt;/strong&gt;没让给我,我就等着&lt;br&gt;
&lt;code&gt;while(flag[j]&amp;amp;&amp;amp;turn=j);&lt;/code&gt;&lt;br&gt;
如果你不想用或者让给我了,我就用了&lt;br&gt;
&lt;code&gt;critical section;&lt;/code&gt;&lt;br&gt;
用完表示不想用了&lt;br&gt;
&lt;code&gt; flag[i]=false;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;硬件方法&#34;&gt;硬件方法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;中断屏蔽法&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/22/UHRGoF.png&#34; alt=&#34;UHRGoF.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;硬件指令法(都是硬件完成的,代码只是功能的描述)&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/22/UHWklR.png&#34; alt=&#34;UHWklR.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;解决了之前双标志先检查法的缺点,即检查和上锁可以一气呵成了&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/22/UHW8Xt.png&#34; alt=&#34;UHW8Xt.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;总结&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/22/UHWyn0.png&#34; alt=&#34;UHWyn0.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;信号量&#34;&gt;信号量&lt;/h2&gt;
&lt;h3 id=&#34;整形信号量&#34;&gt;整形信号量&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/24/UjWVtx.png&#34; alt=&#34;UjWVtx.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;易考查不满足让权等待的问题,与记录型信号量的对比&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;记录型信号量&#34;&gt;记录型信号量(☆)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/24/UvERk4.png&#34; alt=&#34;UvERk4.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;小结&#34;&gt;小结&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/24/UvV9nf.png&#34; alt=&#34;UvV9nf.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;信号量的使用&#34;&gt;信号量的使用&lt;/h2&gt;
&lt;h3 id=&#34;总体&#34;&gt;总体&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/28/aA5FW6.png&#34; alt=&#34;aA5FW6.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;互斥&#34;&gt;互斥&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/28/aAIWDg.png&#34; alt=&#34;aAIWDg.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;同步&#34;&gt;同步&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/28/aATZOU.png&#34; alt=&#34;aATZOU.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;前驱&#34;&gt;前驱&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/28/aAOuTO.png&#34; alt=&#34;aAOuTO.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;小结-2&#34;&gt;小结&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;10&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/28/aAOAp9.png&#34; alt=&#34;aAOAp9.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;管程&#34;&gt;管程&lt;/h2&gt;
&lt;h3 id=&#34;概念&#34;&gt;概念&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;11&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/08/01/a8xWOs.png&#34; alt=&#34;a8xWOs.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;组成其实就是一个类数据+方法
&lt;ul&gt;
&lt;li&gt;因此只有局部于管程的过程(函数)才能访问局部于的数据&lt;/li&gt;
&lt;li&gt;也只有调用管程内的方法才能访问共享数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;每次仅允许一个进程在管程内执行某个内部过程==&amp;gt;保证了访问共享数据时的互斥性&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;应用&#34;&gt;应用&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;12&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/08/01/aGSMUx.png&#34; alt=&#34;aGSMUx.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;实现互斥:由编译器负责实现各进程互斥地进入管程中的过程&lt;br&gt;
当两个进程并发执行,一次调用insert过程,如果第一个没执行完,发生调度,则第二个执行到insert时会阻塞,这是由编译器完成的&lt;br&gt;
**队列:insert-&amp;gt;producer2&lt;/li&gt;
&lt;li&gt;实现同步:管程中设置条件变量和等待/唤醒条件,以解决同步问题&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;小结-3&#34;&gt;小结&lt;/h3&gt;
&lt;p&gt;其实就是用了封装的思想,对外提供接口,方便使用&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/08/01/aGC82T.png&#34; alt=&#34;aGC82T.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h3 id=&#34;java中的类似管程的机制&#34;&gt;java中的类似管程的机制&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;13&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/08/01/aGCrRK.png&#34; alt=&#34;aGCrRK.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;总结&#34;&gt;总结&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;14&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/08/01/aGC4it.png&#34; alt=&#34;aGC4it.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">第二章 进程同步</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-er-zhang-ji-chong-diao-du-suan-fa-de-bi-jiao/"" data-c="
          &lt;h2 id=&#34;总览&#34;&gt;总览&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/19/UWDGNQ.png&#34; alt=&#34;UWDGNQ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;先来先服务&#34;&gt;先来先服务&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/19/UWDfu6.png&#34; alt=&#34;UWDfu6.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;按照到达先后,实际上就是等待时间越久的越先得到服务&lt;/li&gt;
&lt;li&gt;注意等待时间的计算
&lt;ul&gt;
&lt;li&gt;纯计算型的进程:周转时间-运行时间&lt;/li&gt;
&lt;li&gt;计算+I/O操作的:周转时间-运行时间-I/O操作时间&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/19/UWDuct.png&#34; alt=&#34;UWDuct.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;短作业优先&#34;&gt;短作业优先&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/19/UWyGND.png&#34; alt=&#34;UWyGND.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;非抢占式spf与抢占式对比srtn&#34;&gt;非抢占式(SPF)与抢占式对比(SRTN)&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;非抢占式&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/19/UWsR0K.png&#34; alt=&#34;UWsR0K.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;抢占式&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/19/UWrGqK.png&#34; alt=&#34;UWrGqK.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/19/UWr7ZT.png&#34; alt=&#34;UWr7ZT.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;几个细节某些说法不一致时&#34;&gt;几个细节(某些说法不一致时)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/19/UWyEAU.png&#34; alt=&#34;UWyEAU.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;fcfs与sjf对比&#34;&gt;FCFS与SJF对比&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/19/UWyBHf.png&#34; alt=&#34;UWyBHf.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
因此推出了高响应比优先&lt;/p&gt;
&lt;h2 id=&#34;高响应比优先&#34;&gt;高响应比优先&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/19/UWcY6A.png&#34; alt=&#34;UWcY6A.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;当前运行的进程主动放弃CPU时,才需要进行调度,重新计算响应比&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/19/UW6XWQ.png&#34; alt=&#34;UW6XWQ.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;以上三种算法对比&#34;&gt;以上三种算法对比&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;交互性差&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/19/UWc0k8.png&#34; alt=&#34;UWc0k8.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;时间片轮转&#34;&gt;时间片轮转&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/19/UWfzy4.png&#34; alt=&#34;UWfzy4.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;注意,时间片到了之后下处理机时,会加到就绪队列的队尾,不要按照题中给的顺序想到然的来,要时刻按照就绪队列的顺序进行分析,如下:&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/19/UWR1YT.png&#34; alt=&#34;UWR1YT.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/19/UWRGpF.png&#34; alt=&#34;UWRGpF.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;时间片太大时,就会变成先来先服务&lt;/li&gt;
&lt;li&gt;太小切换的代价就大了,&lt;strong&gt;切换的开销不超过1%就认为是合适的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;用于进程调度&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;优先级调度算法&#34;&gt;优先级调度算法&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/19/UW4q2T.png&#34; alt=&#34;UW4q2T.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;注意是优先数越大,优先级越高,还是相反&lt;/li&gt;
&lt;li&gt;抢占式和非抢占式
&lt;ul&gt;
&lt;li&gt;非抢占式的优先级调度算法：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。&lt;/li&gt;
&lt;li&gt;抢占式的优先级调度算法：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。另外，当就绪队列发生改变时也需要检查是会发生抢占。&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/19/UW4RxS.png&#34; alt=&#34;UW4RxS.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;多级反馈队列调度算法&#34;&gt;多级反馈队列调度算法&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/19/UWo0rF.png&#34; alt=&#34;UWo0rF.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;认为是抢占式的算法&lt;/li&gt;
&lt;li&gt;用于进程调度&lt;br&gt;
算法规则(个人理解)&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;某一队列的上级队列都空了,才轮到这一级&lt;/li&gt;
&lt;li&gt;某进程在该队列的时间片用完,还没完成,就进入下一级队列(时间片增加的),但如果已经是最底层了,就放到该级队尾&lt;/li&gt;
&lt;li&gt;来一个新的进程首先放到第1级的队尾,如果此时运行的是低级的队列的进程,则发生抢占,被强占的进程放到所在队列的队尾,并不是到下一级了(毕竟是意外,也没说自己在这一级能不能运行完)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;以上三种比对&#34;&gt;以上三种比对&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;适合交互式系统&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/19/UWoTIA.png&#34; alt=&#34;UWoTIA.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
">第二章 几种调度算法的比较</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/zhan-yu-dui-lie-cuo-ti-ji-chong-dian/"" data-c="
          &lt;h2 id=&#34;概念部分&#34;&gt;概念部分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;栈和队列具有相同的&lt;strong&gt;逻辑结构&lt;/strong&gt;,这tm别忘啊,逻辑结构就线性和非线性的,&lt;strong&gt;栈和队列都是线性的&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;只有表头结点指针而没有表尾指针的单向循环链表&lt;strong&gt;最不适合&lt;/strong&gt;作为链栈
&lt;ul&gt;
&lt;li&gt;比如在出栈的时候,即删除第一个结点,删是好删,但是最后一个结点的next指到新的第一个结点时,得遍历整个链表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;栈与队列的应用&#34;&gt;栈与队列的应用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;用到栈的操作
&lt;ul&gt;
&lt;li&gt;递归&lt;/li&gt;
&lt;li&gt;进制转换&lt;/li&gt;
&lt;li&gt;迷宫求解&lt;/li&gt;
&lt;li&gt;括号匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用到队列的操作
&lt;ul&gt;
&lt;li&gt;缓冲区&lt;/li&gt;
&lt;li&gt;页面替换算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;调用函数时,系统会为调用者构造一个由参数表和返回地址组成的活动记录,并将记录压入系统提供的栈中,若被调用的函数有局部变量,也要压入栈中&lt;/li&gt;
&lt;li&gt;栈和队列都是操作受限的线性表,但是只有队列允许在两端操作,&lt;strong&gt;栈只能在一端操作&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;递归调用函数时,在系统栈中保存的函数信息需要满足先进后出的特点,&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int s(int n)
{
    return (n&amp;lt;=0)?0:s(n-1)+n;
}
int main()
{
    cout&amp;lt;&amp;lt;S(1);
}
main()-&amp;gt;s(1)-&amp;gt;s(0)
&lt;/code&gt;&lt;/pre&gt;
">栈与队列错题及重点</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/chu-li-ji-diao-du-bu-fen-li-jie/"" data-c="
          &lt;h3 id=&#34;概念部分调度的时机切换与过程&#34;&gt;概念部分,调度的时机,切换与过程&lt;/h3&gt;
&lt;h3 id=&#34;调度的概念&#34;&gt;调度的概念&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/14/UUVu6S.png&#34; alt=&#34;UUVu6S.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;作业调度&#34;&gt;作业调度&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/14/UUVIAA.png&#34; alt=&#34;UUVIAA.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;进程调度&#34;&gt;进程调度&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/14/UUZljO.png&#34; alt=&#34;UUZljO.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;内存调度中级调度&#34;&gt;内存调度(中级调度)&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;4&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/14/UUZGHH.png&#34; alt=&#34;UUZGHH.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;七状态模型&#34;&gt;七状态模型&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;5&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/14/UUZb5R.png&#34; alt=&#34;UUZb5R.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;对比&#34;&gt;对比&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/14/UUuPIJ.png&#34; alt=&#34;UUuPIJ.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
###概念总结&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/14/UUulid.png&#34; alt=&#34;UUulid.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注意调度针对的是什么
&lt;ul&gt;
&lt;li&gt;进程调度针对的是就绪队列里的进程,而其他状态的进程是系统处理&lt;/li&gt;
&lt;li&gt;内存调度针对的是挂起队列(就绪挂起队列/阻塞挂起队列)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程调度的时机&#34;&gt;进程调度的时机&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/14/UUWU2Q.png&#34; alt=&#34;UUWU2Q.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;注意区别&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进程在&lt;strong&gt;操作系统内核程序临界区&lt;/strong&gt;中&lt;strong&gt;不能&lt;/strong&gt;进行调度和切换&lt;br&gt;
进程处于&lt;strong&gt;临界区&lt;/strong&gt;时&lt;strong&gt;不能&lt;/strong&gt;进行处理机调度是&lt;strong&gt;错误的&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/14/UUf4Sg.png&#34; alt=&#34;UUf4Sg.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/14/UUhFk6.png&#34; alt=&#34;UUhFk6.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
后者案例:访问普通临界资源&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/14/UUh3h8.png&#34; alt=&#34;UUh3h8.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/14/UUhG9S.png&#34; alt=&#34;UUhG9S.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;进程调度方式种类&#34;&gt;进程调度方式种类&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;6&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/14/UUhLDA.png&#34; alt=&#34;UUhLDA.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;进程的切换过程&#34;&gt;进程的切换过程&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;7&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/14/UU4qRU.png&#34; alt=&#34;UU4qRU.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;调度时机切换与过程的总结&#34;&gt;调度时机,切换与过程的总结&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;8&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/14/UU5FzD.png&#34; alt=&#34;UU5FzD.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;进程调度方式&#34;&gt;进程调度方式&lt;/h2&gt;
&lt;h3 id=&#34;调度的基本准则&#34;&gt;调度的基本准则&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;CPU利用率&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/14/UUOt0S.png&#34; alt=&#34;UUOt0S.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;系统吞吐量&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/14/UUOwfs.png&#34; alt=&#34;UUOwfs.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;周转时间&lt;br&gt;
对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间。&lt;br&gt;
周转时间，是指从作业被提交给系统开始，到作业完成为止的这段时间间隔。&lt;br&gt;
它包括四个部分：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;作业在外存后备队列上等待作业调度（高级调度）的时间、&lt;/li&gt;
&lt;li&gt;进程在就绪队列上等待进程调度（低级调度）的时间、&lt;/li&gt;
&lt;li&gt;进程在CPU上执行的时间、&lt;/li&gt;
&lt;li&gt;进程等待I/0操作完成的时间。&lt;/li&gt;
&lt;li&gt;后三项在一个作业的整个处理过程中，可能发生多次。&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;（作业）周转时间=作业完成时间-作业提交时间&lt;/center&gt; 
&lt;figure data-type=&#34;image&#34; tabindex=&#34;9&#34;&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/14/UUXBUe.png&#34; alt=&#34;UUXBUe.png&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;p&gt;&lt;img src=&#34;https://s1.ax1x.com/2020/07/14/UUjQMt.png&#34; alt=&#34;UUjQMt.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
4. 等待时间&lt;br&gt;
注意的是:进程等待I/O完成的期间不算在等待时间里&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/14/UUjHFe.png&#34; alt=&#34;UUjHFe.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
5. 响应时间&lt;br&gt;
指从用户提交请求到首次产生响应所用时间&lt;br&gt;
6. 小结&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/14/UUv861.png&#34; alt=&#34;UUv861.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">处理机调度部分理解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/qia-te-lan-shu-de-bu-fen-li-jie/"" data-c="
          &lt;p&gt;公式1 (通项公式) ：&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/13/UYhBZV.png&#34; alt=&#34;UYhBZV.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
在上文提到的出栈序列的问题情景中，如果有n&lt;br&gt;
个元素，在平面直角坐标系中用x坐标表示入栈数，y坐标表示出栈数，则坐标(a,b)表示目前已经进行了a次入栈和b次出栈，则再进行一次入栈就是走到(a+1,b)，再进行一次出栈就是走到(a,b+1)。并且，由于入栈数一定小于等于出栈数，所以路径不能跨越直线y=x&lt;br&gt;
因此，题目相当于求从(0,0)走到(n,n)且不跨越直线y=x的方案数&lt;br&gt;
首先，如果不考虑不能跨越直线y=x的要求，相当于从2n次操作中选n次进行入栈，则方案数为Cn2n。&lt;br&gt;
然后，考虑对于一种不合法的方案，一定在若干次操作后有一次出栈数比入栈数多一次，这个点在直线y=x+1 (即下图中红色的线) 上。那么把第一次碰到该直线以后的部分关于该直线对称，则最终到达的点是(n−1,n+1) (如下图) 。&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/13/UYhJPg.png&#34; alt=&#34;UYhJPg.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
图源：英文维基 (即文首网址)&lt;br&gt;
显然，任何非法方案都可以通过此方式变成一条从(0,0)到(n−1,n+1)的路径，有Cn+12n种。而任何合法方案由于不接触直线y=x+1，无论从哪个点对称都不是一条连续的路径。由于合法方案数就是Catalann&lt;/p&gt;
&lt;p&gt;，所以：&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/13/UY5Vcd.png&#34; alt=&#34;UY5Vcd.png&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
">卡特兰数的部分理解</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/lian-biao-cao-zuo/"" data-c="
          &lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

typedef struct LNode
{
    int data;
    struct LNode *next;
}LNode,*LinkList;
LinkList list_headinsert(LinkList &amp;amp;L)
{
    L=(LinkList)malloc(sizeof(LNode));
    LNode *s;
    int i=0;
    L-&amp;gt;next=NULL;
    while(i&amp;lt;=20)
    {
        s=(LNode*)malloc(sizeof(LNode));
        s-&amp;gt;data=i;
        s-&amp;gt;next=L-&amp;gt;next;
        L-&amp;gt;next=s;
    }
}
LinkList list_tailinsert(LinkList &amp;amp;L)
{
    L=(LinkList)malloc(sizeof(LNode));
    LNode *s,*r=L;
    int i=0;
    while(i&amp;lt;=20)
    {
        s=(LNode*)malloc(sizeof(LNode));
        s-&amp;gt;data=i;
        r-&amp;gt;next=s;
        r=s;
    }
    r-&amp;gt;next=NULL;
}
void print(LinkList &amp;amp;L)
{
    LNode *p=L-&amp;gt;next;
    while(p!=NULL)
    {
        printf(&amp;quot;%d   &amp;quot;,p-&amp;gt;data);
        p=p-&amp;gt;next;
    }
    printf(&amp;quot;\n&amp;quot;);
}
void delx(LinkList &amp;amp;l,int x)
{
    LNode *p;
    if(L==NULL)
    {
        return;
    }
    if(L-&amp;gt;data==x)
    {
        p=L;
        L=L-&amp;gt;next;
        free(p);
        delx(L,x);
    }
    else
        delx(L-&amp;gt;next,x);
}
int main()
{
    LinkList L;
    list_tailinsert(L);
    print(L);
    printf(&amp;quot;Hello world!\n&amp;quot;);
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
">链表操作</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-er-zhang-jin-cheng-guan-li-cuo-ti-ji-chong-yao-zhi-shi-dian/"" data-c="
          &lt;h2 id=&#34;选择题&#34;&gt;选择题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;线程&lt;strong&gt;没有&lt;/strong&gt;自己独立的地址空间,同一进程的多个线程共享其地址空间&lt;/li&gt;
&lt;li&gt;线程包含CPU现场,是处理机调度的基本单位,可以独立执行程序&lt;/li&gt;
&lt;li&gt;进程和程序的根本区别是&lt;strong&gt;静态和动态特点&lt;/strong&gt;k&lt;/li&gt;
&lt;li&gt;优先级分静态和动态两种&lt;/li&gt;
&lt;li&gt;在单处理器中,任何时刻都只有一个进程处于运行态是&lt;strong&gt;错的&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;系统死锁全部是阻塞态或者无进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在进程的整个生命周期中,系统总是通过其PCB来对进程进行控制;
&lt;ul&gt;
&lt;li&gt;系统是根据PCB而非其他任何因素来感知进程存在的&lt;/li&gt;
&lt;li&gt;PCB是进程存在的唯一标志;&lt;/li&gt;
&lt;li&gt;PCB常驻内存&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;单处理机系统,n个进程,处于就绪队列的最多n-1个,还有一个肯定在运行;处于阻塞态的最多n个&lt;/li&gt;
&lt;li&gt;并发进程失去封闭性是指并发进程共享变量,其执行结果与速度有关
&lt;ul&gt;
&lt;li&gt;程序的封闭性是指进程执行的结果只取决于进程本身,不受外界影响&lt;/li&gt;
&lt;li&gt;也就是,进程在执行的过程中不管是不停顿的执行还是走走停停,进程的执行速度都不会改变他的执行结果&lt;/li&gt;
&lt;li&gt;但是,在失去封闭性后,不同的速度下执行的结果不同&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程之间可能是相关的,也可能是封闭的&lt;/li&gt;
&lt;li&gt;进程是作为除CPU之外的系统资源的分配单位
&lt;ul&gt;
&lt;li&gt;这里注意题目中一般可能&lt;strong&gt;不特地强调除CPU之外&lt;/strong&gt;,除非特地考查这个概念,不然默认是对的&lt;/li&gt;
&lt;li&gt;特地强调了引入线程后,还说是资源调度和分配的基本单位就是错的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;多对一模型中,一个线程阻塞,整个进程都阻塞&lt;/li&gt;
&lt;li&gt;对进程进行定义时,如果带有静态的概念就是错的
&lt;ul&gt;
&lt;li&gt;例如说进程是多道程序环境下的完整程序就是错的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;C语言编写的程序在使用内存时一般分为3段:正文段(即代码和赋值数据段),数据堆段,数据栈段
&lt;ul&gt;
&lt;li&gt;二进制代码和常量(#define 标识符 常量)在正文段
&lt;ul&gt;
&lt;li&gt;全局赋值变量&lt;/li&gt;
&lt;li&gt;常量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;动态分配的存储区在数据堆段
&lt;ul&gt;
&lt;li&gt;动态内存分配&lt;/li&gt;
&lt;li&gt;new,malloc&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;临时使用的变量在数据栈段
&lt;ul&gt;
&lt;li&gt;未赋值的局部变量&lt;/li&gt;
&lt;li&gt;实参传递&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;//main.cpp
int a = 0; //全局初始化区
int a = 0; //全局初始化区
char *p1; //全局未初始化区
main() {
    int b; //栈
    char s[] = &amp;quot;abc&amp;quot;; //栈
    char *p2; //栈
    char *p3 = &amp;quot;123456&amp;quot;; //123456\0在常量区，p3在栈上。
    static int c = 0; //全局（静态）初始化区
    p1 = (char *)malloc(10);
    p2 = (char *)malloc(20);
    //分配得来得10和20字节的区域就在堆区。
    strcpy(p1, &amp;quot;123456&amp;quot;); //123456\0放在常量区，编译器可能会将它与p3所指向的&amp;quot;123456&amp;quot;优化成一个地方。
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;系统动态DLL库中的系统线程,被不同的进程调用时,任然是相同的线程&lt;/li&gt;
&lt;li&gt;进程创建需要占用系统内存来存放PCB数据结构,所以一个系统能够创建的进程数量是有限的,最大数目取决于内存的大小&lt;/li&gt;
&lt;li&gt;阻塞态和挂起态的区别
&lt;ul&gt;
&lt;li&gt;阻塞态任然处于五个转化状态中,而挂起态一般直接被操作系统在调度时忽略了,除非恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;     操作系统中睡眠、阻塞、挂起的区别形象解释：

     首先这些术语都是对于线程来说的。对线程的控制就好比你控制了一个雇工为你干活。你对雇工的控制是通过编程来实现的。
     挂起线程的意思就是你对主动对雇工说：“你睡觉去吧，用着你的时候我主动去叫你，然后接着干活&amp;quot;。
     使线程睡眠的意思就是你主动对雇工说：“你睡觉去吧，某时某刻过来报到，然后接着干活”。
     线程阻塞的意思就是，你突然发现，你的雇工不知道在什么时候没经过你允许，自己睡觉呢，但是你不能怪雇工，肯定你这个雇主没注意，本来你让雇工扫地，结果扫帚被偷了或被邻居家借去了，你又没让雇工继续干别的活，他就只好睡觉了。至于扫帚回来后，雇工会不会知道，会不会继续干活，你不用担心，雇工一旦发现扫帚回来了，他就会自己去干活的。因为雇工受过良好的培训。这个培训机构就是操作系统。
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;一般默认进程创建完成后就进入就绪队列,除非特地考查资源未分配全进入阻塞态&lt;/li&gt;
&lt;li&gt;就绪队列不空时,处理器的效率是不变的,和就绪进程数量无关,因为只要有在就绪队列里,就可以一直执行&lt;/li&gt;
&lt;li&gt;对进程的管理和控制使用&lt;strong&gt;原语&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;I.用户登录成功后，系统要为此创建一个用户管理的进程，包括用户桌面、环境等。所有用户进程都会在该进程下创建和管理。Ⅱ.设备分配是通过在系统中设置相应的数据结构实现的，不需要创建进程，这是操作系统中/O核心子系统的内容。班.启动程序执行是引起创建进程的典型事件。&lt;/li&gt;
&lt;li&gt;进程中的线程共享进程内的全部资源，但进程中某线程的栈指针对其他线程是透明的，不能与其他线程共享。&lt;/li&gt;
&lt;li&gt;进程可以在时间片用完时降低优先级以让其他的进程被调度进入执行状态,不应该在就绪态转为运行态时降低优先级&lt;/li&gt;
&lt;li&gt;当一个进程被唤醒时，这个进程就进入了就绪态，等待进程调度而占有CPU运行。
&lt;ul&gt;
&lt;li&gt;进程被唤醒在某种情形下优先级可以增大，但一般不会变为最大，而由固定的算法来计算。&lt;/li&gt;
&lt;li&gt;也不会在唤醒后位于就绪队列的队首，就绪队列是按照一定的规则赋予其位置的，如先来先服务，或者高优先级优先，或者短进程优先等，更不能直接占有处理器运行(存在疑问)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程间的通信主要有管道、消息传递、共享内存、文件映射和套接字等。数据库不能用于进程间通信。&lt;/li&gt;
&lt;li&gt;进程可以创建进程或线程，线程也可以创建线程，但线程不能创建进程。&lt;/li&gt;
&lt;li&gt;管道实际上是一种固定大小的缓冲区，管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户、单独构成的一种文件系统，并且只存在于内存中。
&lt;ul&gt;
&lt;li&gt;它类似于通信中半双工信道的进程通信机制，一个管道可以实现双向的数据传输，而同一时刻只能最多有一个方向的传输，不能两个方向同时进行。&lt;/li&gt;
&lt;li&gt;管道的容量大小通常为内存上的一页，它的大小并不受磁盘容量大小的限制。&lt;/li&gt;
&lt;li&gt;当管道满时，进程在写管道会被阻塞，而当管道空时，进程在读管道会被阻塞&lt;/li&gt;
&lt;li&gt;一个管道只能有一个读进程或一个写进程对其操作是错的
&lt;ul&gt;
&lt;li&gt;有些说是可以有多个读进程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;filedes[0]用于读出数据，读取时必须关闭写入端，即close(filedes[1]);&lt;br&gt;
filedes[1]用于写入数据，写入时必须关闭读取端，即close(filedes[0])。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int main(void)
{
    int n;
    int fd[2];
    pid_t pid;
    char line[MAXLINE];
   
    if(pipe(fd)  0){                 /* 先建立管道得到一对文件描述符 */
        exit(0);
    }

    if((pid = fork())  0)            /* 父进程把文件描述符复制给子进程 */
        exit(1);
    else if(pid &amp;gt; 0){                /* 父进程写 */
        close(fd[0]);                /* 关闭读描述符 */
        write(fd[1], &amp;quot;\nhello world\n&amp;quot;, 14);
    }
    else{                            /* 子进程读 */
        close(fd[1]);                /* 关闭写端 */
        n = read(fd[0], line, MAXLINE);
        write(STDOUT_FILENO, line, n);
    }

    exit(0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;某进程退出临界区时,之前申请临界区资源而不得进入阻塞态的进程会被唤醒&lt;/li&gt;
&lt;li&gt;用户级线程间的切换效率比内核级的高&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;简答题&#34;&gt;简答题&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;举例说明进程和程序间可以形成一对一,一对多,多对一,多对多关系
&lt;ul&gt;
&lt;li&gt;分析&lt;br&gt;
从进程的概念、进程与程序之间的关系来考虑问题的解答。进程是程序的执行过程，进程代表执行中的程序，因此进程与程序的差别就隐含在“执行”之中。程序是静态的指令集合，进程是程序的动态执行过程。静态的程序除占用磁盘空间外，不需要其他系统资源，只有执行中的进程才需要分配内存、CPU等系统资源。&lt;br&gt;
进程的定义说明了两点：&lt;br&gt;
1）进程与程序相关，进程包含了程序。程序是进程的核心内容，没有程序就没有进程。&lt;br&gt;
2）进程不仅仅是程序，还包含程序在执行过程中使用的全部资源。没有资源，程序就无法执行，因此进程是程序执行的载体。&lt;br&gt;
运行一个程序时，操作系统首先要创建一个进程，为进程分配内存等资源，然后加入进程队列中执行。对单个进程在某个时刻而言，一个进程只能执行一个程序，进程与程序之间是一对一的关系。但对整个系统中的进程集合及进程的生命周期而言，进程与程序之间可以形成一对一、多对一、一对多、多对多的关系。&lt;/li&gt;
&lt;li&gt;解答：&lt;br&gt;
执行一条命令或运行一个应用程序时，进程和程序之间形成一对一的关系。进程在执行过程中可以加载执行不同的应用程序，从而形成一对多的关系；以不同的参数或数据多次执行同一个应用程序时，形成多对一的关系；并发地执行不同的应用程序时，形成多对多的关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;父进程创建子进程和主程序调用子程序的区别
&lt;blockquote&gt;
&lt;p&gt;父进程创建子进程后，父进程与子进程同时执行（并发）。主程序调用子程序后，主程序暂停在调用点，子程序开始执行，直到子程序返回，主程序才开始执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;为啥进程间通信必须借助操作系统的内核功能
&lt;blockquote&gt;
&lt;p&gt;在操作系统中，进程是竞争和分配计算机系统资源的基本单位。每个进程都有自己的独立地址空间。为了保证多个进程能够彼此互不干扰地共享物理内存，操作系统利用硬件地址机制对进程的地址空间进行了严格的保护，限制每个进程只能访问自己的地址空间。&lt;br&gt;
解答：&lt;br&gt;
每个进程有自己独立的地址空间。在操作系统和硬件的地址保护机制下，进程无法访问其他进程的地址空间，所以必须借助于操作系统的系统调用函数实现进程之间的通信。进程通信的主要方式有：&lt;br&gt;
1）共享内存区。通过系统调用创建共享内存区。多个进程可以（通过系统调用）连接同一个共享内存区，通过访问共享内存区实现进程之间的数据交换。使用共享内存区时需要利用信号量解决同步互斥问题。&lt;br&gt;
2）消息传递。通过发送/接收消息，系统调用实现进程之间的通信。当进程发送消息时，系统将消息从用户缓冲区复制到内核中的消息缓冲区，然后将消息缓冲区挂入消息队列。进程发送的消息保持在消息队列中，直到被另一进程接收。当进程接收消息时，系统从消息队列中解挂消息缓冲区，将消息从内核的消息缓冲区中复制到用户缓冲区，然后释放消息缓冲区。&lt;br&gt;
3）管道系统。管道是先进先出（FIFO）的信息流，允许多个进程向管道写入数据，允许多个进程从管道读出数据。在读/写过程中，操作系统保证数据的写入顺序和读出顺序是一致的。进程通过读/写管道文件或管道设备实现彼此之间的通信。&lt;br&gt;
4）共享文件。利用操作系统提供的文件共享功能实现进程之间的通信。这时，也需要信号量来解决文件共享操作中的同步和互斥问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;啥是多线程,多线程和多任务的区别
&lt;blockquote&gt;
&lt;p&gt;多线程是指在一个程序中可以定义多个线程并同时运行它们，每个线程可以执行不同的任务。多线程与多任务的区别：多任务是针对操作系统而言的，代表操作系统可以同时执行的程序个数；多线程是针对一个程序而言的，代表一个程序可以同时执行的线程个数，而每个线程可以完成不同的任务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;五题
&lt;blockquote&gt;
&lt;p&gt;1）为支持多进程的并发执行，系统为每个进程建立了一个数据结构：进程控制块（PCB），用于进程的管理和控制。PCB中记录了有关进程的一些描述信息和控制信息，包括进程标识符、进程当前的状态、优先级、进程放弃CPU时的现场信息，以及指示组成进程的程序和数据在存储器中存放位置的信息、资源使用信息、进程各种队列的连接指针和反映进程之间的隶属关系的信息等。&lt;br&gt;
2）在进程的整个生命周期中，会经历多种状态。进程控制的主要职能是对系统中所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程的状态转换等功能。在操作系统内核中，有一组程序专门用于完成对进程的控制，这些原语至少需要包括创建新进程原语、阻塞进程原语、唤醒进程原语、终止进程原语等操作。系统服务对用户开放，即用户可以通过相应的接口来使用它们。&lt;br&gt;
3）进程创建原语：从PCB集合中申请一个空白的PCB，将调用者参数（如进程外部标识符、初始CPU状态、进程优先数、初始内存及申请资源清单等）添入该PCB，设置记账数据。&lt;br&gt;
置新进程为“就绪”态。&lt;br&gt;
终止进程原语：用于终止完成的进程，回收其所占资源。包括消去其资源描述块，消去进程的PCB。阻塞原语：将进程从运行态变为阻塞态。进程被插入等待事件的队列，同时修改PCB中相应的表项，如进程状态和等待队列指针等。&lt;br&gt;
唤醒原语：将进程从阻塞态变为就绪态。进程从阻塞队列中移出，插入就绪队列，等待调度，同时修改PCB中相应的表项，如进程状态等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
">第二章 进程线程概念部分错题及重要知识点</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/jin-cheng-de-gai-nian-xiang-guan-zhi-shi-dian/"" data-c="
          &lt;h2 id=&#34;概念&#34;&gt;概念&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/songdlut/Picbed_PicGo/master/img/OS2.2.png&#34; alt=&#34;1.1&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;动态性是进程的最基本特征&lt;/li&gt;
&lt;li&gt;进程是资源分配和接受调度的单位&lt;/li&gt;
&lt;li&gt;各进程以不可知的速度前进,&lt;strong&gt;可能导致运行结果的不确定性&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;PCB是进程存在的唯一标志&lt;/li&gt;
&lt;li&gt;注意
&lt;ul&gt;
&lt;li&gt;进程的管理者(操作系统)所需的数据都在PCB中&lt;/li&gt;
&lt;li&gt;程序本身的运行所需的数据在程序段和数据段中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;状态与转换&#34;&gt;状态与转换&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/songdlut/Picbed_PicGo/master/img/OS.png&#34; alt=&#34;1.2&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/09/UncERA.jpg&#34; alt=&#34;UncERA.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/09/UncAGd.jpg&#34; alt=&#34;UncAGd.jpg&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注意单核双核&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;进程间通信&#34;&gt;进程间通信&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;管道通信
&lt;ul&gt;
&lt;li&gt;写满时不能再写;读空时不能再读&lt;/li&gt;
&lt;li&gt;未写满时不能读;未读空时不能写&lt;/li&gt;
&lt;li&gt;一个管道半双工通信,双向通信要俩管道&lt;/li&gt;
&lt;li&gt;设置一个特殊的共享文件(管道),其实就是一个缓冲区&lt;/li&gt;
&lt;li&gt;各进程互斥访问管道&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;共享存储
&lt;ul&gt;
&lt;li&gt;王道书上说管道是其优化和发展,感觉错的,肯定共享存储是最吊的&lt;/li&gt;
&lt;li&gt;互斥地访问共享空间&lt;/li&gt;
&lt;li&gt;两种方式
&lt;ul&gt;
&lt;li&gt;基于数据的(低级)&lt;/li&gt;
&lt;li&gt;基于存储区的共享(高级)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;消息传递
&lt;ul&gt;
&lt;li&gt;传送结构化的消息(消息头/消息体)&lt;/li&gt;
&lt;li&gt;系统提供__发送接收原语__&lt;/li&gt;
&lt;li&gt;两种方式
&lt;ul&gt;
&lt;li&gt;直接通信方式:消息挂到接收方的消息队列&lt;/li&gt;
&lt;li&gt;简介(信箱)通信方式:消息先发到中间体(信箱)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程概念及实现&#34;&gt;线程概念及实现&lt;/h2&gt;
&lt;h3 id=&#34;概念-2&#34;&gt;概念&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://raw.githubusercontent.com/songdlut/Picbed_PicGo/master/img/20200709183533.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;线程可以相同的代码,也可以用不同的代码&lt;/li&gt;
&lt;li&gt;进程的地址空间相互独立,某进程内的线程对于其他进程不可见&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程的实现&#34;&gt;线程的实现&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;用户级线程&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/09/Un8WO1.png&#34; alt=&#34;Un8WO1.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/09/Unwa6S.png&#34; alt=&#34;Unwa6S.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;线程的管理工作由应用程序通过线程库来完成的&lt;/li&gt;
&lt;li&gt;不请求系统服务,在用户态下就完成线程切换&lt;/li&gt;
&lt;li&gt;操作系统意识不到用户级线程的存在&lt;/li&gt;
&lt;li&gt;优缺点
&lt;ul&gt;
&lt;li&gt;切换在用户空间完成,不需要切换到核心态,管理的开销小&lt;/li&gt;
&lt;li&gt;某个用户级线程被阻塞,整个进程都会阻塞,并发度不高,多个线程不可在多核处理机上并行运行
&lt;ul&gt;
&lt;li&gt;因为在操作系统上还是以进程运行的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;内核级线程&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/09/UnBbLD.png&#34; alt=&#34;UnBbLD.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;线程的管理由操作系统完成&lt;/li&gt;
&lt;li&gt;线程的切换需要CPU变态,即切换到核心态&lt;/li&gt;
&lt;li&gt;操作系统可以意识到内核级线程的存在
&lt;ul&gt;
&lt;li&gt;操作系统会为每个内核级线程建立相应的TCB,通过TCB对线程进行管理&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;优缺点
&lt;ul&gt;
&lt;li&gt;优点:当一个线程被阻塞的时候,别的线程还可以继续执行,并发能力强;多线程可以在多核处理机上并发执行&lt;/li&gt;
&lt;li&gt;一个用户进程会占用多个内核级线程,线程的切换由操作系统完成,需要切换到核心态因此线程的管理成本高,开销大&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;多线程模型&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/09/UnrnNd.png&#34; alt=&#34;UnrnNd.png&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/09/Unrq5d.png&#34; alt=&#34;Unrq5d.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;这种多对一的线程是无法__并行__运行的&lt;/li&gt;
&lt;li&gt;这个进程被分配了多个内核级线程时,如果在多核情况下,这些内核级线程肯定可以__并行__运行
&lt;ul&gt;
&lt;li&gt;但是考试中提到多对一模型则默认一个进程只被分配一个内核级线程&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/09/Un6Fcq.png&#34; alt=&#34;Un6Fcq.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;内核级线程可以运行任意一个有映射关系的用户级线程代码,只有两个内核级线程中正在运行的代码逻辑都阻塞时,这个进程才会阻塞&lt;br&gt;
&lt;img src=&#34;https://s1.ax1x.com/2020/07/09/Un6TbT.png&#34; alt=&#34;Un6TbT.png&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
">进程的概念相关知识点</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-er-zhang-jin-cheng-guan-li/"" data-c="
          &lt;p&gt;&lt;strong&gt;考试内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程与线程
&lt;ul&gt;
&lt;li&gt;进程的概念&lt;/li&gt;
&lt;li&gt;进程的状态与转换&lt;/li&gt;
&lt;li&gt;进程控制&lt;/li&gt;
&lt;li&gt;进程组织&lt;/li&gt;
&lt;li&gt;进程通信&lt;/li&gt;
&lt;li&gt;线程概念与多线程模型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;处理机调度
&lt;ul&gt;
&lt;li&gt;调度的基本概念&lt;/li&gt;
&lt;li&gt;调度时机,切换与过程&lt;/li&gt;
&lt;li&gt;调度的基本准则&lt;/li&gt;
&lt;li&gt;调度方式&lt;/li&gt;
&lt;li&gt;典型调度算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;进程同步
&lt;ul&gt;
&lt;li&gt;进程同步的基本概念&lt;/li&gt;
&lt;li&gt;实现临界区互斥的基本方法&lt;/li&gt;
&lt;li&gt;信号量&lt;/li&gt;
&lt;li&gt;管程&lt;/li&gt;
&lt;li&gt;经典同步问题&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;死锁
&lt;ul&gt;
&lt;li&gt;死锁的概念&lt;/li&gt;
&lt;li&gt;死锁处理策略&lt;/li&gt;
&lt;li&gt;死锁预防&lt;/li&gt;
&lt;li&gt;死锁避免&lt;/li&gt;
&lt;li&gt;死锁的检测和解除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;知识框架&lt;/strong&gt;&lt;/p&gt;
">第二章 进程管理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/zhong-duan-de-gai-nian-ji-zuo-yong/"" data-c="
          &lt;ol&gt;
&lt;li&gt;当中断发生后,CPU立即进入__核心态__&lt;/li&gt;
&lt;li&gt;当中断发生后,当前运行的进程暂停运行,并由操作系统内核对中断进行处理&lt;/li&gt;
&lt;li&gt;对于不同的中断信号,会进行不同的处理&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;发生了中断，就意味着需要操作系统介入，开展管理工作。由于操作系统的管理工作（比如进程切换、分配I/O设备等）需要使用特权指令，因此CPU要从用户态转为核心态。&lt;strong&gt;中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权&lt;/strong&gt;。有了中断，才能实现多道程序并发执行。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户态-&amp;gt;核心态是通过中断实现的,并且中断是唯一途径&lt;/li&gt;
&lt;li&gt;核心态-&amp;gt;用户态的切换是通过执行一个特权指令,将程序状态字(PSW)的标志位设置为&amp;quot;用户态&amp;quot;&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/songdlut/Picbed_PicGo/master/img/zhongduan1.png&#34; alt=&#34;1.1&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/songdlut/Picbed_PicGo/master/img/zhongduan2.png&#34; alt=&#34;1.2&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/songdlut/Picbed_PicGo/master/img/zhongduan6.png&#34; alt=&#34;1.6&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/songdlut/Picbed_PicGo/master/img/zhongduan3.png&#34; alt=&#34;1.3&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/songdlut/Picbed_PicGo/master/img/zhongduan4.png&#34; alt=&#34;1.4&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/songdlut/Picbed_PicGo/master/img/zhongduan5.png&#34; alt=&#34;1.5&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;陷入指令是唯一一个只能在用户态下执行的指令&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
">中断的概念及作用</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-yi-zhang-cuo-ti-ji-chong-dian-wen-ti-zheng-li/"" data-c="
          &lt;h2 id=&#34;1概念&#34;&gt;1.概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;高级程序设计语言的__编译器不是__操作系统关心的问题
&lt;ul&gt;
&lt;li&gt;用户界面并非是必须的,但却包含在操作系统范畴内&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OS基本功能是__控制管理系统内的各种资源__
&lt;ul&gt;
&lt;li&gt;注意网络管理,用户界面,可视化编辑程序都不是最基本的功能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;用户可以通过__命令接口和系统调用__来使用计算机&lt;/li&gt;
&lt;li&gt;系统调用只能通过用户程序间接使用&lt;/li&gt;
&lt;li&gt;系统调用的目的是__请求系统服务__
&lt;ul&gt;
&lt;li&gt;不是什么申请/释放资源,终止服务啥的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OS与用户通信接口通常不包括__缓存管理指令__
&lt;ul&gt;
&lt;li&gt;系统中的缓存全部由OS管理,对用户是透明的&lt;/li&gt;
&lt;li&gt;shell(命令解析器),命令解释器,广义指令(系统调用)都是通信接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;库函数与系统调用的区别与联系&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;库函数是语言或应用程序的一部分,可以运行在用户空间中&lt;/li&gt;
&lt;li&gt;系统调用是操作系统的一部分,是内核为用户提供的程序接口,运行在内核空间中&lt;/li&gt;
&lt;li&gt;许多库函数会使用系统调用来实现功能&lt;/li&gt;
&lt;li&gt;未使用系统调用的库函数执行效率通常要比系统调用的高&lt;/li&gt;
&lt;li&gt;因为使用系统调用需要上下文切换以及状态的转换(由用户态转移到核心态)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;各技术所解决的问题
&lt;ul&gt;
&lt;li&gt;脱机技术用于解决独占设备问题。&lt;/li&gt;
&lt;li&gt;虚拟技术与交换技术以多道程序设计技术为前提。&lt;/li&gt;
&lt;li&gt;多道程序设计技术由于同时在主存中运行多个程序，在一个程序等待时，可以去执行其他程序，因此提高了系统咨源的利用率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;引入多道程序后,程序的执行就失去了顺序性和封闭性,执行的程序是断续的&lt;/li&gt;
&lt;li&gt;操作系统的基本主要类型:
&lt;ul&gt;
&lt;li&gt;批处理OS&lt;/li&gt;
&lt;li&gt;分时OS&lt;/li&gt;
&lt;li&gt;实时OS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;中断技术使得多道批处理系统和I/O设备可与CPU并行工作&lt;/li&gt;
&lt;li&gt;实时系统的进度调度通常采用__抢占式的优先级高者优先__算法&lt;/li&gt;
&lt;li&gt;实时OS的主要目标不包括__资源利用率__&lt;/li&gt;
&lt;li&gt;分时OS的主要目标是__比较快速响应用户__&lt;/li&gt;
&lt;li&gt;分时OS响应时间T≈QN,Q:时间片;N:用户数&lt;/li&gt;
&lt;li&gt;批处理OS,分时OS,实时OS的各自特点
&lt;ul&gt;
&lt;li&gt;批处理操作系统的用户脱机使用计算机，作业是成批处理的，系统内多道程序并发执行，交互能力差。&lt;/li&gt;
&lt;li&gt;分时操作系统可让多个用户同时使用计算机，人机交互性较强，具有每个用户独立使用计算机的独占性，系统响应及时&lt;/li&gt;
&lt;li&gt;实时操作系统能对控制对象做出及时反应，可靠性高，响应及时，但资源利用率低。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2中断等&#34;&gt;2.中断等&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;进程调度可以不需要硬件支持,而时钟管理,地址映射,中断系统都需要硬件的支持&lt;/li&gt;
&lt;li&gt;用户态到核心态的转换由__硬件__完成&lt;/li&gt;
&lt;li&gt;中断处理程序一般在核心态执行,因此无法完成&amp;quot;转换成核心态&amp;quot;这一任务&lt;/li&gt;
&lt;li&gt;命令解释程序是运行在用户态的&lt;/li&gt;
&lt;li&gt;注意区分在__用户态执行和发生的区别__
&lt;ul&gt;
&lt;li&gt;例如系统调用发生在用户态,而被调用程序在核心态下执行&lt;/li&gt;
&lt;li&gt;外部中断是用户态到核心态的&amp;quot;门&amp;quot;,发生在用户态,但是在核心态完成中断过程&lt;/li&gt;
&lt;li&gt;进程切换术语系统调用的执行过程中的事件,只能发生在核心态&lt;/li&gt;
&lt;li&gt;缺页产生后,在用户态发生缺页中断,然后进入核心态执行缺页程序中断服务程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;只能在核心态下执行的指令&lt;/strong&gt;(继续补充)
&lt;ul&gt;
&lt;li&gt;置时钟指令&lt;/li&gt;
&lt;li&gt;广义指令&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不是只能在核心态下&amp;quot;执行&amp;quot;的指令&lt;/strong&gt;(继续补充)
&lt;ul&gt;
&lt;li&gt;读时钟指令&lt;/li&gt;
&lt;li&gt;取数指令&lt;/li&gt;
&lt;li&gt;寄存器清零&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;陷入指令是唯一一个只能在用户态下执行而不能在核心态下执行的指令&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;中断处理和子程序调用的区别(重要)
&lt;ul&gt;
&lt;li&gt;子程序调用只需保存程序断点，即该指令的下一条指令的地址；&lt;/li&gt;
&lt;li&gt;中断调用子程序不仅要保存断点（PC的内容），还要保存程序状态字寄存器（PSW）的内容。在中断处理中，最重要的两个寄存器是PC和PSWR。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;关中断指令是权限非常大的指令,必须在核心态才能执行
&lt;ul&gt;
&lt;li&gt;trap指令,跳转指令,压栈指令均可在用户态下执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有关内部异常的叙述
&lt;ul&gt;
&lt;li&gt;内部异常的产生与当前执行指令相关&lt;/li&gt;
&lt;li&gt;内部异常的检测由CPU内部逻辑实现&lt;/li&gt;
&lt;li&gt;内部异常的响应发生在指令执行过程中
&lt;ul&gt;
&lt;li&gt;内中断是指来自CPU和内存内部产生的中断，包括程序运算引起的各种错误，如地址非法、校验错、页面失效、非法指令、用户程序执行特权指令自行中断（INT）和除数为零等，以上都是在指令的执行过程中产生的，因此A正确。这种检测异常的工作肯定是由CPU（包括控制器和运算器）实现的，因此B正确。内中断不能被屏蔽，一旦出现应立即处理，C正确。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;(&lt;strong&gt;错误&lt;/strong&gt;)内部异常处理后返回到发生异常的指令继续执行
&lt;ul&gt;
&lt;li&gt;考虑到特殊情况，如除数为零和自行中断（INT）都会自动跳过中断指令，所以不会返回到发生异常的指令继续执行，因此错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意狭义中断和广义中断
&lt;ul&gt;
&lt;li&gt;广义上,异常(内中断)和外部中断都叫&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;外部中断处理过程，PC值由中断隐指令自动保存，而通用寄存器内容由操作系统保存。(重要)&lt;/li&gt;
&lt;li&gt;MOV R0,addr:有可能出现缺页异常的可能&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;执行系统调用的过程如下&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;正在运行的进程先传递系统调用参数，然后由陷入（trap）指令负责将用户态转换为内核态，并将返回地址压入堆栈以备后用，接下来CPU执行相应的内核态服务程序，最后返回用户态。所以选项C正确。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;时钟中断的主要工作是处理和时间有关的信息及决定是否执行调度程序。和时间有关的所有信息包括系统时间、进程的时间片、延时、使用CPU的时间、各种定时器，因此I、Ⅱ、IⅢ均正确。&lt;/li&gt;
&lt;li&gt;不同的操作系统为应用程序提供的系统调用接口也不同&lt;/li&gt;
&lt;li&gt;设备管理属于操作系统的职能之一，包括对输入/输出设备的分配、初始化、维护等，用户程序需要通过系统调用使用操作系统的设备管理服务(重要)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;区分执行态的主要目的是保护系统程序&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;用户态到核心态的转换发生在中断产生时，而核心态到用户态的转换则发生在中断返回用户程序时。&lt;/li&gt;
&lt;li&gt;为什么说直到出现中断和通道技术之后,多道程序概念才变得有用?
&lt;ul&gt;
&lt;li&gt;多道程序并发执行是指有的程序正在CPU上执行，而另一些程序正在I/O设备上进行传输，即通过CPU操作与外设传输在时间上的重叠必须有中断和通道技术的支持，原因如下：&lt;br&gt;
1）通道是一种控制一台或多台外部设备的硬件机构，它一旦被启动就独立于CPU运行，因而做到了输入/输出操作与CPU并行工作。但早期CPU与通道的联络方法是由CPU向通道发出询问指令来了解通道工作是否完成的。若未完成，则主机就循环询问直到通道工作结束为止。因此，这种询问方式是无法真正做到CPU与I/O设备并行工作的。&lt;br&gt;
2）在硬件上引入了中断技术。所谓中断，就是在输入/输出结束时，或硬件发生某种故障时，由相应的硬件（即中断机构）向CPU发出信号，这时CPU立即停下工作而转向处理中断请求，待处理完中断后再继续原来的工作。&lt;br&gt;
因此，通道技术和中断技术结合起来就可实现CPU与I/O设备并行工作，即CPU启动通道传输数据后便去执行其他程序的计算工作，而通道则进行输入/输出操作；当通道工作结束时，再通过中断机构向CPU发出中断请求，CPU则暂停正在执行的操作，对出现的中断进行处理，处理完后再继续原来的工作。这样，就真正做到了CPU与IVO设备并行工作。此时，多道程序的概念才变为现实。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3本章疑难点&#34;&gt;3.本章疑难点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;并行性与并发性的区别和联系&lt;br&gt;
并行性和并发性是既相似又有区别的两个概念。并行性是指两个或多个事件在同一时刻发生，并发性是指两个或多个事件在同一时间间隔内发生。&lt;br&gt;
在多道程序环境下，并发性是指在一段时间内，宏观上有多个程序同时运行，但在单处理器系统中每个时刻却仅能有一道程序执行，因此微观上这些程序只能分时地交替执行。若在计算机系统中有多个处理器，则这些可以并发执行的程序便被分配到多个处理器上，实现并行执行，即利用每个处理器来处理一个可并发执行的程序。&lt;/li&gt;
&lt;li&gt;特权指令与非特权指令&lt;br&gt;
所谓特权指令，是指有特殊权限的指令，由于这类指令的权限最大，使用不当将导致整个系统崩溃，如清内存、置时钟、分配系统资源、修改虚存的段表或页表、修改用户的访问权限等。若所有程序都能使用这些指令，则系统一天死机n次就不足为奇。为保证系统安全，这类指令只能用于操作系统或其他系统软件，不直接提供给用户使用。因此，特权指令必须在核心态执行。&lt;br&gt;
实际上，CPU在核心态下可以执行指令系统的全集。形象地说，特权指令是那些儿童不宜的东西，而非特权指令是老少皆宜的东西。&lt;br&gt;
为了防止用户程序中使用特权指令，用户态下只能使用非特权指令，核心态下可以使用全部指令。在用户态下使用特权指令时，将产生中断以阻止用户使用特权指令。所以把用户程序放在用户态下运行，而操作系统中必须使用特权指令的那部分程序在核心态下运行，保证了计算机系统的安全可靠。从用户态转换为核心态的唯一途径是中断或异常。&lt;/li&gt;
&lt;li&gt;访管指令与访管中断&lt;br&gt;
访管指令是一条可以在用户态下执行的指令。在用户程序中，因要求操作系统提供服务而有意识地使用访管指令，从而产生一个中断事件（自愿中断），将操作系统转换为核心态，称为访管中断。访管中断由访管指令产生，程序员使用访管指令向操作系统请求服务。&lt;br&gt;
为什么要在程序中引入访管指令呢？这是因为用户程序只能在用户态下运行。若用户程序想要完成在用户态下无法完成的工作，该怎么办？解决这个问题要靠访管指令。访管指令本身不是特权指令，其基本功能是让程序拥有“自愿进管”的手段，从而引起访管中断。&lt;br&gt;
处于用户态的用户程序使用访管指令时，系统根据访管指令的操作数执行访管中断处理程序，访管中断处理程序将按系统调用的操作数和参数转到相应的例行子程序。完成服务功能后，退出中断，返回到用户程序断点继续执行。&lt;/li&gt;
&lt;/ol&gt;
">第一章错题及重点问题整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-yi-zhang-ji-suan-ji-xi-tong-yin-lun/"" data-c="
          &lt;p&gt;&lt;strong&gt;考试内容&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统的概念,特征,功能和提供的方服务&lt;/li&gt;
&lt;li&gt;操作系统的发展和分类&lt;/li&gt;
&lt;li&gt;操作系统的运行环境
&lt;ul&gt;
&lt;li&gt;内核态与用户态&lt;/li&gt;
&lt;li&gt;中断,异常&lt;/li&gt;
&lt;li&gt;系统调用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;操作系统体系结构&lt;br&gt;
&lt;strong&gt;知识框架&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/songdlut/Picbed_PicGo/master/img/OS1.1.png&#34; alt=&#34;1.1&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;重点&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;通常选择题的形式&lt;/li&gt;
&lt;li&gt;形成大体框架后,反复做题,完善知识体系&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;11-操作系统的基本概念&#34;&gt;1.1 操作系统的基本概念&lt;/h2&gt;
&lt;h3 id=&#34;111-操作系统的目标和作用&#34;&gt;1.1.1 操作系统的目标和作用&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;目标
&lt;ul&gt;
&lt;li&gt;方便性
&lt;ul&gt;
&lt;li&gt;裸机运行程序很不方便,要用机器语言书写程序&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;有效性
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;提高系统资源的利用率&lt;/strong&gt;:在早期未配置OS的计算机系统中，诸如处理机、I/O设备等都经常处于空闲状态，各种资源无法得到充分利用，所以在当时，提高系统资源利用率是推动OS发展最主要的动力。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;提高系统的吞吐量&lt;/strong&gt;:OS可以通过合理地组织计算机的工作流程，加速程序的运行，缩短程序的运行周期，从而提高了系统的吞吐量&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可扩充性
&lt;ul&gt;
&lt;li&gt;早期的无结构发展成模块化结构，进而又发展成层次化结构&lt;/li&gt;
&lt;li&gt;近年来OS已广泛采用了__微内核结构__。微内核结构能方便地增添新的功能和模块，以及对原有的功能和模块进行修改，具有良好的可扩充性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;开放性
&lt;ul&gt;
&lt;li&gt;所谓开放性，是指系统能遵循世界标准规范，特别是遵循开放系统互连OSI国际标准&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;作用&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;OS作为用户与计算机硬件系统之间的接口&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/songdlut/Picbed_PicGo/master/img/OS1.2.png&#34; alt=&#34;1.2&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;OS作为计算机系统资源的管理者
&lt;ul&gt;
&lt;li&gt;主要分为:处理机,存储器,I/O设备,文件(数据和程序)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OS实现了对计算机资源的抽象&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/songdlut/Picbed_PicGo/master/img/OS1.3.png&#34; alt=&#34;1.3&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
">第一章 计算机系统引论</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-er-zhang-xian-xing-biao/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#21-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E5%8F%8A%E6%93%8D%E4%BD%9C&#34;&gt;2.1 线性表相关概念及操作&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#211-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5&#34;&gt;2.1.1 线性表相关概念&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#212-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C&#34;&gt;2.1.2 线性表的基本操作&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#22-%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA&#34;&gt;2.2 线性表的顺序表示&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#221-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89&#34;&gt;2.2.1 顺序表的定义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#222-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E4%B8%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0&#34;&gt;2.2.2 顺序表上基本操作的实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
(目录)&lt;br&gt;
&lt;strong&gt;考点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性表的定义和基本操作&lt;/li&gt;
&lt;li&gt;线性表的实现
&lt;ul&gt;
&lt;li&gt;顺序存储&lt;/li&gt;
&lt;li&gt;链式存储&lt;/li&gt;
&lt;li&gt;线性表的应用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;知识框架&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/songdlut/Picbed_PicGo/master/img/DS2.1&#34; alt=&#34;2.1&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
&lt;strong&gt;重点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;考研命题重点&lt;/li&gt;
&lt;li&gt;代码量少,但是性能要求极高(时间,空间复杂度)&lt;/li&gt;
&lt;li&gt;基于两种存储结构的各种基本操作&lt;/li&gt;
&lt;li&gt;可执行性不强求(那肯定语法正确更好),但须尽量表达出算法的思想和步骤&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;21-线性表相关概念及操作&#34;&gt;2.1 线性表相关概念及操作&lt;/h2&gt;
&lt;h3 id=&#34;211-线性表相关概念&#34;&gt;2.1.1 线性表相关概念&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;线性结构的特点,在数据元素的非空有限集中:
&lt;ul&gt;
&lt;li&gt;存在惟一的一个被称做“第一个”的数据元素&lt;/li&gt;
&lt;li&gt;存在惟一的一个被称做“最后一个”的数据元素&lt;/li&gt;
&lt;li&gt;除第一个之外，集合中的每个数据元素均只有一个前驱&lt;/li&gt;
&lt;li&gt;除最后一个之外，集合中每个数据元素均只有一个后继。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线性表的定义&lt;br&gt;
线性表是具有相同数据类型的n(n≥0)个数据元素的__有限序列__，其中__n为表长，当n=0时线性表是一个空表__。若用L命名线性表，则其一般表示为:&lt;center&gt;L=(a&lt;sub&gt;1&lt;/sub&gt;,a&lt;sub&gt;2&lt;/sub&gt;,...,a&lt;sub&gt;i+1&lt;/sub&gt;,...,a&lt;sub&gt;n&lt;/sub&gt;)&lt;/center&gt;式中:
&lt;ul&gt;
&lt;li&gt;a&lt;sub&gt;1&lt;/sub&gt;是唯一的“第一个”数据元素，又称表头元素；&lt;/li&gt;
&lt;li&gt;a&lt;sub&gt;n&lt;/sub&gt;是唯一的“最后一个”数据元素，又称表尾元素。&lt;/li&gt;
&lt;li&gt;除第一个元素外，每个元素有且仅有一个直接前驱。&lt;/li&gt;
&lt;li&gt;除最后一个元素外，每个元素有且仅有一个直接后继。&lt;br&gt;
以上就是线性表的逻辑特性，这种线性有序的逻辑结构正是线性表名字的由来。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;线性表的特点:
&lt;ul&gt;
&lt;li&gt;表中元素的__个数有限__。&lt;/li&gt;
&lt;li&gt;表中元素具有逻辑上的__顺序性__，表中元素有其先后次序。&lt;/li&gt;
&lt;li&gt;表中元素都是数据元素，每个元素都是单个元素。&lt;/li&gt;
&lt;li&gt;表中元素的数据类型都相同，这意味着__每个元素占有相同大小的存储空间__。&lt;/li&gt;
&lt;li&gt;表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;注意点
&lt;ul&gt;
&lt;li&gt;线性表是一种逻辑结构，表示元素之间一对一的相邻关系。&lt;/li&gt;
&lt;li&gt;顺序表和链表是指存储结构，两者属于不同层面的概念，因此不要将其混淆。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;212-线性表的基本操作&#34;&gt;2.1.2 线性表的基本操作&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;一个数据结构的基本操作是指其最核心、最基本的操作。其他较复杂的操作可通过调用其基本操作来实现。线性表的主要操作如下:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;InitList(&amp;amp;L):初始化表。构造一个空的线性表。
Length(L):求表长。返回线性表L的长度，即L中数据元素的个数。
LocateElem(L，e):按值查找操作。在表L中查找具有给定关键字值的元素。返回i,无返回0(咱-1)
GetElem(L，i):按位查找操作。获取表工中第i个位置的元素的值。
ListInsert(&amp;amp;L，i，e):插入操作。在表L中的第i个位置上插入指定元素e。
Listpelete(&amp;amp;L，i，&amp;amp;e):删除操作。删除表工中第i个位置的元素，并用e返回删除元素的值。
PrintList(L):输出操作。按前后顺序输出线性表L的所有元素值。
Empty(L):判空操作。若L为空表，则返回true，否则返回false。
DestroyList(&amp;amp;L):销毁操作。销毁线性表，并释放线性表工所占用的内存空间。
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;注意:&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;基本操作的__实现取决于采用哪种存储结构__，存储结构不同，算法的实现也不同。&lt;/li&gt;
&lt;li&gt;&amp;quot;&amp;amp;&amp;quot;表示C++中的引用调用。若传入的变量是指针型变量，且在函数体内要对传入的指针进行改变，则会用到指针变量的引用型。在C中采用指针的指针也可达到同样的效果。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22-线性表的顺序表示&#34;&gt;2.2 线性表的顺序表示&lt;/h2&gt;
&lt;h3 id=&#34;221-顺序表的定义&#34;&gt;2.2.1 顺序表的定义&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;线性表的顺序表示是指用一组地址连续的存储单元依次存储线性表中数据元素,使得逻辑上相邻的两个元素在物理位置上也相邻.
&lt;ul&gt;
&lt;li&gt;线性表的顺序存储又称__顺序表__&lt;/li&gt;
&lt;li&gt;第1个元素存储在线性表的起始位置,也叫__基地址__&lt;/li&gt;
&lt;li&gt;第i个元素的存储位置后面紧接着存储的是第i+1个元素，称i为元素a&lt;sub&gt;i&lt;/sub&gt;在线性表中的位序。假设线性表L存储的起始位置为LOC(A)，sizeof(ElemType)是每个数据元素所占用存储空间的大小，则表L所对应的顺序存储如图;&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/songdlut/Picbed_PicGo/master/img/DS2.2&#34; alt=&#34;2.2&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;线性表的这种机内表示称作__线性表的顺序存储结构或顺序映像__&lt;/li&gt;
&lt;li&gt;顺序表的特点是表中元素的逻辑顺序与其物理顺序相同&lt;/li&gt;
&lt;li&gt;线性表中元素的位序是从1开始的,而数组中的元素的下标是从0开始的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;顺序表的描述&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;假定线性表的元素类型为ElemType，则线性表的顺序存储类型描述为(静态)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#define MaxSize50//定义线性表的最大长度
typedef struct{
    ElemType data[MaxSize]；//顺序表的元素
    int length；/顺序表的当前长度
}SqList;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;一维数组可以是静态分配的，也可以是动态分配的。
&lt;ul&gt;
&lt;li&gt;在静态分配时，由于数组的大小和空间事先已经固定，一旦空间占满，再加入新的数据将会产生溢出，进而导致程序崩溃。而在动态分配时，存储数组的空间是在程序执行过程中通过动态存储分配语句分配的，一旦数据空间占满，就另外开辟一块更大的存储空间，用以替换原来的存储空间，从而达到扩充存储数组空间的目的，而不需要为线性表一次性地划分所有空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#define InitSize 100//表长度的初始定义
typedef struct{
    Elemrype*data；//指示动态分配数组的指针
    int MaxSize，length；//数组的最大容量和当前个数
}SeqList；/动态分配数组顺序表的类型定义
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;    * C的初始动态分配语句:
    L.data=(ElemType*)malloc(sizeof(ElemType)*InitSize);
    * C++的初始动态分配语句
    L.data=newElemType(InitSize);
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;由于高级程序语言中的数组类型也有随机存取的特性,因此通常用数组来描述数据结构中的顺序存储结构&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意：动态分配并不是链式存储&lt;/strong&gt;，它同样属于顺序存储结构，物理结构没有变化，依然是随机存取方式，只是分配的空间大小可以在运行时决定。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;顺序表最主要的特点是随机访问，即通过首地址和元素序号可在时间O(1)内找到指定的元素。&lt;/li&gt;
&lt;li&gt;顺序表的存储密度高，每个结点只存储数据元素。&lt;/li&gt;
&lt;li&gt;顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;222-顺序表上基本操作的实现&#34;&gt;2.2.2 顺序表上基本操作的实现&lt;/h3&gt;
">第二章 线性表</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/bei-dan-ci-shi-yu-dao-dao-yi-si-xiang-jin-de-ci-冲突-宋宇航_Win10/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%92%8C%E4%BD%9C%E8%80%85%E6%80%81%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AF%8D&#34;&gt;和作者态度相关的词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%81%8C%E7%A7%B0%E7%A7%B0%E8%B0%93%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8D%95%E8%AF%8D&#34;&gt;职称,称谓相关的单词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BA%AB%E4%BD%93%E9%83%A8%E4%BD%8D%E7%9A%84&#34;&gt;身体部位的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E9%9B%87&#34;&gt;解雇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B8%A6%E6%9C%89%E5%88%A0%E9%99%A4%E5%BF%BD%E7%95%A5%E7%95%A5%E5%8E%BB%E6%8E%92%E9%99%A4%E6%84%8F%E5%91%B3%E7%9A%84%E8%AF%8D&#34;&gt;带有删除,忽略,略去,排除意味的词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B8%A6%E6%9C%89%E5%8C%85%E5%90%AB%E6%84%8F%E5%91%B3%E7%9A%84%E8%AF%8D&#34;&gt;带有包含意味的词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B8%A6%E6%9C%89%E6%83%B3%E8%B1%A1%E5%B9%BB%E6%83%B3%E6%84%8F%E5%91%B3%E7%9A%84&#34;&gt;带有想象,幻想意味的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%9F%E9%92%B1%E6%9C%89%E5%85%B3&#34;&gt;跟钱有关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%9F%E6%94%BF%E6%B2%BB%E6%94%BF%E5%BA%9C%E6%9C%89%E5%85%B3&#34;&gt;跟政治,政府有关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B3%95%E5%BE%8B%E7%8A%AF%E7%BD%AA%E4%B9%8B%E7%B1%BB%E7%9A%84&#34;&gt;法律犯罪之类的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8E%A2%E7%B4%A2%E8%BF%BD%E6%B1%82%E4%B9%8B%E7%B1%BB%E7%9A%84&#34;&gt;探索追求之类的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8C%85%E8%A3%B9%E7%9B%B8%E5%85%B3&#34;&gt;包裹相关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A1%A5%E4%B8%81%E7%A2%8E%E7%89%87%E5%9E%83%E5%9C%BE%E7%9B%B8%E5%85%B3&#34;&gt;补丁,碎片,垃圾相关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%92%8C%E6%95%B0%E9%87%8F%E7%9B%B8%E5%85%B3&#34;&gt;和数量相关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E4%BA%9B%E6%84%8F%E6%80%9D%E5%A4%AA%E5%A4%9A%E4%BD%86%E6%98%AF%E8%A1%A8%E7%A4%BA%E5%BE%88%E7%89%9B%E6%89%B9%E7%9A%84%E9%82%A3%E7%A7%8D%E6%84%8F%E6%80%9D&#34;&gt;一些意思太多,但是表示很牛批的那种意思&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%9B%84%E8%BE%A9%E7%9A%84%E6%9C%89%E8%AF%B4%E6%9C%8D%E5%8A%9B%E7%9A%84&#34;&gt;雄辩的,有说服力的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%96%98%E6%81%AF%E5%96%98%E6%B0%94%E6%B0%94%E5%96%98%E5%90%81%E5%90%81%E5%9C%B0%E8%AF%B4&#34;&gt;喘息,喘气,气喘吁吁地说&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A1%A8%E6%98%8E%E8%AF%81%E6%98%8E&#34;&gt;表明证明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%89%BF%E8%AE%A4&#34;&gt;承认&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%9B%B8%E5%85%B3%E6%80%A7%E7%9A%84%E6%9C%89%E5%85%B3%E8%81%94%E9%82%A3%E7%A7%8D%E6%84%8F%E6%80%9D%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8D%95%E8%AF%8D&#34;&gt;相关性的,有关联那种意思的一些单词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BC%80%E5%A7%8B%E7%9D%80%E6%89%8B%E5%81%9A&#34;&gt;开始,着手做&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%81%B0%E5%BD%93%E7%9A%84%E5%90%88%E9%80%82%E7%9A%84&#34;&gt;恰当的,合适的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B6%B3%E5%A4%9F%E7%9A%84%E9%82%A3%E7%A7%8D%E6%84%8F%E6%80%9D%E6%80%BB%E6%98%AF%E5%92%8C%E6%81%B0%E5%BD%93%E8%AE%B0%E6%B7%B7&#34;&gt;足够的那种意思(总是和恰当记混)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%93%E4%BD%8F%E5%A4%84%E7%90%86%E8%A7%A3%E5%86%B3&#34;&gt;抓住,处理,解决&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%BD%E4%BC%9A%E8%AE%AE%E4%BC%9A%E4%BB%A3%E8%A1%A8%E5%A4%A7%E4%BC%9A&#34;&gt;国会,议会,代表大会&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%90%86%E4%BA%8B%E4%BC%9A%E5%A7%94%E5%91%98%E4%BC%9A%E7%AD%89&#34;&gt;理事会,委员会等&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%89%A7%E8%8D%89%E5%9C%B0%E7%89%A7%E5%9C%BA&#34;&gt;牧草地,牧场&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BD%BF%E7%96%B2%E5%8A%B3&#34;&gt;(使)疲劳&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A6%A8%E7%A2%8D%E9%98%BB%E7%A2%8D&#34;&gt;妨碍,阻碍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%89%A9%E5%A4%A7%E5%A2%9E%E5%A4%A7&#34;&gt;扩大,增大&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A8%E5%A4%A7%E7%9A%84&#34;&gt;巨大的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%A4%E6%80%AA%E7%9A%84&#34;&gt;古怪的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%90%8C%E6%84%8F%E8%B5%9E%E6%88%90%E7%AD%94%E5%BA%94&#34;&gt;同意赞成答应&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%98%BE%E7%9C%BC%E7%9A%84%E6%98%8E%E6%98%BE%E7%9A%84&#34;&gt;显眼的,明显的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A1%A8%E7%A4%BA%E9%87%8D%E8%A6%81%E6%80%A7%E7%9A%84%E4%B8%80%E7%B1%BB%E8%AF%8D&#34;&gt;表示重要性的一类词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%90%88%E5%90%8C%E5%A5%91%E7%BA%A6%E6%9D%A1%E7%BA%A6%E5%85%AC%E7%BA%A6&#34;&gt;合同,契约,条约,公约&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AD%96%E5%88%92%E5%9B%BE%E8%B0%8B&#34;&gt;策划,图谋&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%87%A0%E4%B8%AA%E8%A1%A8%E7%A4%BA%E6%99%AE%E9%80%9A%E6%AD%A3%E5%B8%B8%E7%9A%84%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;几个表示普通正常的单词的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BD%BB%E8%A7%86%E8%94%91%E8%A7%86%E7%9E%A7%E4%B8%8D%E8%B5%B7&#34;&gt;轻视蔑视瞧不起&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BC%BA%E7%82%B9%E4%B8%8D%E8%B6%B3&#34;&gt;缺点,不足&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8E%A8%E5%8A%A8%E4%BF%83%E8%BF%9B&#34;&gt;推动促进&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B1%87%E9%9B%86%E8%81%9A%E9%9B%86&#34;&gt;汇集聚集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%B2%E5%88%87%E8%AF%9Axx%E4%B9%8B%E7%B1%BB%E7%9A%84&#34;&gt;亲切,诚XX之类的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B8%A6%E6%9C%89%E5%BE%AE%E5%BC%B1%E6%9C%A6%E8%83%A7%E6%99%A6%E6%B6%A9%E8%BF%99%E7%A7%8D%E5%90%AB%E4%B9%89%E7%9A%84&#34;&gt;带有微弱,朦胧,晦涩这种含义的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B0%BC%E7%8E%9B%E6%80%BB%E6%98%AF%E5%BF%98%E6%8E%89%E7%9A%84%E4%B8%80%E4%BA%9B&#34;&gt;尼玛总是忘掉的一些&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%A4%E9%80%9A%E5%B7%A5%E5%85%B7&#34;&gt;交通工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%9F%E8%8D%AF%E5%93%81%E5%8C%BB%E5%AD%A6%E6%9C%89%E5%85%B3%E7%9A%84%E8%AF%8D%E6%B1%87%E4%BB%8A%E5%B9%B4%E6%9C%89%E5%8F%AF%E8%83%BD%E8%80%83%E5%88%B0&#34;&gt;跟药品.医学有关的词汇(今年有可能考到)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3&#34;&gt;时间相关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8C%96%E5%B7%A5%E7%89%A9%E7%90%86%E7%A7%91%E6%8A%80&#34;&gt;化工,物理,科技&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%87%A0%E4%B8%AAf%E7%9A%84%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E5%8D%95%E8%AF%8D&#34;&gt;几个f的易混淆的单词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%87%A0%E4%B8%AAp%E5%BC%80%E5%A4%B4%E7%9A%84%E6%80%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%8D%95%E8%AF%8D&#34;&gt;几个P开头的总混淆的单词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3%E8%AF%8D%E6%B1%87&#34;&gt;数学,计算机相关词汇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%8E%8B%E5%9B%BD%E4%B9%8B%E7%B1%BB%E7%9A%84&#34;&gt;王国之类的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AD%A6%E7%A7%91&#34;&gt;学科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%8D%E5%B8%B8%E8%A7%81%E5%8A%A8%E7%89%A9%E5%8D%95%E8%AF%8D&#34;&gt;不常见动物单词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%81%9A%E9%A2%98%E7%A7%AF%E7%B4%AF%E8%AF%8D%E6%B1%87&#34;&gt;做题积累词汇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%87%A0%E4%B8%AA%E5%B8%A6tem%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E5%8D%95%E8%AF%8D&#34;&gt;几个带tem容易混淆的单词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%98%85%E8%AF%BB%E6%80%9D%E8%B7%AF&#34;&gt;阅读思路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8A%A8%E8%AF%8D%E7%9A%84%E6%84%8F%E6%80%9D%E4%B8%AD%E7%B1%BB%E4%BC%BC%E4%BD%BFxx%E8%A7%A3%E9%87%8A&#34;&gt;动词的意思中类似**(使)XX**解释&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h2 id=&#34;和作者态度相关的词&#34;&gt;和作者态度相关的词&lt;/h2&gt;
&lt;p&gt;indifferent:漠不关心的&lt;br&gt;
trivial:无关紧要的&lt;br&gt;
certain:确定的:&lt;strong&gt;当作者提及影响时,只说有某种影响(中性的,没说好的还是坏的),就选certain,但让最好还是结合别的选项看看,排除一下&lt;/strong&gt;&lt;br&gt;
positive:积极的&lt;br&gt;
negative:消极的,否定的&lt;br&gt;
permissive:放任&lt;br&gt;
scornful:蔑视&lt;br&gt;
critical:批评&lt;br&gt;
biased:片面的&lt;br&gt;
pessimistic:悲观的&lt;br&gt;
desperate:绝望的&lt;br&gt;
conceited:自负的&lt;br&gt;
destructive:毁灭性的(问影响的时候)&lt;br&gt;
oppose:反对&lt;/p&gt;
&lt;h2 id=&#34;职称称谓相关的单词&#34;&gt;职称,称谓相关的单词&lt;/h2&gt;
&lt;p&gt;dean:(大学)院长,主持牧师,(基督)教长&lt;br&gt;
mayor:市长&lt;br&gt;
juvenile:青少年,少年读物;a.青少年的,幼稚的&lt;br&gt;
landlady:女房东,女地主&lt;br&gt;
landlord:男房东,男地主&lt;br&gt;
tenant:承租人,房客,佃[diàn]户;vt.租赁,承租&lt;br&gt;
vegetarian:素食主义者&lt;br&gt;
magistrate:(地方)行政官,法官,治安官&lt;br&gt;
executive:主管,领导,管理层&lt;br&gt;
outside director:外部董事&lt;br&gt;
dealer:商人&lt;br&gt;
lad:小伙子,男孩&lt;br&gt;
skipper:机长&lt;br&gt;
cheerleader:啦啦队长,(强有力的)支持者&lt;br&gt;
celebrity:名人,知名人士,名流&lt;br&gt;
executive:主管&lt;br&gt;
secretary of state:(美国)国务卿,(英国)部长&lt;br&gt;
correspondent:记者,通讯员&lt;br&gt;
associate professor:&lt;strong&gt;副&lt;/strong&gt;教授&lt;br&gt;
toddler:幼童&lt;br&gt;
sage:哲人,先知&lt;br&gt;
sojourner:旅居者,逗留者,sojourn:逗留,旅居&lt;br&gt;
alien:外国人.外星人&lt;br&gt;
violinist:小提琴手&lt;br&gt;
entrepreneur:企业家,承包人&lt;br&gt;
aide:助手,助理&lt;br&gt;
rival:对手&lt;br&gt;
screener:筛选者:在求职有关的中引申为面试官的意思&lt;br&gt;
representative:n.代表;销售代表;销售代理;代销人;代表他人者adj.典型的;有代表性的;代表各类人(或事物)的;可作为典型(或示例)的&lt;br&gt;
opponent:反对者,对手,阻止者&lt;/p&gt;
&lt;h2 id=&#34;身体部位的&#34;&gt;身体部位的&lt;/h2&gt;
&lt;p&gt;jaw:颚,颌&lt;br&gt;
nail:指甲,爪,钉;vt.将...钉住&lt;br&gt;
waist:腰部&lt;br&gt;
belly:肚子,腹部&lt;br&gt;
elbow:肘,(衣服)肘部&lt;/p&gt;
&lt;h2 id=&#34;解雇&#34;&gt;解雇&lt;/h2&gt;
&lt;p&gt;sack:vt.解雇;n.袋,包,麻袋&lt;br&gt;
axe:vt.解雇,用斧头砍;n.斧子&lt;br&gt;
layoff:n.临时解雇,操作停止,活动停止期间,停业期&lt;br&gt;
dismissal:n.解雇;开除;撤职;不予考虑;不予理会;摒弃;驳回(诉讼);不予受理&lt;/p&gt;
&lt;h2 id=&#34;带有删除忽略略去排除意味的词&#34;&gt;带有删除,忽略,略去,排除意味的词&lt;/h2&gt;
&lt;p&gt;omit:vt.省略,删去,遗漏疏忽&lt;br&gt;
negligible:忽略的,微不足道的&lt;br&gt;
eliminate:vt.删去,淘汰,(排/删/消)除,消减(人员)&lt;/p&gt;
&lt;h2 id=&#34;带有包含意味的词&#34;&gt;带有包含意味的词&lt;/h2&gt;
&lt;p&gt;embrace:拥抱,包含,包围,环绕,采用,接受&lt;/p&gt;
&lt;h2 id=&#34;带有想象幻想意味的&#34;&gt;带有想象,幻想意味的&lt;/h2&gt;
&lt;p&gt;fancy:n.爱好,迷恋;vt想像幻想;a.花式的,奇特的&lt;br&gt;
fairy:幻想中,虚构,优雅的;n.仙女精灵&lt;br&gt;
illusion:幻想,错误观念,错觉,幻觉,假象&lt;/p&gt;
&lt;h2 id=&#34;跟钱有关&#34;&gt;跟钱有关&lt;/h2&gt;
&lt;p&gt;bankrupt:破产的,使破产,破产者&lt;br&gt;
fare:车费船费,伙食,乘客,vi.过活,进展,经营&lt;br&gt;
margin:利润,盈余&lt;br&gt;
profit margins:利润空间&lt;br&gt;
revenue:n.总收入&lt;br&gt;
proportion:比,比率,比例&lt;br&gt;
devaluation:(货币)贬值&lt;br&gt;
fiscal:财政上的&lt;br&gt;
redistribution:(尤指钱或土地的)重新分配&lt;br&gt;
corporate-tax rates:企业税率&lt;br&gt;
labour costs:劳动力成本&lt;br&gt;
sponsorship赞助者的地位,赞助行为,资助行为&lt;br&gt;
outlet:经销店,廉价经销店&lt;br&gt;
billboard:广告牌,告示牌&lt;br&gt;
product placement:产品置入,植入式广告&lt;br&gt;
commodity:商品&lt;br&gt;
impoverished:贫困的&lt;br&gt;
consumerism:消费主义&lt;br&gt;
monopoly:垄断者,垄断企业&lt;br&gt;
lean times:经济不景气的时期&lt;br&gt;
economic stagnation:经济停滞&lt;br&gt;
materialistic:实利主义的,物质主义的(含贬义)&lt;br&gt;
prudent:节俭的,明智谨慎的&lt;br&gt;
great recession:经济大衰退,经济萧条&lt;br&gt;
high joblessness:高失业率&lt;br&gt;
withdraw:除了撤退之外,还有从银行账户取钱提款的意思&lt;br&gt;
withdrawal:n. 也是取钱的意思,但是为从对方账户直接汇到我的里面&lt;br&gt;
issuer:开支票的人,出票人&lt;br&gt;
shed wokers:裁员&lt;br&gt;
mill:n.磨坊;面粉厂;工厂;制造厂;磨粉机;磨面机v.(用磨粉机)碾碎，磨成粉&lt;br&gt;
thrive:兴旺发达,繁荣,蓬勃发展&lt;br&gt;
estate:n.(通常指农村的)大片私有土地，庄园;住宅区;工业区;工厂区;个人财产;(尤指)遗产&lt;br&gt;
offshoring:离岸外包n.&lt;br&gt;
bump:(工资等)数量上的增加&lt;br&gt;
wage subsidy:工资补贴&lt;br&gt;
portable pension:便携式养老金&lt;br&gt;
well-off:adj.富裕的；顺利的，走运的；繁荣昌盛的&lt;br&gt;
loans:n.贷款;借款;借出;贷给;被借出v.借出，贷与(尤指钱);出借(贵重物品给博物馆等)&lt;/p&gt;
&lt;h2 id=&#34;跟政治政府有关&#34;&gt;跟政治,政府有关&lt;/h2&gt;
&lt;p&gt;elect:选举推选,选择,做出选择&lt;br&gt;
parade:n.游行,检阅;vi.参加游行,炫耀;vt.使参加游行,绕行&lt;br&gt;
rebellion:n.叛乱反抗,起义&lt;br&gt;
defy:(公然)违抗,反抗,蔑视&lt;br&gt;
bureau:局,处,科,办事处&lt;br&gt;
ministerial:内阁的,部长的,行政(上)的&lt;br&gt;
working class:工人阶级,劳动阶级&lt;br&gt;
military adventurism:军事冒险主义&lt;br&gt;
Nazi reign of murder:纳粹杀戮统治&lt;br&gt;
G.I Bill:美国退伍军人权利法案(考到好多次了)&lt;br&gt;
regulate:监管,注意和regular半毛钱关系都没得&lt;br&gt;
come into force:开始生效,实施&lt;br&gt;
levy:征收&lt;/p&gt;
&lt;h2 id=&#34;法律犯罪之类的&#34;&gt;法律犯罪之类的&lt;/h2&gt;
&lt;p&gt;bail:保释,离开,三柱门上的横木&lt;br&gt;
jury:陪审团&lt;br&gt;
judical:司法的,法庭的,公正的,审判的&lt;br&gt;
convict:vt.证明..有罪,判..有罪;n.囚犯&lt;br&gt;
conviction:n.深信,确信,定罪&lt;br&gt;
counsel:n.法律顾问,辩护人,劝告忠告;v.劝告,忠告&lt;br&gt;
defendant:被告人&lt;br&gt;
culprit:犯人,肇事者&lt;br&gt;
suit:诉讼,讼案&lt;br&gt;
federal appeals court:联邦上诉法院&lt;br&gt;
fine:罚款&lt;br&gt;
enact:v.颁布;制定法律&lt;br&gt;
legislation:n.立法法律&lt;br&gt;
imposition:n.实施施加&lt;/p&gt;
&lt;h2 id=&#34;探索追求之类的&#34;&gt;探索追求之类的&lt;/h2&gt;
&lt;p&gt;quest:探寻探求追求&lt;br&gt;
rake:耙子;v.耙,搜索,探索&lt;/p&gt;
&lt;h2 id=&#34;包裹相关&#34;&gt;包裹相关&lt;/h2&gt;
&lt;p&gt;packet:小包裹,小梱,一扎,邮船,班轮&lt;br&gt;
parcel:n.包裹,邮包,部分;vt.打包,捆扎,分配&lt;/p&gt;
&lt;h2 id=&#34;补丁碎片垃圾相关&#34;&gt;补丁,碎片,垃圾相关&lt;/h2&gt;
&lt;p&gt;rag:抹布,破布,碎布&lt;br&gt;
junk:废物&lt;/p&gt;
&lt;h2 id=&#34;和数量相关&#34;&gt;和数量相关&lt;/h2&gt;
&lt;p&gt;gang:n.一群一伙一帮&lt;br&gt;
batch:n.一批一组一群&lt;/p&gt;
&lt;h2 id=&#34;一些意思太多但是表示很牛批的那种意思&#34;&gt;一些意思太多,但是表示很牛批的那种意思&lt;/h2&gt;
&lt;p&gt;marve(l)lous:惊人的,奇迹般的,妙极的&lt;br&gt;
fabulous:极好的,极为巨大的,寓言中的,传说中的&lt;br&gt;
magnificent:华丽的,高尚的,雄伟的&lt;br&gt;
immense:&amp;lt;口&amp;gt;极好的,广大的,巨大的&lt;br&gt;
terrific:极好的,非常的,极度的&lt;br&gt;
mega:,巨大的,极佳的&lt;/p&gt;
&lt;h2 id=&#34;雄辩的有说服力的&#34;&gt;雄辩的,有说服力的&lt;/h2&gt;
&lt;p&gt;eloquent&lt;br&gt;
lame:辩解论据&lt;strong&gt;无&lt;/strong&gt;说服力的,跛的&lt;/p&gt;
&lt;h2 id=&#34;喘息喘气气喘吁吁地说&#34;&gt;喘息,喘气,气喘吁吁地说&lt;/h2&gt;
&lt;p&gt;gasp&lt;br&gt;
pant&lt;/p&gt;
&lt;h2 id=&#34;表明证明&#34;&gt;表明证明&lt;/h2&gt;
&lt;p&gt;manifest:表明证明显示,明白的,显然的&lt;br&gt;
testimony:证据,证词;表明,说明&lt;br&gt;
testify:v.作证,证明;(to)表明,说明&lt;br&gt;
warrant:正当理由,许可证,委任状;v.保证,担保&lt;/p&gt;
&lt;h2 id=&#34;承认&#34;&gt;承认&lt;/h2&gt;
&lt;p&gt;acknowledge&lt;br&gt;
admit&lt;/p&gt;
&lt;h2 id=&#34;相关性的有关联那种意思的一些单词&#34;&gt;相关性的,有关联那种意思的一些单词&lt;/h2&gt;
&lt;p&gt;correlate:相互关联的事物;v.(~ with/to)(使)互相关联&lt;br&gt;
coordinate:同等的,同等物,坐标(|neit|其余发音都是|nət|);vt.协作,协调&lt;br&gt;
identical:(~to/with)同一的,同样的&lt;/p&gt;
&lt;h2 id=&#34;开始着手做&#34;&gt;开始,着手做&lt;/h2&gt;
&lt;p&gt;embark:另:上船(车飞机等)&lt;br&gt;
wage:vt.进行,开展;n.工资&lt;/p&gt;
&lt;h2 id=&#34;恰当的合适的&#34;&gt;恰当的,合适的&lt;/h2&gt;
&lt;h2 id=&#34;足够的那种意思总是和恰当记混&#34;&gt;足够的那种意思(总是和恰当记混)&lt;/h2&gt;
&lt;p&gt;abundant:丰富的,大量的&lt;br&gt;
adequate:足够的,合乎需要的&lt;br&gt;
plentiful:大量的,充足的,众多的,丰富的&lt;/p&gt;
&lt;h2 id=&#34;抓住处理解决&#34;&gt;抓住,处理,解决&lt;/h2&gt;
&lt;p&gt;tackle&lt;br&gt;
adress oneself to :致力于,处理&lt;br&gt;
address:(着手)处理解决(问题),向...讲话,用..称呼(某人),~ sth to对...提出sth&lt;/p&gt;
&lt;h2 id=&#34;国会议会代表大会&#34;&gt;国会,议会,代表大会&lt;/h2&gt;
&lt;p&gt;congress&lt;br&gt;
parliament&lt;/p&gt;
&lt;h2 id=&#34;理事会委员会等&#34;&gt;理事会,委员会等&lt;/h2&gt;
&lt;p&gt;council&lt;br&gt;
board:除了板,登船车啥的,还有:(公司或其他机构的)董事会，委员会，理事会&lt;/p&gt;
&lt;h2 id=&#34;牧草地牧场&#34;&gt;牧草地,牧场&lt;/h2&gt;
&lt;p&gt;meadow&lt;br&gt;
pasture&lt;/p&gt;
&lt;h2 id=&#34;使疲劳&#34;&gt;(使)疲劳&lt;/h2&gt;
&lt;p&gt;fatigue:v/n(使)疲劳&lt;br&gt;
weary:疲倦的,令人厌烦的,v.使疲倦,使厌倦&lt;br&gt;
feeble:虚弱的,无力的&lt;/p&gt;
&lt;h2 id=&#34;妨碍阻碍&#34;&gt;妨碍,阻碍&lt;/h2&gt;
&lt;p&gt;hinder&lt;br&gt;
hamper&lt;br&gt;
handicap:另:(身体或智力)缺陷,不利条件&lt;/p&gt;
&lt;h2 id=&#34;扩大增大&#34;&gt;扩大,增大&lt;/h2&gt;
&lt;p&gt;magnify:扩大,增大,夸张,夸大,n.magnitude:大小数量巨大广大&lt;/p&gt;
&lt;h2 id=&#34;巨大的&#34;&gt;巨大的&lt;/h2&gt;
&lt;p&gt;enormous&lt;br&gt;
immense&lt;br&gt;
giant:巨大,巨大的&lt;/p&gt;
&lt;h2 id=&#34;古怪的&#34;&gt;古怪的&lt;/h2&gt;
&lt;p&gt;eccentric:另:怪癖的,异乎寻常的,n:古怪的人&lt;br&gt;
peculiar:古怪异常,特殊,特有的&lt;/p&gt;
&lt;h2 id=&#34;同意赞成答应&#34;&gt;同意赞成答应&lt;/h2&gt;
&lt;p&gt;consent:~ to&lt;br&gt;
consensus:(意见等)一致,一致同意,共识&lt;br&gt;
unanimous:全体一致的,一致同意的&lt;br&gt;
sanction:n/v.批准同意支持认可;n.处罚制裁&lt;/p&gt;
&lt;h2 id=&#34;显眼的明显的&#34;&gt;显眼的,明显的&lt;/h2&gt;
&lt;p&gt;conspicuous&lt;/p&gt;
&lt;h2 id=&#34;表示重要性的一类词&#34;&gt;表示重要性的一类词&lt;/h2&gt;
&lt;p&gt;salient:显著的,突出的,重要的&lt;/p&gt;
&lt;h2 id=&#34;合同契约条约公约&#34;&gt;合同,契约,条约,公约&lt;/h2&gt;
&lt;p&gt;packt&lt;br&gt;
contract:合同契约,v.订合同,(使)缩小&lt;/p&gt;
&lt;h2 id=&#34;策划图谋&#34;&gt;策划,图谋&lt;/h2&gt;
&lt;p&gt;hatch:另:v.孵化孵出,n.舱口,小门&lt;br&gt;
conspiracy:阴谋密谋共谋&lt;br&gt;
contemplate:盘算,计议,注视,周密考虑&lt;br&gt;
contrive:谋划策划,设计&lt;br&gt;
scenario:n.设想,(行动的)方案,预测,剧情梗概&lt;br&gt;
maneuvel:n.策略花招;n/v.机动,操作,操纵;&lt;br&gt;
tactic(s):策略战术&lt;br&gt;
scheme:计划,方案,阴谋,配置;v.计划,策划,阴谋&lt;/p&gt;
&lt;h2 id=&#34;几个表示普通正常的单词的区别&#34;&gt;几个表示普通正常的单词的区别&lt;/h2&gt;
&lt;p&gt;normal:正常的 反义,不正常,变态&lt;br&gt;
formal:正式的 比如正式的会议,正式的演讲稿（不是临时的,随便的）&lt;br&gt;
average:普通的 ,人均的 ,平均（水平,数）的&lt;br&gt;
common:普通的 ,共同的（强调普通性）&lt;br&gt;
ordinary 普通的&lt;br&gt;
average ,common,ordinary 都只普通的,平均水平的,不异于人的,后两者意思更接近&lt;br&gt;
plain:平平的,朴素的&lt;/p&gt;
&lt;h2 id=&#34;轻视蔑视瞧不起&#34;&gt;轻视蔑视瞧不起&lt;/h2&gt;
&lt;p&gt;contempt&lt;/p&gt;
&lt;h2 id=&#34;缺点不足&#34;&gt;缺点,不足&lt;/h2&gt;
&lt;p&gt;deficiency:n.缺乏不足,缺点缺陷&lt;br&gt;
defect:过失,缺点,不足&lt;/p&gt;
&lt;h2 id=&#34;推动促进&#34;&gt;推动促进&lt;/h2&gt;
&lt;p&gt;impetus:n.推动(力),促进&lt;br&gt;
impulse:n/v推动,冲动;n.刺激&lt;/p&gt;
&lt;h2 id=&#34;汇集聚集&#34;&gt;汇集聚集&lt;/h2&gt;
&lt;p&gt;gather:聚集,推测推断&lt;br&gt;
converge:另:会于一点&lt;br&gt;
rally:v.恢复重整振作;n.聚集,集会,大会,拉力赛&lt;br&gt;
cluster:聚集,集居&lt;br&gt;
agglomeration:集聚&lt;/p&gt;
&lt;h2 id=&#34;亲切诚xx之类的&#34;&gt;亲切,诚XX之类的&lt;/h2&gt;
&lt;p&gt;cordial:诚恳,亲切,热诚的&lt;br&gt;
zeal:热情,热心,热忱&lt;br&gt;
upright:诚实的,垂直的,正直的;ad.竖立着的&lt;br&gt;
benign:仁慈和蔼的;良性的(病)&lt;br&gt;
beloved:受爱戴的,敬爱的,爱人&lt;/p&gt;
&lt;h2 id=&#34;带有微弱朦胧晦涩这种含义的&#34;&gt;带有微弱,朦胧,晦涩这种含义的&lt;/h2&gt;
&lt;p&gt;faint:a.微弱,不明显,暗淡的,n/v.昏倒昏厥&lt;br&gt;
pale:苍白灰白的,浅的,暗淡的&lt;br&gt;
vague:不明确的,含糊的,暧昧的&lt;br&gt;
obscure:暗的,朦胧的,模糊的,晦涩的,不著名的,不重要的&lt;br&gt;
opaque:难理解,不透明,晦涩的&lt;br&gt;
latent:潜在的,不易察觉的,潜伏的&lt;/p&gt;
&lt;h2 id=&#34;尼玛总是忘掉的一些&#34;&gt;尼玛总是忘掉的一些&lt;/h2&gt;
&lt;p&gt;scatter:v.驱散,散开,散布,散播&lt;br&gt;
vapo(u)r:汽,(水)蒸汽&lt;br&gt;
rack:挂物架,搁物架,v:折磨使痛苦&lt;br&gt;
racket:吵闹,喧闹&lt;br&gt;
rage:愤怒,风靡一时的事物,时尚;vi.狂吹,汹涌,发怒&lt;br&gt;
undermine:暗中破坏,逐渐削弱,挖....墙脚&lt;br&gt;
uproar:骚动,喧嚣,鼎沸&lt;br&gt;
cordial:热诚,诚恳,亲切的&lt;br&gt;
malignant:恶性的,致命的,恶意的,恶毒的&lt;br&gt;
courtesy:n.恭谦有礼,有礼貌的举止/言辞&lt;br&gt;
eloquent:雄辩有说服力的,有口才的&amp;lt;--反--&amp;gt;lame:a.辩解无说服力的,另:跛的&lt;br&gt;
daunt:使胆怯,使气馁vt&lt;br&gt;
genuine:真正的,名副其实的&lt;br&gt;
hazard:n/v.危险,冒险,危害,拼命&lt;br&gt;
harness:v.治理,利用,n.马具,挽具&lt;br&gt;
rake:耙子,v.耙,搜索&lt;br&gt;
rally:v.重整,恢复,振作,n.聚集,集会,大会,接力赛&lt;br&gt;
harassment:骚扰,扰乱,烦恼,烦乱&lt;br&gt;
convention:大会,常规,惯例,习俗,公约&lt;br&gt;
patrol:v/n巡逻巡查,巡逻队&lt;br&gt;
scrap:碎片废料;v.废弃,报废&lt;br&gt;
wedge:楔形,楔;vt.楔牢,楔人,挤进&lt;br&gt;
scout:侦查员(机/船),童子军,v.探索,侦察&lt;br&gt;
coupon:证明持券人有某种权力的卡片,票证,赠券&lt;br&gt;
cripple:跛子,残疾人;v使跛,残疾&lt;/p&gt;
&lt;h2 id=&#34;交通工具&#34;&gt;交通工具&lt;/h2&gt;
&lt;p&gt;waggon:运货(马)车,敞篷车箱&lt;/p&gt;
&lt;h2 id=&#34;跟药品医学有关的词汇今年有可能考到&#34;&gt;跟药品.医学有关的词汇(今年有可能考到)&lt;/h2&gt;
&lt;p&gt;vaccine:疫苗,痘苗,疫苗的,痘苗的&lt;br&gt;
immune:免疫的,有免疫力的,有受影响的,豁免的&lt;br&gt;
tablet:药片,碑匾&lt;br&gt;
administer:**给予,施用(药物)**管理治理,实施&lt;br&gt;
administration:(药物等的施用),管理行政部门,(美国)政府&lt;br&gt;
moisturizer:润肤膏&lt;br&gt;
disinfecting:消毒的&lt;br&gt;
purifier:净化器&lt;br&gt;
cavity-preventing:口腔预防&lt;br&gt;
contagious:接触传染的&lt;br&gt;
therapy:n.治疗,(不需要药物或手术的)物理疗法&lt;br&gt;
germ:微生物&lt;br&gt;
genetic:遗传&lt;br&gt;
embryo:胚胎,胚&lt;br&gt;
odo(u)r:气味,臭味,名声&lt;br&gt;
scent:n.气味,香味,香水,线索,嗅觉;v.嗅,发觉&lt;br&gt;
malignant:恶性的,致命的,恶意的,恶毒的&lt;br&gt;
diabetes:糖尿病,多尿症&lt;br&gt;
paediatrics:儿科学,小儿科&lt;br&gt;
genome:基因组&lt;br&gt;
neuroticism:神经质,情绪不稳定性&lt;/p&gt;
&lt;h2 id=&#34;时间相关&#34;&gt;时间相关&lt;/h2&gt;
&lt;p&gt;dawn:黎明拂晓;v.破晓,开始出现&lt;br&gt;
elapse:vi(时间)溜走,(光阴)逝去&lt;br&gt;
the Renaissance:文艺复兴时期&lt;/p&gt;
&lt;h2 id=&#34;化工物理科技&#34;&gt;化工,物理,科技&lt;/h2&gt;
&lt;p&gt;neutron:中子&lt;br&gt;
particle:n.粒子,微粒,极小量,小品词,虚词&lt;br&gt;
zinc:锌&lt;br&gt;
laser:激光&lt;br&gt;
gear:齿轮,传动装置&lt;br&gt;
copper:铜,铜币,铜制器&lt;br&gt;
nickle:镍,镍币,五美分&lt;br&gt;
ignite:v.点燃,点火&lt;br&gt;
quench:v.熄灭扑灭,压制,抑制,止渴&lt;br&gt;
jet:(喷气)发动机,飞机,喷口;v.喷出,喷射&lt;br&gt;
generator:发电机,发生器&lt;br&gt;
radiant:发光的,辐射的,容光焕发的&lt;br&gt;
radioactive放射性的,放射引起的&lt;br&gt;
radiate:v.放射,辐射,散布,传播&lt;br&gt;
ultraviolet:n/a.紫外线(的)&lt;br&gt;
tangle:n.纠缠,缠结,混乱;v.(使)变乱/缠绕&lt;br&gt;
quartz:石英&lt;br&gt;
marble:云石,大理石,(pl.)弹子游戏&lt;br&gt;
pebble:卵石&lt;br&gt;
corrode:v.(受)腐蚀,侵蚀&lt;br&gt;
decay:v/n.腐朽,腐烂,衰退衰减&lt;br&gt;
composite:a.合成的,混合的,复合的;n.合成物,混合物,复合物&lt;br&gt;
upwash:上升气流&lt;br&gt;
wingtip:(鸟或飞机的)翼尖,翼梢&lt;br&gt;
emission:排放&lt;br&gt;
turbulence:湍流,不稳定的气流&lt;br&gt;
fuse:n.保险丝;熔断器;导火线;导火索;引信;信管;雷管v.(使)融合，熔接，结合;(使)熔化;(使保险丝熔断而)停止工作&lt;br&gt;
isolate:分离(物质,疾病等以作研究)&lt;br&gt;
molecule:分子&lt;br&gt;
atom:原子&lt;br&gt;
proton:质子&lt;/p&gt;
&lt;h2 id=&#34;几个f的易混淆的单词&#34;&gt;几个f的易混淆的单词&lt;/h2&gt;
&lt;p&gt;facile:容易的&lt;br&gt;
facilitate:使容易,促使&lt;br&gt;
facaulty:才能,院系&lt;br&gt;
facility:设施&lt;/p&gt;
&lt;h2 id=&#34;几个p开头的总混淆的单词&#34;&gt;几个P开头的总混淆的单词&lt;/h2&gt;
&lt;p&gt;prosperity:繁荣,兴旺,昌盛&lt;br&gt;
properly:正确地,适当地,得体地&lt;br&gt;
proportion:比,比例&lt;br&gt;
proposal:提议;建议;动议;求婚&lt;br&gt;
property:所有物;财产;财物;不动产;房地产;房屋及院落;庄园&lt;br&gt;
prespect:预测&lt;br&gt;
perception:n.知觉;感知;洞察力;悟性;看法;见解&lt;/p&gt;
&lt;h2 id=&#34;数学计算机相关词汇&#34;&gt;数学,计算机相关词汇&lt;/h2&gt;
&lt;p&gt;decimal:十进的,小数的,十进制的;n.小数&lt;br&gt;
finite:有限的,[数]有穷的,限定的&lt;/p&gt;
&lt;h2 id=&#34;王国之类的&#34;&gt;王国之类的&lt;/h2&gt;
&lt;p&gt;realm:王国,国土,领域范围&lt;br&gt;
territory:领土,版图,领域,范围&lt;br&gt;
imperial:帝国的,帝王的,(度量衡)英制的&lt;br&gt;
majesty:n.雄伟壮观;庄严;威严;(对国王或女王的尊称)陛下;王权&lt;br&gt;
emperor:皇帝&lt;br&gt;
empire:帝国&lt;br&gt;
crown:王冠,冕,君权,君王;v.为...加冕&lt;/p&gt;
&lt;h2 id=&#34;学科&#34;&gt;学科&lt;/h2&gt;
&lt;p&gt;genetics:遗传学&lt;br&gt;
mechanics:力学,机械学&lt;br&gt;
ecology:生态学&lt;br&gt;
aeronautics:航空学&lt;br&gt;
aesthetic:美学的,审美的&lt;br&gt;
geographic:adj.地理（学）（上）的；地区（性）的&lt;/p&gt;
&lt;h2 id=&#34;不常见动物单词&#34;&gt;不常见动物单词&lt;/h2&gt;
&lt;p&gt;hawk:鹰隼&lt;/p&gt;
&lt;h2 id=&#34;做题积累词汇&#34;&gt;做题积累词汇&lt;/h2&gt;
&lt;p&gt;tropical:热带的&lt;br&gt;
soap habbit:用肥皂洗手的习惯;&lt;strong&gt;类似的组合词学会结合上下文翻译&lt;/strong&gt;&lt;br&gt;
wipe:抹,擦&lt;br&gt;
counter:柜台&lt;br&gt;
cue:暗示,提示&lt;br&gt;
turn to:求助于&lt;br&gt;
subtle:微妙的&lt;br&gt;
invest ... doing sth:投入...做某事&lt;br&gt;
routine:惯例&lt;br&gt;
shrewd:精明的&lt;br&gt;
scrub:n.擦洗&lt;br&gt;
sip:小口地喝&lt;br&gt;
primarily:首先地&lt;br&gt;
ritual:仪式&lt;br&gt;
viable:可行的&lt;br&gt;
ruthless:无情残忍的&lt;br&gt;
controversies...erupted:辩论争论爆发&lt;br&gt;
exempt....from...使...:免除豁免&lt;br&gt;
peer:同龄,同等地位的人;v.仔细看,端详&lt;br&gt;
ideal:理想&lt;br&gt;
landmark:里程碑&lt;br&gt;
unconstitutional:不符合宪法的&lt;br&gt;
discrimination:歧视&lt;br&gt;
antidiscrimination:反歧视&lt;br&gt;
usher:引导,~ sth in:开创,开启&lt;br&gt;
supposedly:据说,据传&lt;br&gt;
intentional:有意的,故意的&lt;br&gt;
blue-ribbon:一流头等的&lt;br&gt;
trumpet:v.大声宣告,大肆宣扬,吹嘘&lt;br&gt;
respectively:ad.分别地&lt;br&gt;
lightweight:a.比通常重量轻的&lt;br&gt;
composite:a.合成的,混合的,复合的;n.合成物,混合物,复合物&lt;br&gt;
make a difference:有作用,有影响&lt;br&gt;
naturalistic:自然的&lt;br&gt;
propel:推进&lt;br&gt;
substantially:ad.实质上,大体上&lt;br&gt;
unsubstantiated:未经证实的&lt;br&gt;
inverted:倒转的&lt;br&gt;
proceed:v.继续前进&lt;br&gt;
process:进程&lt;br&gt;
procedure:程序&lt;br&gt;
favorable:有利的,赞许的,令人愉快的,讨人喜欢的&lt;br&gt;
cruise:(汽车飞机等)以平稳速度行驶&lt;br&gt;
portion:部分&lt;br&gt;
perception:察觉,感知,洞察力,知觉&lt;br&gt;
nautical:航海的&lt;br&gt;
intimate:亲近的&lt;br&gt;
regulation:规定&lt;br&gt;
aviation:航空&lt;br&gt;
wake:航空轨迹&lt;br&gt;
diminish:变小,减小&lt;br&gt;
investigate:调查&lt;br&gt;
under fire:收到批评和攻击&lt;br&gt;
compensation:报酬薪水&lt;br&gt;
bonus payout:奖金支出&lt;br&gt;
presumably:ad.据推测,大概,可能&lt;br&gt;
weather:v.平安度过(难关),挨过,经受住&lt;br&gt;
a firm&#39;s board:公司董事会&lt;br&gt;
make one&#39;s wealth and reputations:功成名就&lt;br&gt;
executive:主管&lt;br&gt;
proxy:代表权,委托书&lt;br&gt;
subsequently:ad.其后,随后,接着&lt;br&gt;
restate:v.重申,重新申报:restate earnings:重申盈利&lt;br&gt;
depart a board:从董事会离职&lt;br&gt;
federal class-action lawsuit:联邦集体诉讼&lt;br&gt;
jump off a sinking ship:跳离沉船&lt;br&gt;
blow:打击,意外的灾害,摧毁&lt;br&gt;
incentive:动机,鼓励,刺激&lt;br&gt;
a blow to the reputations:有损名誉&lt;br&gt;
recession:n.经济衰退/萎缩,不景气&lt;br&gt;
chronicle:记录(大事)&lt;br&gt;
chronic:慢性的,长期的,习惯性的&lt;br&gt;
devaluation:(货币)贬值&lt;br&gt;
subsidize:v.以津贴补助&lt;br&gt;
inhabit:v.居住,在....出现,填满&lt;br&gt;
routine:常规,通常情况&lt;br&gt;
shrug off:对...满不在乎,不屑一顾&lt;br&gt;
afloat:ad.漂流着的,漂浮不定:stay ~:维持运营&lt;br&gt;
overboard:ad.越过船边坠入水中:push sth/sb overboard:抛弃,甩掉某人/某事&lt;br&gt;
whirlwind:旋风,猛烈的势力&lt;br&gt;
distinctive:有特色的,与众不同的&lt;br&gt;
savagely:野蛮地,残忍地,粗野地&lt;br&gt;
line up:排队&lt;br&gt;
common sense:常识&lt;br&gt;
stylish:时髦的,流行的,入时的&lt;br&gt;
take up posts:就职&lt;br&gt;
stimulus:刺激物,刺激因素&lt;br&gt;
exert:发挥,运用,使受(影响)&lt;br&gt;
signature:签名,署名,识别标志,鲜明特征:~ phrase:口头禅&lt;br&gt;
derive from:由...起源,取自&lt;br&gt;
laminated:由薄片叠成的,分层的&lt;br&gt;
symbolize:象征,用符号表现&lt;br&gt;
sophisticated:复杂的,精致的&lt;br&gt;
take for granted:认为...理所当然&lt;br&gt;
mask the fact:掩盖事实&lt;br&gt;
modest:适度的,适中的,端庄的&lt;br&gt;
desirable:令人满意的,可取的&lt;br&gt;
inevitable:不可避免的,必然发生的&lt;br&gt;
forthright:直率的,明确的&lt;br&gt;
disintegration:瓦解,崩溃&lt;br&gt;
stuck:动不了,被卡主的,被难住的&lt;br&gt;
dominant:占优势的,统治的,支配的,首要的&lt;br&gt;
harmonisation:和谐,协调,相称&lt;br&gt;
quasi-automatic:半自动的,准自动的&lt;br&gt;
mega:巨大的,极佳的&lt;br&gt;
suspension:悬挂,暂停&lt;br&gt;
rigour:严苛,严酷&lt;br&gt;
backed by:依靠,在...支持下&lt;br&gt;
intervene:介于..之间,干预,介入:~ in介入,干预&lt;br&gt;
murmur:咕哝,发牢骚,私下抱怨&lt;br&gt;
curb:制止,束缚,限制,抑制&lt;br&gt;
remarkably:引人注目地,明显地&lt;br&gt;
liberal:开明的,自由的&lt;br&gt;
blunt:使迟钝&lt;br&gt;
write off:认定...不重要/无用/无可救药&lt;br&gt;
weigh in:参加,加入(争论等)&lt;br&gt;
spiral:盘旋上升(或下降),(物价等)不断急剧上升(或下降)&lt;br&gt;
excessive:过度的,极度的,非常的&lt;br&gt;
inconceivable:不能想象的,不可思议的,难以置信的&lt;br&gt;
in respect of:关于,涉及&lt;br&gt;
inducement:诱导,诱惑,诱因&lt;br&gt;
lure:吸引,引诱&lt;br&gt;
up front:预先,在前面&lt;br&gt;
takeaway:外卖食品,外卖店&lt;br&gt;
centerpiece:最重要的项目(或物品)&lt;br&gt;
set out:陈述,列述&lt;br&gt;
deploy:展开,施展,部署&lt;br&gt;
abbreviation:缩写词,缩写形式&lt;br&gt;
article:文章,(成套的)五篇,物件,条款&lt;br&gt;
mindless:无头脑的,盲目的,无谓的&lt;br&gt;
tear away from ...:依依不舍离开..&lt;br&gt;
foxhole:散兵坑&lt;br&gt;
stick it/sth out:坚持到底,忍受下去&lt;br&gt;
up against:必须面对某人/某事&lt;br&gt;
hand out:分发&lt;br&gt;
turn over:移交,交托&lt;br&gt;
pass down:遗传,继承&lt;br&gt;
cover:报道的意思一定记住啊,经常用&lt;br&gt;
portray:扮演某角色&lt;br&gt;
civilization:文明,文明社会:注意和urbanization(城市化)区别开,总记错&lt;br&gt;
colony:殖民地,群体&lt;br&gt;
parallel:除了有平行,还有&lt;strong&gt;相似的意思啊注意注意&lt;/strong&gt;&lt;br&gt;
counteracted:抵消,中和&lt;br&gt;
duplicate:重复,复制&lt;br&gt;
duplex:双工&lt;br&gt;
disguised:伪装的,掩饰的&lt;br&gt;
disturbed:坎坷的,不幸的&lt;br&gt;
disputed:争论的,有争议的&lt;br&gt;
distinguished:卓越的,杰出的&lt;br&gt;
from the outset:从开始时&lt;br&gt;
revise:修正,改变&lt;br&gt;
ritual:惯例,老规矩,例行公事&lt;br&gt;
mandate:命令指示&lt;br&gt;
interpretation:n.理解;解释;说明;演绎;演奏方式;表演方式&lt;br&gt;
pastel:(色彩)淡的,柔和的&lt;br&gt;
dominant:adj.首要的;占支配地位的;占优势的;显著的;(基因)显性的，优势的n.[生]显性性状;显性基因;优势物种;[乐]全阶第五音;主因;要素&lt;br&gt;
come into its own:显示出用处&lt;br&gt;
across-the-board:一刀切的&lt;br&gt;
thorny:棘手的&lt;br&gt;
look into:调查&lt;br&gt;
put on hold:搁置,暂缓&lt;br&gt;
dictate:控制,支配,口述,...听写的动词&lt;br&gt;
consel:建议&lt;br&gt;
stepping stone:垫脚石,踏板&lt;br&gt;
pervasive:普遍的,无处不在的&lt;br&gt;
intrinsically:ad.从本质上(讲)&lt;br&gt;
singular:如初的,非凡的&lt;br&gt;
fuse .. to ..:把..和..熔合在一起&lt;br&gt;
be obsessed with:痴迷于&lt;br&gt;
domestic:adj.本国的;国内的;家用的;家庭的;家务的;喜爱家庭生活的;享受家庭乐趣的;乐于操持家务的n.家佣;佣人;家庭纠纷;家庭矛盾&lt;br&gt;
violently:激烈地,强烈地&lt;br&gt;
agitated:紧张不安的,焦虑的&lt;br&gt;
preliminary:初步的,预备的&lt;br&gt;
federal judge:联邦法官&lt;br&gt;
shake...to its core:彻底震惊&lt;br&gt;
suppress:压制,镇压,制止&lt;br&gt;
make arguments against:提出反对...的理由&lt;br&gt;
innovation:创新&lt;br&gt;
violate:侵犯,干扰&lt;br&gt;
session:(一系列会议中的一次)会议&lt;br&gt;
landscape:景色,形势&lt;br&gt;
packed:挤满人的,非常拥挤的&lt;br&gt;
alike:adv.同样都(用于强调刚刚提及的两者)&lt;br&gt;
over turn:使倾覆,打翻&lt;br&gt;
national polls:国内民意调查&lt;br&gt;
social fabric:社会结构&lt;br&gt;
discern:识别,看清,领悟&lt;br&gt;
resentment:怨气,怨恨,不满&lt;br&gt;
shrink:(使)缩小/收缩&lt;br&gt;
reinforce:加强,强化....&lt;strong&gt;不要老是记成限制(restrain)啊&lt;/strong&gt;&lt;br&gt;
lengthy:长时间的,过长的&lt;br&gt;
mean-spirited:心胸狭隘的&lt;br&gt;
inclusive:包容的&lt;br&gt;
sentiment:观点感想意见&lt;br&gt;
far off:遥远&lt;br&gt;
reckless:鲁莽轻率不顾后果的&lt;br&gt;
exemplary:模范的&lt;br&gt;
lining:n.衬层;内衬;衬里;(身体器官内壁的)膜v.(用…)做衬里;(在某物的内部)形成一层;沿…形成行(或列、排)&lt;br&gt;
rambling:讲话或文章杂乱无章的&lt;br&gt;
champion:除了冠军,还有捍卫维护的意思&lt;br&gt;
cunning:n.狡猾狡诈&lt;br&gt;
ruthlessness:无情冷酷&lt;br&gt;
furnish:v.提供,供应&lt;br&gt;
resolute:坚决的,坚定的&lt;br&gt;
steadfast:忠诚的,坚贞不渝的&lt;br&gt;
integrity:n.诚实正直;完整;完好&lt;br&gt;
beacon:引路人,指路明灯&lt;br&gt;
bourgeois:过分追求名利的,注意物质享受的;市侩的,庸俗的&lt;br&gt;
epochal:具有时代意义的&lt;br&gt;
bombast:空洞华丽的(言论)&lt;br&gt;
hitherto:ad.迄今,至今&lt;br&gt;
nurture:v.培养培育&lt;br&gt;
unpick:v.拆去针脚,撬开,引申为分析研究&lt;br&gt;
multiplicity:多样性&lt;br&gt;
downstairs:底层(阶级)&lt;br&gt;
upstairs:上层(阶级)&lt;br&gt;
fruition:n.(计划、过程或活动的)完成，实现，取得成果:come to fruition:完成实现&lt;br&gt;
revolutionize:v.彻底改革,彻底变革&lt;br&gt;
steady:稳定的,持续的&lt;br&gt;
telecommunication:电磁通信,远距离通信&lt;br&gt;
receipt:收据收条&lt;br&gt;
unauthorized:未被授权的,未经认可的&lt;br&gt;
fraud:欺诈,欺骗&lt;br&gt;
chunk:厚块,大块&lt;br&gt;
trail:踪迹,痕迹&lt;br&gt;
stubbornly:顽固地,倔强地&lt;br&gt;
make the point:表明观点&lt;br&gt;
automate:自动化&lt;br&gt;
relate:除了关联之外还有讲述叙述的意思&lt;br&gt;
look to do sh:寻找机会做某事&lt;br&gt;
for good:永久地,永远地,一劳永逸地&lt;br&gt;
birds of passage:候鸟,漂泊的人&lt;br&gt;
affectionate:深情的,充满深情的&lt;br&gt;
rigid:严格的,僵硬的死板的&lt;br&gt;
brand:打烙印于,印商标于&lt;br&gt;
paralysis:n.麻痹,无力,停顿(活动工作能力)完全丧失,瘫痪&lt;br&gt;
look beyond:超越...看问题&lt;br&gt;
in the making:在酝酿中,在形成中&lt;br&gt;
kick out:踢出&lt;br&gt;
hail ..as...:将..誉为...&lt;br&gt;
mightily:很,非常ad&lt;br&gt;
straddle:跨立于,跨越&lt;br&gt;
jurisdiction:管辖范围&lt;br&gt;
commit oneself to sth/doing sth:承诺&lt;br&gt;
in motion:在运动中的&lt;br&gt;
prone:有..倾向的,易于倾向于&lt;br&gt;
snap:仓促的,匆忙的,注意与nap(小憩)的区别&lt;br&gt;
hard-wired:(计算机系统中)硬件控制的,硬连线的,固有的,天生的(innate):be hard-wired to do sth:天生会做某事&lt;br&gt;
mechanism:机制&lt;br&gt;
assess:评估(哎,千万别忘了啊)&lt;br&gt;
preferably:ad.较好,更适宜&lt;br&gt;
sociable:好交际的,合群的,友好的&lt;br&gt;
stimuli:n.刺激(stimulus的复数)&lt;br&gt;
exclusive:独有的,独占的,专有的:be exclusive to:专为...独享&lt;br&gt;
prime:v.使准备好:prime sb to do sth:使某人准备好应付某种情况&lt;br&gt;
interpersonal:人际关系的,&lt;br&gt;
reverse:颠倒,逆转&lt;br&gt;
ground:v.使接触地面.打基础&lt;br&gt;
retreat:僻静处,隐居处,休息寓所&lt;br&gt;
mute:减弱...的声音,使...柔和(可以引申为控制,抑制)&lt;br&gt;
contemplate:沉思,深思熟虑,冥思苦想&lt;br&gt;
revitalize:使得到复兴&lt;br&gt;
weave:使组合,使交织&lt;br&gt;
paraphrase:意译,改述&lt;br&gt;
by virtue of:由于,因为&lt;br&gt;
disperse:使分散&lt;br&gt;
intervene:干预&lt;br&gt;
alternative:n.(两者或以上)择一&lt;br&gt;
deploy:利用&lt;br&gt;
profile:n.面部的侧影;侧面轮廓;概述;简介;传略;印象;形象v.扼要介绍;概述;写简介&lt;br&gt;
high-profile:高调的,备受瞩目的&lt;br&gt;
convert:除了动词转换转变还有名词:皈依者,改变信念的人&lt;br&gt;
indulgence:n.放纵溺爱&lt;br&gt;
momentum:势头声势&lt;br&gt;
coalition:联合联盟&lt;br&gt;
shave off:减少,剃掉&lt;br&gt;
skate by:轻松通过&lt;br&gt;
testimonial:推荐信,证明书&lt;br&gt;
curricular:课程的,extracurricular:课外的&lt;br&gt;
level:还有动词使平等的意思&lt;br&gt;
level the playing field:创造公平的竞争环境&lt;br&gt;
unveil:公布,为...揭幕&lt;br&gt;
speculative:猜测性的,投机的&lt;br&gt;
rigor:严格&lt;br&gt;
resistence:阻力,抵抗力&lt;br&gt;
demonstrate:[ˈdemənstreɪt] v.证明;证实;论证;说明;表达;表露;表现;显露;示范;演示&lt;br&gt;
compelling:英 [kəmˈpelɪŋ] 美 [kəmˈpelɪŋ]adj.引人入胜的;扣人心弦的;非常强烈的;不可抗拒的;令人信服的v.强迫;迫使;使必须;引起(反应)&lt;br&gt;
the best bits of:最好的部分&lt;br&gt;
come into force:生效,开始实施&lt;br&gt;
flaw:缺点,瑕疵&lt;br&gt;
premise:n.前提,假定&lt;br&gt;
levy:n.征收&lt;br&gt;
fine:罚款&lt;br&gt;
regulate:监管.self-regulatory:自我监管的&lt;br&gt;
spray around:分散,喷洒&lt;br&gt;
leak:泄露渗漏&lt;br&gt;
harmonise:使和谐&lt;br&gt;
embroil::v使卷入,使混乱&lt;br&gt;
template:模板样板&lt;br&gt;
overarching:包罗万象的&lt;br&gt;
dominoes[&#39;dominouz]n.多米诺骨牌（PlL1）&lt;br&gt;
slap on the wrist 象征性惩罚（P1L1）&lt;br&gt;
show the door 开除，扫地出门（P1L2）&lt;br&gt;
insensitive[in&#39;senstiv]a.缺乏同情心的,不敏感的（P1L3）&lt;br&gt;
misconduct[imis&#39;kondakt]n.不端行为（PlL4）&lt;br&gt;
integrity[un&#39;tegrtu]n.正直；诚实（P2L1）&lt;br&gt;
pragmatic[preg&#39;maetik]a.实用主义的（P21L3）&lt;br&gt;
course of action做法，行动步骤（P2L3）&lt;br&gt;
overlook A for the sake of B:为B忽略A（P3L2）&lt;br&gt;
ethical lapse 道德败坏，道德堕落（P3L3）&lt;br&gt;
accountable[a&#39;kauntobl]a.有责任的，负责的（P315）&lt;br&gt;
fallout[folaut]n.（尤指预料不到的）影响，结果&lt;br&gt;
harshly[ha:fu]ad.严厉地；严酷的（P5L1）&lt;br&gt;
toxic[&#39;toksik]a.有毒的；中毒的（P5L2）&lt;br&gt;
one-off[iwan&#39;of]n.一次性事物（P6L2）&lt;br&gt;
paper over 隐瞒（有争议或使人不愉快之事）&lt;br&gt;
bigwig[&#39;brgwrg]n.有重大影响的人（P1L3）&lt;br&gt;
gung-ho[&#39;gag&#39;hou]a.非常急切的（P7L1）&lt;br&gt;
errant:犯错误的;行为不当的;出格的;对配偶不忠的&lt;br&gt;
accountable:负责的&lt;br&gt;
inclusive:adj.包含全部费用;包括所提到的费用在内;包括提到的所有的天数(或月、数目等)在内;包容广阔的;范围广泛的&lt;br&gt;
fallout:后果,余波&lt;br&gt;
wicked:adj.邪恶的;缺德的;淘气的;调皮的;恶作剧的;危险的;有害的;强大的n恶人;邪恶的人&lt;br&gt;
revolutionise[.revallufanalz]v.彻底改变，使彻底变革&lt;br&gt;
star-up[&#39;statAp]n.初创公司&lt;br&gt;
gig worker零工，临时工（P2L1）&lt;br&gt;
reimagine[ria&#39;maedsin]v.重新构想&lt;br&gt;
benefit[&#39;benift]n.福利，补贴&lt;br&gt;
weather[&#39;we0].经受住，平安度过&lt;br&gt;
ensuing[in&#39;sjug]a.随后的&lt;br&gt;
select[silekt]a.精选的，挑选出的&lt;br&gt;
emerging[I&#39;msxd31g]a.新兴的，新出现的&lt;br&gt;
compromise[&#39;kompromalz]v.妥协，让步&lt;br&gt;
step in介入，干预（P3L1）&lt;br&gt;
on one&#39;s own terms按照某人自己的意愿&lt;br&gt;
climate[&#39;klatmt]n.氛围，形势&lt;br&gt;
opening[&#39;oupanig]n.机遇，良机&lt;br&gt;
tailor:定做，根据需要制作&lt;br&gt;
aggregate[egrg]a.总计的，合计的&lt;br&gt;
intermittent[inta&#39;mutant]a.断断续续的，间歇的&lt;br&gt;
trigger:n.(枪的)扳机;(尤指引发不良反应或发展的)起因，诱因;触发器;引爆器v.发动;引起;触发;开动;起动&lt;br&gt;
dignity:n.庄重;庄严;尊严;尊贵;高贵;高尚;自豪;自尊;自重&lt;br&gt;
rational[&#39;refnol]a.理性的；合理的（P3L1）&lt;br&gt;
fosil[&#39;fosl]n.化石（P513）&lt;br&gt;
auction[&#39;o.kJn]n.竞卖，拍卖（P3L4）&lt;br&gt;
shake off摆脱（P6L5）&lt;br&gt;
scheme[skim]n.（造福他人的）计划，方案（P3L4）&lt;br&gt;
onshore[&#39;on/]n.陆上的，朝岸的（P4L3）&lt;br&gt;
muster[&#39;masta]v.鼓起（勇气），积聚（信心），争取支持&lt;br&gt;
curb[katb]v.控制，抑制，束缚&lt;br&gt;
ideological[iaidia&#39;lodglkl]a.思想上的，意识形态&lt;br&gt;
shuter[Uata]u.便停止运行，关闭；装百页窗&lt;br&gt;
press ahead推进，加紧进行&lt;br&gt;
fury[&#39;fjuori]n.狂怒，暴怒&lt;br&gt;
infrastructure[nfrstraktfar]n.基础设施，基础&lt;br&gt;
arbitrary::任意的,专断的&lt;br&gt;
opaque:不透明的&lt;/p&gt;
&lt;h2 id=&#34;几个带tem容易混淆的单词&#34;&gt;几个带tem容易混淆的单词&lt;/h2&gt;
&lt;p&gt;contempt:轻视蔑视&lt;br&gt;
contemplate:周密考虑,深思熟虑,冥思苦想&lt;br&gt;
tempt:诱惑,引诱,temptation&lt;br&gt;
template:模板样板&lt;/p&gt;
&lt;h2 id=&#34;阅读思路&#34;&gt;阅读思路&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;注意程度
&lt;ul&gt;
&lt;li&gt;类似的,不提倡,不支持,不建议**&amp;lt;--不等于--&amp;gt;**禁止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;选项错误的原因
&lt;ul&gt;
&lt;li&gt;偷换主语&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;给文章取标题的题目
&lt;ul&gt;
&lt;li&gt;考查概括主旨,体现文章探讨的主要对象&lt;/li&gt;
&lt;li&gt;干扰项长为文章中的细枝末节,不能涵盖全文内容&lt;/li&gt;
&lt;li&gt;仅在&lt;strong&gt;某一段&lt;/strong&gt;出现一次或多次的关键词不是,而分别在&lt;strong&gt;不同段&lt;/strong&gt;出现大于一次的关键词可能是的,末尾段一般作为总结,看看开头的句子是否有出现在别的段落的关键词&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;偷换概念
&lt;ul&gt;
&lt;li&gt;XX举措有利于sth变得怎么这么样-&amp;gt;有利于已经怎么怎么样的sth:
&lt;ul&gt;
&lt;li&gt;例题:张剑阅读模拟题T2中:有利于学校提升排名-&amp;gt;这有利于高排名的学校&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;It can be inferred from XXX_____:之类的一定是作者的观点,不要想当然的自己去推断
&lt;ul&gt;
&lt;li&gt;开头说某些人认为xxx怎样怎样,但作者要是有一丝提到不怎样怎样就不好,说明作者是反对之前这些人的观点的,选项可能还包含其他干扰项,多是论证开头这个怎样怎样的,要是选项涉及这个怎样怎样且和作者观点相同,多半是选这个(例如张剑模拟题T3/13)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;动词的意思中类似使xx解释&#34;&gt;动词的意思中类似**(使)XX**解释&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;原因就在这里,以air为例：&lt;br&gt;
air vt. 使通风;vi. 通风&lt;br&gt;
air 同时是vt和vi。当它是vt时，就要把括号中的使字译出。当它是vi是，就不用把使译出。为了方便，所以很多字典都把使用括号括起来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以correlate为例:(使)相互关联&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;及物&lt;br&gt;
The figures do not seem to correlate.&lt;br&gt;
这些数字似乎毫不相干。&lt;/li&gt;
&lt;li&gt;不及物&lt;br&gt;
A high-fat diet correlates with a greater risk of heart disease.&lt;br&gt;
高脂肪饮食与增加心脏病发作的风险密切相关。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;imply和implicate&lt;br&gt;
hint 是给个“bai提示”，比如老师du留作业的时候顺便给你个hint，或者有话不直zhi说但是拐弯给你个hint让你自dao己去领悟。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;imply带有推理的性质，比如两眼距离过大往往implies这个人是白痴，一个现象推理出另一个结论，用imply。&lt;/p&gt;
&lt;p&gt;implicate跟imply有点联系，都有推理的性质，但是这个词好象不推出什么好事情，比如被牵连进去就是implicate in...&lt;br&gt;
4. issue&lt;br&gt;
英 [ˈɪʃuː] 美 [ˈɪʃuː]&lt;br&gt;
n.&lt;br&gt;
重要议题;争论的问题;(有关某事的)问题，担忧;一期;期号&lt;br&gt;
v.&lt;br&gt;
宣布;公布;发出;(正式)发给，供给;(尤指通过正式文件)将…诉诸法律&lt;/p&gt;
">背单词时遇到到意思相近的词</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/bei-dan-ci-shi-yu-dao-dao-yi-si-xiang-jin-de-ci/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%92%8C%E4%BD%9C%E8%80%85%E6%80%81%E5%BA%A6%E7%9B%B8%E5%85%B3%E7%9A%84%E8%AF%8D&#34;&gt;和作者态度相关的词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%81%8C%E7%A7%B0%E7%A7%B0%E8%B0%93%E7%9B%B8%E5%85%B3%E7%9A%84%E5%8D%95%E8%AF%8D&#34;&gt;职称,称谓相关的单词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BA%AB%E4%BD%93%E9%83%A8%E4%BD%8D%E7%9A%84&#34;&gt;身体部位的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A7%A3%E9%9B%87&#34;&gt;解雇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B8%A6%E6%9C%89%E5%88%A0%E9%99%A4%E5%BF%BD%E7%95%A5%E7%95%A5%E5%8E%BB%E6%8E%92%E9%99%A4%E6%84%8F%E5%91%B3%E7%9A%84%E8%AF%8D&#34;&gt;带有删除,忽略,略去,排除意味的词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B8%A6%E6%9C%89%E5%8C%85%E5%90%AB%E6%84%8F%E5%91%B3%E7%9A%84%E8%AF%8D&#34;&gt;带有包含意味的词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B8%A6%E6%9C%89%E6%83%B3%E8%B1%A1%E5%B9%BB%E6%83%B3%E6%84%8F%E5%91%B3%E7%9A%84&#34;&gt;带有想象,幻想意味的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%9F%E9%92%B1%E6%9C%89%E5%85%B3&#34;&gt;跟钱有关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%9F%E6%94%BF%E6%B2%BB%E6%94%BF%E5%BA%9C%E6%9C%89%E5%85%B3&#34;&gt;跟政治,政府有关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B3%95%E5%BE%8B%E7%8A%AF%E7%BD%AA%E4%B9%8B%E7%B1%BB%E7%9A%84&#34;&gt;法律犯罪之类的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8E%A2%E7%B4%A2%E8%BF%BD%E6%B1%82%E4%B9%8B%E7%B1%BB%E7%9A%84&#34;&gt;探索追求之类的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8C%85%E8%A3%B9%E7%9B%B8%E5%85%B3&#34;&gt;包裹相关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A1%A5%E4%B8%81%E7%A2%8E%E7%89%87%E5%9E%83%E5%9C%BE%E7%9B%B8%E5%85%B3&#34;&gt;补丁,碎片,垃圾相关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%92%8C%E6%95%B0%E9%87%8F%E7%9B%B8%E5%85%B3&#34;&gt;和数量相关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%80%E4%BA%9B%E6%84%8F%E6%80%9D%E5%A4%AA%E5%A4%9A%E4%BD%86%E6%98%AF%E8%A1%A8%E7%A4%BA%E5%BE%88%E7%89%9B%E6%89%B9%E7%9A%84%E9%82%A3%E7%A7%8D%E6%84%8F%E6%80%9D&#34;&gt;一些意思太多,但是表示很牛批的那种意思&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%9B%84%E8%BE%A9%E7%9A%84%E6%9C%89%E8%AF%B4%E6%9C%8D%E5%8A%9B%E7%9A%84&#34;&gt;雄辩的,有说服力的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%96%98%E6%81%AF%E5%96%98%E6%B0%94%E6%B0%94%E5%96%98%E5%90%81%E5%90%81%E5%9C%B0%E8%AF%B4&#34;&gt;喘息,喘气,气喘吁吁地说&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A1%A8%E6%98%8E%E8%AF%81%E6%98%8E&#34;&gt;表明证明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%89%BF%E8%AE%A4&#34;&gt;承认&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%9B%B8%E5%85%B3%E6%80%A7%E7%9A%84%E6%9C%89%E5%85%B3%E8%81%94%E9%82%A3%E7%A7%8D%E6%84%8F%E6%80%9D%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8D%95%E8%AF%8D&#34;&gt;相关性的,有关联那种意思的一些单词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%BC%80%E5%A7%8B%E7%9D%80%E6%89%8B%E5%81%9A&#34;&gt;开始,着手做&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%81%B0%E5%BD%93%E7%9A%84%E5%90%88%E9%80%82%E7%9A%84&#34;&gt;恰当的,合适的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B6%B3%E5%A4%9F%E7%9A%84%E9%82%A3%E7%A7%8D%E6%84%8F%E6%80%9D%E6%80%BB%E6%98%AF%E5%92%8C%E6%81%B0%E5%BD%93%E8%AE%B0%E6%B7%B7&#34;&gt;足够的那种意思(总是和恰当记混)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8A%93%E4%BD%8F%E5%A4%84%E7%90%86%E8%A7%A3%E5%86%B3&#34;&gt;抓住,处理,解决&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%9B%BD%E4%BC%9A%E8%AE%AE%E4%BC%9A%E4%BB%A3%E8%A1%A8%E5%A4%A7%E4%BC%9A&#34;&gt;国会,议会,代表大会&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%90%86%E4%BA%8B%E4%BC%9A%E5%A7%94%E5%91%98%E4%BC%9A%E7%AD%89&#34;&gt;理事会,委员会等&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%89%A7%E8%8D%89%E5%9C%B0%E7%89%A7%E5%9C%BA&#34;&gt;牧草地,牧场&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BD%BF%E7%96%B2%E5%8A%B3&#34;&gt;(使)疲劳&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%A6%A8%E7%A2%8D%E9%98%BB%E7%A2%8D&#34;&gt;妨碍,阻碍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%89%A9%E5%A4%A7%E5%A2%9E%E5%A4%A7&#34;&gt;扩大,增大&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B7%A8%E5%A4%A7%E7%9A%84&#34;&gt;巨大的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8F%A4%E6%80%AA%E7%9A%84&#34;&gt;古怪的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%90%8C%E6%84%8F%E8%B5%9E%E6%88%90%E7%AD%94%E5%BA%94&#34;&gt;同意赞成答应&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%98%BE%E7%9C%BC%E7%9A%84%E6%98%8E%E6%98%BE%E7%9A%84&#34;&gt;显眼的,明显的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%A1%A8%E7%A4%BA%E9%87%8D%E8%A6%81%E6%80%A7%E7%9A%84%E4%B8%80%E7%B1%BB%E8%AF%8D&#34;&gt;表示重要性的一类词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%90%88%E5%90%8C%E5%A5%91%E7%BA%A6%E6%9D%A1%E7%BA%A6%E5%85%AC%E7%BA%A6&#34;&gt;合同,契约,条约,公约&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%AD%96%E5%88%92%E5%9B%BE%E8%B0%8B&#34;&gt;策划,图谋&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%87%A0%E4%B8%AA%E8%A1%A8%E7%A4%BA%E6%99%AE%E9%80%9A%E6%AD%A3%E5%B8%B8%E7%9A%84%E5%8D%95%E8%AF%8D%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;几个表示普通正常的单词的区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%BD%BB%E8%A7%86%E8%94%91%E8%A7%86%E7%9E%A7%E4%B8%8D%E8%B5%B7&#34;&gt;轻视蔑视瞧不起&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%BC%BA%E7%82%B9%E4%B8%8D%E8%B6%B3&#34;&gt;缺点,不足&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%8E%A8%E5%8A%A8%E4%BF%83%E8%BF%9B&#34;&gt;推动促进&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%B1%87%E9%9B%86%E8%81%9A%E9%9B%86&#34;&gt;汇集聚集&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%B2%E5%88%87%E8%AF%9Axx%E4%B9%8B%E7%B1%BB%E7%9A%84&#34;&gt;亲切,诚XX之类的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B8%A6%E6%9C%89%E5%BE%AE%E5%BC%B1%E6%9C%A6%E8%83%A7%E6%99%A6%E6%B6%A9%E8%BF%99%E7%A7%8D%E5%90%AB%E4%B9%89%E7%9A%84&#34;&gt;带有微弱,朦胧,晦涩这种含义的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%B0%BC%E7%8E%9B%E6%80%BB%E6%98%AF%E5%BF%98%E6%8E%89%E7%9A%84%E4%B8%80%E4%BA%9B&#34;&gt;尼玛总是忘掉的一些&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%BA%A4%E9%80%9A%E5%B7%A5%E5%85%B7&#34;&gt;交通工具&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E8%B7%9F%E8%8D%AF%E5%93%81%E5%8C%BB%E5%AD%A6%E6%9C%89%E5%85%B3%E7%9A%84%E8%AF%8D%E6%B1%87%E4%BB%8A%E5%B9%B4%E6%9C%89%E5%8F%AF%E8%83%BD%E8%80%83%E5%88%B0&#34;&gt;跟药品.医学有关的词汇(今年有可能考到)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3&#34;&gt;时间相关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8C%96%E5%B7%A5%E7%89%A9%E7%90%86%E7%A7%91%E6%8A%80&#34;&gt;化工,物理,科技&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%87%A0%E4%B8%AAf%E7%9A%84%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E5%8D%95%E8%AF%8D&#34;&gt;几个f的易混淆的单词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%87%A0%E4%B8%AAp%E5%BC%80%E5%A4%B4%E7%9A%84%E6%80%BB%E6%B7%B7%E6%B7%86%E7%9A%84%E5%8D%95%E8%AF%8D&#34;&gt;几个P开头的总混淆的单词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E6%95%B0%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9B%B8%E5%85%B3%E8%AF%8D%E6%B1%87&#34;&gt;数学,计算机相关词汇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E7%8E%8B%E5%9B%BD%E4%B9%8B%E7%B1%BB%E7%9A%84&#34;&gt;王国之类的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%AD%A6%E7%A7%91&#34;&gt;学科&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E4%B8%8D%E5%B8%B8%E8%A7%81%E5%8A%A8%E7%89%A9%E5%8D%95%E8%AF%8D&#34;&gt;不常见动物单词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%81%9A%E9%A2%98%E7%A7%AF%E7%B4%AF%E8%AF%8D%E6%B1%87&#34;&gt;做题积累词汇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%87%A0%E4%B8%AA%E5%B8%A6tem%E5%AE%B9%E6%98%93%E6%B7%B7%E6%B7%86%E7%9A%84%E5%8D%95%E8%AF%8D&#34;&gt;几个带tem容易混淆的单词&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E9%98%85%E8%AF%BB%E6%80%9D%E8%B7%AF&#34;&gt;阅读思路&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#%E5%8A%A8%E8%AF%8D%E7%9A%84%E6%84%8F%E6%80%9D%E4%B8%AD%E7%B1%BB%E4%BC%BC%E4%BD%BFxx%E8%A7%A3%E9%87%8A&#34;&gt;动词的意思中类似**(使)XX**解释&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/p&gt;
&lt;h2 id=&#34;和作者态度相关的词&#34;&gt;和作者态度相关的词&lt;/h2&gt;
&lt;p&gt;indifferent:漠不关心的&lt;br&gt;
trivial:无关紧要的&lt;br&gt;
certain:确定的:&lt;strong&gt;当作者提及影响时,只说有某种影响(中性的,没说好的还是坏的),就选certain,但让最好还是结合别的选项看看,排除一下&lt;/strong&gt;&lt;br&gt;
positive:积极的&lt;br&gt;
negative:消极的,否定的&lt;br&gt;
permissive:放任&lt;br&gt;
scornful:蔑视&lt;br&gt;
critical:批评&lt;br&gt;
biased:片面的&lt;br&gt;
pessimistic:悲观的&lt;br&gt;
desperate:绝望的&lt;br&gt;
conceited:自负的&lt;br&gt;
destructive:毁灭性的(问影响的时候)&lt;br&gt;
oppose:反对&lt;/p&gt;
&lt;h2 id=&#34;职称称谓相关的单词&#34;&gt;职称,称谓相关的单词&lt;/h2&gt;
&lt;p&gt;dean:(大学)院长,主持牧师,(基督)教长&lt;br&gt;
mayor:市长&lt;br&gt;
juvenile:青少年,少年读物;a.青少年的,幼稚的&lt;br&gt;
landlady:女房东,女地主&lt;br&gt;
landlord:男房东,男地主&lt;br&gt;
tenant:承租人,房客,佃[diàn]户;vt.租赁,承租&lt;br&gt;
vegetarian:素食主义者&lt;br&gt;
magistrate:(地方)行政官,法官,治安官&lt;br&gt;
executive:主管,领导,管理层&lt;br&gt;
outside director:外部董事&lt;br&gt;
dealer:商人&lt;br&gt;
lad:小伙子,男孩&lt;br&gt;
skipper:机长&lt;br&gt;
cheerleader:啦啦队长,(强有力的)支持者&lt;br&gt;
celebrity:名人,知名人士,名流&lt;br&gt;
executive:主管&lt;br&gt;
secretary of state:(美国)国务卿,(英国)部长&lt;br&gt;
correspondent:记者,通讯员&lt;br&gt;
associate professor:&lt;strong&gt;副&lt;/strong&gt;教授&lt;br&gt;
toddler:幼童&lt;br&gt;
sage:哲人,先知&lt;br&gt;
sojourner:旅居者,逗留者,sojourn:逗留,旅居&lt;br&gt;
alien:外国人.外星人&lt;br&gt;
violinist:小提琴手&lt;br&gt;
entrepreneur:企业家,承包人&lt;br&gt;
aide:助手,助理&lt;br&gt;
rival:对手&lt;br&gt;
screener:筛选者:在求职有关的中引申为面试官的意思&lt;br&gt;
representative:n.代表;销售代表;销售代理;代销人;代表他人者adj.典型的;有代表性的;代表各类人(或事物)的;可作为典型(或示例)的&lt;br&gt;
opponent:反对者,对手,阻止者&lt;/p&gt;
&lt;h2 id=&#34;身体部位的&#34;&gt;身体部位的&lt;/h2&gt;
&lt;p&gt;jaw:颚,颌&lt;br&gt;
nail:指甲,爪,钉;vt.将...钉住&lt;br&gt;
waist:腰部&lt;br&gt;
belly:肚子,腹部&lt;br&gt;
elbow:肘,(衣服)肘部&lt;/p&gt;
&lt;h2 id=&#34;解雇&#34;&gt;解雇&lt;/h2&gt;
&lt;p&gt;sack:vt.解雇;n.袋,包,麻袋&lt;br&gt;
axe:vt.解雇,用斧头砍;n.斧子&lt;br&gt;
layoff:n.临时解雇,操作停止,活动停止期间,停业期&lt;br&gt;
dismissal:n.解雇;开除;撤职;不予考虑;不予理会;摒弃;驳回(诉讼);不予受理&lt;/p&gt;
&lt;h2 id=&#34;带有删除忽略略去排除意味的词&#34;&gt;带有删除,忽略,略去,排除意味的词&lt;/h2&gt;
&lt;p&gt;omit:vt.省略,删去,遗漏疏忽&lt;br&gt;
negligible:忽略的,微不足道的&lt;br&gt;
eliminate:vt.删去,淘汰,(排/删/消)除,消减(人员)&lt;/p&gt;
&lt;h2 id=&#34;带有包含意味的词&#34;&gt;带有包含意味的词&lt;/h2&gt;
&lt;p&gt;embrace:拥抱,包含,包围,环绕,采用,接受&lt;/p&gt;
&lt;h2 id=&#34;带有想象幻想意味的&#34;&gt;带有想象,幻想意味的&lt;/h2&gt;
&lt;p&gt;fancy:n.爱好,迷恋;vt想像幻想;a.花式的,奇特的&lt;br&gt;
fairy:幻想中,虚构,优雅的;n.仙女精灵&lt;br&gt;
illusion:幻想,错误观念,错觉,幻觉,假象&lt;/p&gt;
&lt;h2 id=&#34;跟钱有关&#34;&gt;跟钱有关&lt;/h2&gt;
&lt;p&gt;bankrupt:破产的,使破产,破产者&lt;br&gt;
fare:车费船费,伙食,乘客,vi.过活,进展,经营&lt;br&gt;
margin:利润,盈余&lt;br&gt;
profit margins:利润空间&lt;br&gt;
revenue:n.总收入&lt;br&gt;
proportion:比,比率,比例&lt;br&gt;
devaluation:(货币)贬值&lt;br&gt;
fiscal:财政上的&lt;br&gt;
redistribution:(尤指钱或土地的)重新分配&lt;br&gt;
corporate-tax rates:企业税率&lt;br&gt;
labour costs:劳动力成本&lt;br&gt;
sponsorship赞助者的地位,赞助行为,资助行为&lt;br&gt;
outlet:经销店,廉价经销店&lt;br&gt;
billboard:广告牌,告示牌&lt;br&gt;
product placement:产品置入,植入式广告&lt;br&gt;
commodity:商品&lt;br&gt;
impoverished:贫困的&lt;br&gt;
consumerism:消费主义&lt;br&gt;
monopoly:垄断者,垄断企业&lt;br&gt;
lean times:经济不景气的时期&lt;br&gt;
economic stagnation:经济停滞&lt;br&gt;
materialistic:实利主义的,物质主义的(含贬义)&lt;br&gt;
prudent:节俭的,明智谨慎的&lt;br&gt;
great recession:经济大衰退,经济萧条&lt;br&gt;
high joblessness:高失业率&lt;br&gt;
withdraw:除了撤退之外,还有从银行账户取钱提款的意思&lt;br&gt;
withdrawal:n. 也是取钱的意思,但是为从对方账户直接汇到我的里面&lt;br&gt;
issuer:开支票的人,出票人&lt;br&gt;
shed wokers:裁员&lt;br&gt;
mill:n.磨坊;面粉厂;工厂;制造厂;磨粉机;磨面机v.(用磨粉机)碾碎，磨成粉&lt;br&gt;
thrive:兴旺发达,繁荣,蓬勃发展&lt;br&gt;
estate:n.(通常指农村的)大片私有土地，庄园;住宅区;工业区;工厂区;个人财产;(尤指)遗产&lt;br&gt;
offshoring:离岸外包n.&lt;br&gt;
bump:(工资等)数量上的增加&lt;br&gt;
wage subsidy:工资补贴&lt;br&gt;
portable pension:便携式养老金&lt;br&gt;
well-off:adj.富裕的；顺利的，走运的；繁荣昌盛的&lt;br&gt;
loans:n.贷款;借款;借出;贷给;被借出v.借出，贷与(尤指钱);出借(贵重物品给博物馆等)&lt;/p&gt;
&lt;h2 id=&#34;跟政治政府有关&#34;&gt;跟政治,政府有关&lt;/h2&gt;
&lt;p&gt;elect:选举推选,选择,做出选择&lt;br&gt;
parade:n.游行,检阅;vi.参加游行,炫耀;vt.使参加游行,绕行&lt;br&gt;
rebellion:n.叛乱反抗,起义&lt;br&gt;
defy:(公然)违抗,反抗,蔑视&lt;br&gt;
bureau:局,处,科,办事处&lt;br&gt;
ministerial:内阁的,部长的,行政(上)的&lt;br&gt;
working class:工人阶级,劳动阶级&lt;br&gt;
military adventurism:军事冒险主义&lt;br&gt;
Nazi reign of murder:纳粹杀戮统治&lt;br&gt;
G.I Bill:美国退伍军人权利法案(考到好多次了)&lt;br&gt;
regulate:监管,注意和regular半毛钱关系都没得&lt;br&gt;
come into force:开始生效,实施&lt;br&gt;
levy:征收&lt;/p&gt;
&lt;h2 id=&#34;法律犯罪之类的&#34;&gt;法律犯罪之类的&lt;/h2&gt;
&lt;p&gt;bail:保释,离开,三柱门上的横木&lt;br&gt;
jury:陪审团&lt;br&gt;
judical:司法的,法庭的,公正的,审判的&lt;br&gt;
convict:vt.证明..有罪,判..有罪;n.囚犯&lt;br&gt;
conviction:n.深信,确信,定罪&lt;br&gt;
counsel:n.法律顾问,辩护人,劝告忠告;v.劝告,忠告&lt;br&gt;
defendant:被告人&lt;br&gt;
culprit:犯人,肇事者&lt;br&gt;
suit:诉讼,讼案&lt;br&gt;
federal appeals court:联邦上诉法院&lt;br&gt;
fine:罚款&lt;br&gt;
enact:v.颁布;制定法律&lt;br&gt;
legislation:n.立法法律&lt;br&gt;
imposition:n.实施施加&lt;/p&gt;
&lt;h2 id=&#34;探索追求之类的&#34;&gt;探索追求之类的&lt;/h2&gt;
&lt;p&gt;quest:探寻探求追求&lt;br&gt;
rake:耙子;v.耙,搜索,探索&lt;/p&gt;
&lt;h2 id=&#34;包裹相关&#34;&gt;包裹相关&lt;/h2&gt;
&lt;p&gt;packet:小包裹,小梱,一扎,邮船,班轮&lt;br&gt;
parcel:n.包裹,邮包,部分;vt.打包,捆扎,分配&lt;/p&gt;
&lt;h2 id=&#34;补丁碎片垃圾相关&#34;&gt;补丁,碎片,垃圾相关&lt;/h2&gt;
&lt;p&gt;rag:抹布,破布,碎布&lt;br&gt;
junk:废物&lt;/p&gt;
&lt;h2 id=&#34;和数量相关&#34;&gt;和数量相关&lt;/h2&gt;
&lt;p&gt;gang:n.一群一伙一帮&lt;br&gt;
batch:n.一批一组一群&lt;/p&gt;
&lt;h2 id=&#34;一些意思太多但是表示很牛批的那种意思&#34;&gt;一些意思太多,但是表示很牛批的那种意思&lt;/h2&gt;
&lt;p&gt;marve(l)lous:惊人的,奇迹般的,妙极的&lt;br&gt;
fabulous:极好的,极为巨大的,寓言中的,传说中的&lt;br&gt;
magnificent:华丽的,高尚的,雄伟的&lt;br&gt;
immense:&amp;lt;口&amp;gt;极好的,广大的,巨大的&lt;br&gt;
terrific:极好的,非常的,极度的&lt;br&gt;
mega:,巨大的,极佳的&lt;/p&gt;
&lt;h2 id=&#34;雄辩的有说服力的&#34;&gt;雄辩的,有说服力的&lt;/h2&gt;
&lt;p&gt;eloquent&lt;br&gt;
lame:辩解论据&lt;strong&gt;无&lt;/strong&gt;说服力的,跛的&lt;/p&gt;
&lt;h2 id=&#34;喘息喘气气喘吁吁地说&#34;&gt;喘息,喘气,气喘吁吁地说&lt;/h2&gt;
&lt;p&gt;gasp&lt;br&gt;
pant&lt;/p&gt;
&lt;h2 id=&#34;表明证明&#34;&gt;表明证明&lt;/h2&gt;
&lt;p&gt;manifest:表明证明显示,明白的,显然的&lt;br&gt;
testimony:证据,证词;表明,说明&lt;br&gt;
testify:v.作证,证明;(to)表明,说明&lt;br&gt;
warrant:正当理由,许可证,委任状;v.保证,担保&lt;/p&gt;
&lt;h2 id=&#34;承认&#34;&gt;承认&lt;/h2&gt;
&lt;p&gt;acknowledge&lt;br&gt;
admit&lt;/p&gt;
&lt;h2 id=&#34;相关性的有关联那种意思的一些单词&#34;&gt;相关性的,有关联那种意思的一些单词&lt;/h2&gt;
&lt;p&gt;correlate:相互关联的事物;v.(~ with/to)(使)互相关联&lt;br&gt;
coordinate:同等的,同等物,坐标(|neit|其余发音都是|nət|);vt.协作,协调&lt;br&gt;
identical:(~to/with)同一的,同样的&lt;/p&gt;
&lt;h2 id=&#34;开始着手做&#34;&gt;开始,着手做&lt;/h2&gt;
&lt;p&gt;embark:另:上船(车飞机等)&lt;br&gt;
wage:vt.进行,开展;n.工资&lt;/p&gt;
&lt;h2 id=&#34;恰当的合适的&#34;&gt;恰当的,合适的&lt;/h2&gt;
&lt;h2 id=&#34;足够的那种意思总是和恰当记混&#34;&gt;足够的那种意思(总是和恰当记混)&lt;/h2&gt;
&lt;p&gt;abundant:丰富的,大量的&lt;br&gt;
adequate:足够的,合乎需要的&lt;br&gt;
plentiful:大量的,充足的,众多的,丰富的&lt;/p&gt;
&lt;h2 id=&#34;抓住处理解决&#34;&gt;抓住,处理,解决&lt;/h2&gt;
&lt;p&gt;tackle&lt;br&gt;
adress oneself to :致力于,处理&lt;br&gt;
address:(着手)处理解决(问题),向...讲话,用..称呼(某人),~ sth to对...提出sth&lt;/p&gt;
&lt;h2 id=&#34;国会议会代表大会&#34;&gt;国会,议会,代表大会&lt;/h2&gt;
&lt;p&gt;congress&lt;br&gt;
parliament&lt;/p&gt;
&lt;h2 id=&#34;理事会委员会等&#34;&gt;理事会,委员会等&lt;/h2&gt;
&lt;p&gt;council&lt;br&gt;
board:除了板,登船车啥的,还有:(公司或其他机构的)董事会，委员会，理事会&lt;/p&gt;
&lt;h2 id=&#34;牧草地牧场&#34;&gt;牧草地,牧场&lt;/h2&gt;
&lt;p&gt;meadow&lt;br&gt;
pasture&lt;/p&gt;
&lt;h2 id=&#34;使疲劳&#34;&gt;(使)疲劳&lt;/h2&gt;
&lt;p&gt;fatigue:v/n(使)疲劳&lt;br&gt;
weary:疲倦的,令人厌烦的,v.使疲倦,使厌倦&lt;br&gt;
feeble:虚弱的,无力的&lt;/p&gt;
&lt;h2 id=&#34;妨碍阻碍&#34;&gt;妨碍,阻碍&lt;/h2&gt;
&lt;p&gt;hinder&lt;br&gt;
hamper&lt;br&gt;
handicap:另:(身体或智力)缺陷,不利条件&lt;/p&gt;
&lt;h2 id=&#34;扩大增大&#34;&gt;扩大,增大&lt;/h2&gt;
&lt;p&gt;magnify:扩大,增大,夸张,夸大,n.magnitude:大小数量巨大广大&lt;/p&gt;
&lt;h2 id=&#34;巨大的&#34;&gt;巨大的&lt;/h2&gt;
&lt;p&gt;enormous&lt;br&gt;
immense&lt;br&gt;
giant:巨大,巨大的&lt;/p&gt;
&lt;h2 id=&#34;古怪的&#34;&gt;古怪的&lt;/h2&gt;
&lt;p&gt;eccentric:另:怪癖的,异乎寻常的,n:古怪的人&lt;br&gt;
peculiar:古怪异常,特殊,特有的&lt;/p&gt;
&lt;h2 id=&#34;同意赞成答应&#34;&gt;同意赞成答应&lt;/h2&gt;
&lt;p&gt;consent:~ to&lt;br&gt;
consensus:(意见等)一致,一致同意,共识&lt;br&gt;
unanimous:全体一致的,一致同意的&lt;br&gt;
sanction:n/v.批准同意支持认可;n.处罚制裁&lt;/p&gt;
&lt;h2 id=&#34;显眼的明显的&#34;&gt;显眼的,明显的&lt;/h2&gt;
&lt;p&gt;conspicuous&lt;/p&gt;
&lt;h2 id=&#34;表示重要性的一类词&#34;&gt;表示重要性的一类词&lt;/h2&gt;
&lt;p&gt;salient:显著的,突出的,重要的&lt;/p&gt;
&lt;h2 id=&#34;合同契约条约公约&#34;&gt;合同,契约,条约,公约&lt;/h2&gt;
&lt;p&gt;packt&lt;br&gt;
contract:合同契约,v.订合同,(使)缩小&lt;/p&gt;
&lt;h2 id=&#34;策划图谋&#34;&gt;策划,图谋&lt;/h2&gt;
&lt;p&gt;hatch:另:v.孵化孵出,n.舱口,小门&lt;br&gt;
conspiracy:阴谋密谋共谋&lt;br&gt;
contemplate:盘算,计议,注视,周密考虑&lt;br&gt;
contrive:谋划策划,设计&lt;br&gt;
scenario:n.设想,(行动的)方案,预测,剧情梗概&lt;br&gt;
maneuvel:n.策略花招;n/v.机动,操作,操纵;&lt;br&gt;
tactic(s):策略战术&lt;br&gt;
scheme:计划,方案,阴谋,配置;v.计划,策划,阴谋&lt;/p&gt;
&lt;h2 id=&#34;几个表示普通正常的单词的区别&#34;&gt;几个表示普通正常的单词的区别&lt;/h2&gt;
&lt;p&gt;normal:正常的 反义,不正常,变态&lt;br&gt;
formal:正式的 比如正式的会议,正式的演讲稿（不是临时的,随便的）&lt;br&gt;
average:普通的 ,人均的 ,平均（水平,数）的&lt;br&gt;
common:普通的 ,共同的（强调普通性）&lt;br&gt;
ordinary 普通的&lt;br&gt;
average ,common,ordinary 都只普通的,平均水平的,不异于人的,后两者意思更接近&lt;br&gt;
plain:平平的,朴素的&lt;/p&gt;
&lt;h2 id=&#34;轻视蔑视瞧不起&#34;&gt;轻视蔑视瞧不起&lt;/h2&gt;
&lt;p&gt;contempt&lt;/p&gt;
&lt;h2 id=&#34;缺点不足&#34;&gt;缺点,不足&lt;/h2&gt;
&lt;p&gt;deficiency:n.缺乏不足,缺点缺陷&lt;br&gt;
defect:过失,缺点,不足&lt;/p&gt;
&lt;h2 id=&#34;推动促进&#34;&gt;推动促进&lt;/h2&gt;
&lt;p&gt;impetus:n.推动(力),促进&lt;br&gt;
impulse:n/v推动,冲动;n.刺激&lt;/p&gt;
&lt;h2 id=&#34;汇集聚集&#34;&gt;汇集聚集&lt;/h2&gt;
&lt;p&gt;gather:聚集,推测推断&lt;br&gt;
converge:另:会于一点&lt;br&gt;
rally:v.恢复重整振作;n.聚集,集会,大会,拉力赛&lt;br&gt;
cluster:聚集,集居&lt;br&gt;
agglomeration:集聚&lt;/p&gt;
&lt;h2 id=&#34;亲切诚xx之类的&#34;&gt;亲切,诚XX之类的&lt;/h2&gt;
&lt;p&gt;cordial:诚恳,亲切,热诚的&lt;br&gt;
zeal:热情,热心,热忱&lt;br&gt;
upright:诚实的,垂直的,正直的;ad.竖立着的&lt;br&gt;
benign:仁慈和蔼的;良性的(病)&lt;br&gt;
beloved:受爱戴的,敬爱的,爱人&lt;/p&gt;
&lt;h2 id=&#34;带有微弱朦胧晦涩这种含义的&#34;&gt;带有微弱,朦胧,晦涩这种含义的&lt;/h2&gt;
&lt;p&gt;faint:a.微弱,不明显,暗淡的,n/v.昏倒昏厥&lt;br&gt;
pale:苍白灰白的,浅的,暗淡的&lt;br&gt;
vague:不明确的,含糊的,暧昧的&lt;br&gt;
obscure:暗的,朦胧的,模糊的,晦涩的,不著名的,不重要的&lt;br&gt;
opaque:难理解,不透明,晦涩的&lt;br&gt;
latent:潜在的,不易察觉的,潜伏的&lt;/p&gt;
&lt;h2 id=&#34;尼玛总是忘掉的一些&#34;&gt;尼玛总是忘掉的一些&lt;/h2&gt;
&lt;p&gt;scatter:v.驱散,散开,散布,散播&lt;br&gt;
vapo(u)r:汽,(水)蒸汽&lt;br&gt;
rack:挂物架,搁物架,v:折磨使痛苦&lt;br&gt;
racket:吵闹,喧闹&lt;br&gt;
rage:愤怒,风靡一时的事物,时尚;vi.狂吹,汹涌,发怒&lt;br&gt;
undermine:暗中破坏,逐渐削弱,挖....墙脚&lt;br&gt;
uproar:骚动,喧嚣,鼎沸&lt;br&gt;
cordial:热诚,诚恳,亲切的&lt;br&gt;
malignant:恶性的,致命的,恶意的,恶毒的&lt;br&gt;
courtesy:n.恭谦有礼,有礼貌的举止/言辞&lt;br&gt;
eloquent:雄辩有说服力的,有口才的&amp;lt;--反--&amp;gt;lame:a.辩解无说服力的,另:跛的&lt;br&gt;
daunt:使胆怯,使气馁vt&lt;br&gt;
genuine:真正的,名副其实的&lt;br&gt;
hazard:n/v.危险,冒险,危害,拼命&lt;br&gt;
harness:v.治理,利用,n.马具,挽具&lt;br&gt;
rake:耙子,v.耙,搜索&lt;br&gt;
rally:v.重整,恢复,振作,n.聚集,集会,大会,接力赛&lt;br&gt;
harassment:骚扰,扰乱,烦恼,烦乱&lt;br&gt;
convention:大会,常规,惯例,习俗,公约&lt;br&gt;
patrol:v/n巡逻巡查,巡逻队&lt;br&gt;
scrap:碎片废料;v.废弃,报废&lt;br&gt;
wedge:楔形,楔;vt.楔牢,楔人,挤进&lt;br&gt;
scout:侦查员(机/船),童子军,v.探索,侦察&lt;br&gt;
coupon:证明持券人有某种权力的卡片,票证,赠券&lt;br&gt;
cripple:跛子,残疾人;v使跛,残疾&lt;/p&gt;
&lt;h2 id=&#34;交通工具&#34;&gt;交通工具&lt;/h2&gt;
&lt;p&gt;waggon:运货(马)车,敞篷车箱&lt;/p&gt;
&lt;h2 id=&#34;跟药品医学有关的词汇今年有可能考到&#34;&gt;跟药品.医学有关的词汇(今年有可能考到)&lt;/h2&gt;
&lt;p&gt;vaccine:疫苗,痘苗,疫苗的,痘苗的&lt;br&gt;
immune:免疫的,有免疫力的,有受影响的,豁免的&lt;br&gt;
tablet:药片,碑匾&lt;br&gt;
administer:**给予,施用(药物)**管理治理,实施&lt;br&gt;
administration:(药物等的施用),管理行政部门,(美国)政府&lt;br&gt;
moisturizer:润肤膏&lt;br&gt;
disinfecting:消毒的&lt;br&gt;
purifier:净化器&lt;br&gt;
cavity-preventing:口腔预防&lt;br&gt;
contagious:接触传染的&lt;br&gt;
therapy:n.治疗,(不需要药物或手术的)物理疗法&lt;br&gt;
germ:微生物&lt;br&gt;
genetic:遗传&lt;br&gt;
embryo:胚胎,胚&lt;br&gt;
odo(u)r:气味,臭味,名声&lt;br&gt;
scent:n.气味,香味,香水,线索,嗅觉;v.嗅,发觉&lt;br&gt;
malignant:恶性的,致命的,恶意的,恶毒的&lt;br&gt;
diabetes:糖尿病,多尿症&lt;br&gt;
paediatrics:儿科学,小儿科&lt;br&gt;
genome:基因组&lt;br&gt;
neuroticism:神经质,情绪不稳定性&lt;/p&gt;
&lt;h2 id=&#34;时间相关&#34;&gt;时间相关&lt;/h2&gt;
&lt;p&gt;dawn:黎明拂晓;v.破晓,开始出现&lt;br&gt;
elapse:vi(时间)溜走,(光阴)逝去&lt;br&gt;
the Renaissance:文艺复兴时期&lt;/p&gt;
&lt;h2 id=&#34;化工物理科技&#34;&gt;化工,物理,科技&lt;/h2&gt;
&lt;p&gt;neutron:中子&lt;br&gt;
particle:n.粒子,微粒,极小量,小品词,虚词&lt;br&gt;
zinc:锌&lt;br&gt;
laser:激光&lt;br&gt;
gear:齿轮,传动装置&lt;br&gt;
copper:铜,铜币,铜制器&lt;br&gt;
nickle:镍,镍币,五美分&lt;br&gt;
ignite:v.点燃,点火&lt;br&gt;
quench:v.熄灭扑灭,压制,抑制,止渴&lt;br&gt;
jet:(喷气)发动机,飞机,喷口;v.喷出,喷射&lt;br&gt;
generator:发电机,发生器&lt;br&gt;
radiant:发光的,辐射的,容光焕发的&lt;br&gt;
radioactive放射性的,放射引起的&lt;br&gt;
radiate:v.放射,辐射,散布,传播&lt;br&gt;
ultraviolet:n/a.紫外线(的)&lt;br&gt;
tangle:n.纠缠,缠结,混乱;v.(使)变乱/缠绕&lt;br&gt;
quartz:石英&lt;br&gt;
marble:云石,大理石,(pl.)弹子游戏&lt;br&gt;
pebble:卵石&lt;br&gt;
corrode:v.(受)腐蚀,侵蚀&lt;br&gt;
decay:v/n.腐朽,腐烂,衰退衰减&lt;br&gt;
composite:a.合成的,混合的,复合的;n.合成物,混合物,复合物&lt;br&gt;
upwash:上升气流&lt;br&gt;
wingtip:(鸟或飞机的)翼尖,翼梢&lt;br&gt;
emission:排放&lt;br&gt;
turbulence:湍流,不稳定的气流&lt;br&gt;
fuse:n.保险丝;熔断器;导火线;导火索;引信;信管;雷管v.(使)融合，熔接，结合;(使)熔化;(使保险丝熔断而)停止工作&lt;br&gt;
isolate:分离(物质,疾病等以作研究)&lt;br&gt;
molecule:分子&lt;br&gt;
atom:原子&lt;br&gt;
proton:质子&lt;/p&gt;
&lt;h2 id=&#34;几个f的易混淆的单词&#34;&gt;几个f的易混淆的单词&lt;/h2&gt;
&lt;p&gt;facile:容易的&lt;br&gt;
facilitate:使容易,促使&lt;br&gt;
facaulty:才能,院系&lt;br&gt;
facility:设施&lt;/p&gt;
&lt;h2 id=&#34;几个p开头的总混淆的单词&#34;&gt;几个P开头的总混淆的单词&lt;/h2&gt;
&lt;p&gt;prosperity:繁荣,兴旺,昌盛&lt;br&gt;
properly:正确地,适当地,得体地&lt;br&gt;
proportion:比,比例&lt;br&gt;
proposal:提议;建议;动议;求婚&lt;br&gt;
property:所有物;财产;财物;不动产;房地产;房屋及院落;庄园&lt;br&gt;
prespect:预测&lt;br&gt;
perception:n.知觉;感知;洞察力;悟性;看法;见解&lt;/p&gt;
&lt;h2 id=&#34;数学计算机相关词汇&#34;&gt;数学,计算机相关词汇&lt;/h2&gt;
&lt;p&gt;decimal:十进的,小数的,十进制的;n.小数&lt;br&gt;
finite:有限的,[数]有穷的,限定的&lt;/p&gt;
&lt;h2 id=&#34;王国之类的&#34;&gt;王国之类的&lt;/h2&gt;
&lt;p&gt;realm:王国,国土,领域范围&lt;br&gt;
territory:领土,版图,领域,范围&lt;br&gt;
imperial:帝国的,帝王的,(度量衡)英制的&lt;br&gt;
majesty:n.雄伟壮观;庄严;威严;(对国王或女王的尊称)陛下;王权&lt;br&gt;
emperor:皇帝&lt;br&gt;
empire:帝国&lt;br&gt;
crown:王冠,冕,君权,君王;v.为...加冕&lt;/p&gt;
&lt;h2 id=&#34;学科&#34;&gt;学科&lt;/h2&gt;
&lt;p&gt;genetics:遗传学&lt;br&gt;
mechanics:力学,机械学&lt;br&gt;
ecology:生态学&lt;br&gt;
aeronautics:航空学&lt;br&gt;
aesthetic:美学的,审美的&lt;br&gt;
geographic:adj.地理（学）（上）的；地区（性）的&lt;/p&gt;
&lt;h2 id=&#34;不常见动物单词&#34;&gt;不常见动物单词&lt;/h2&gt;
&lt;p&gt;hawk:鹰隼&lt;/p&gt;
&lt;h2 id=&#34;做题积累词汇&#34;&gt;做题积累词汇&lt;/h2&gt;
&lt;p&gt;tropical:热带的&lt;br&gt;
soap habbit:用肥皂洗手的习惯;&lt;strong&gt;类似的组合词学会结合上下文翻译&lt;/strong&gt;&lt;br&gt;
wipe:抹,擦&lt;br&gt;
counter:柜台&lt;br&gt;
cue:暗示,提示&lt;br&gt;
turn to:求助于&lt;br&gt;
subtle:微妙的&lt;br&gt;
invest ... doing sth:投入...做某事&lt;br&gt;
routine:惯例&lt;br&gt;
shrewd:精明的&lt;br&gt;
scrub:n.擦洗&lt;br&gt;
sip:小口地喝&lt;br&gt;
primarily:首先地&lt;br&gt;
ritual:仪式&lt;br&gt;
viable:可行的&lt;br&gt;
ruthless:无情残忍的&lt;br&gt;
controversies...erupted:辩论争论爆发&lt;br&gt;
exempt....from...使...:免除豁免&lt;br&gt;
peer:同龄,同等地位的人;v.仔细看,端详&lt;br&gt;
ideal:理想&lt;br&gt;
landmark:里程碑&lt;br&gt;
unconstitutional:不符合宪法的&lt;br&gt;
discrimination:歧视&lt;br&gt;
antidiscrimination:反歧视&lt;br&gt;
usher:引导,~ sth in:开创,开启&lt;br&gt;
supposedly:据说,据传&lt;br&gt;
intentional:有意的,故意的&lt;br&gt;
blue-ribbon:一流头等的&lt;br&gt;
trumpet:v.大声宣告,大肆宣扬,吹嘘&lt;br&gt;
respectively:ad.分别地&lt;br&gt;
lightweight:a.比通常重量轻的&lt;br&gt;
composite:a.合成的,混合的,复合的;n.合成物,混合物,复合物&lt;br&gt;
make a difference:有作用,有影响&lt;br&gt;
naturalistic:自然的&lt;br&gt;
propel:推进&lt;br&gt;
substantially:ad.实质上,大体上&lt;br&gt;
unsubstantiated:未经证实的&lt;br&gt;
inverted:倒转的&lt;br&gt;
proceed:v.继续前进&lt;br&gt;
process:进程&lt;br&gt;
procedure:程序&lt;br&gt;
favorable:有利的,赞许的,令人愉快的,讨人喜欢的&lt;br&gt;
cruise:(汽车飞机等)以平稳速度行驶&lt;br&gt;
portion:部分&lt;br&gt;
perception:察觉,感知,洞察力,知觉&lt;br&gt;
nautical:航海的&lt;br&gt;
intimate:亲近的&lt;br&gt;
regulation:规定&lt;br&gt;
aviation:航空&lt;br&gt;
wake:航空轨迹&lt;br&gt;
diminish:变小,减小&lt;br&gt;
investigate:调查&lt;br&gt;
under fire:收到批评和攻击&lt;br&gt;
compensation:报酬薪水&lt;br&gt;
bonus payout:奖金支出&lt;br&gt;
presumably:ad.据推测,大概,可能&lt;br&gt;
weather:v.平安度过(难关),挨过,经受住&lt;br&gt;
a firm&#39;s board:公司董事会&lt;br&gt;
make one&#39;s wealth and reputations:功成名就&lt;br&gt;
executive:主管&lt;br&gt;
proxy:代表权,委托书&lt;br&gt;
subsequently:ad.其后,随后,接着&lt;br&gt;
restate:v.重申,重新申报:restate earnings:重申盈利&lt;br&gt;
depart a board:从董事会离职&lt;br&gt;
federal class-action lawsuit:联邦集体诉讼&lt;br&gt;
jump off a sinking ship:跳离沉船&lt;br&gt;
blow:打击,意外的灾害,摧毁&lt;br&gt;
incentive:动机,鼓励,刺激&lt;br&gt;
a blow to the reputations:有损名誉&lt;br&gt;
recession:n.经济衰退/萎缩,不景气&lt;br&gt;
chronicle:记录(大事)&lt;br&gt;
chronic:慢性的,长期的,习惯性的&lt;br&gt;
devaluation:(货币)贬值&lt;br&gt;
subsidize:v.以津贴补助&lt;br&gt;
inhabit:v.居住,在....出现,填满&lt;br&gt;
routine:常规,通常情况&lt;br&gt;
shrug off:对...满不在乎,不屑一顾&lt;br&gt;
afloat:ad.漂流着的,漂浮不定:stay ~:维持运营&lt;br&gt;
overboard:ad.越过船边坠入水中:push sth/sb overboard:抛弃,甩掉某人/某事&lt;br&gt;
whirlwind:旋风,猛烈的势力&lt;br&gt;
distinctive:有特色的,与众不同的&lt;br&gt;
savagely:野蛮地,残忍地,粗野地&lt;br&gt;
line up:排队&lt;br&gt;
common sense:常识&lt;br&gt;
stylish:时髦的,流行的,入时的&lt;br&gt;
take up posts:就职&lt;br&gt;
stimulus:刺激物,刺激因素&lt;br&gt;
exert:发挥,运用,使受(影响)&lt;br&gt;
signature:签名,署名,识别标志,鲜明特征:~ phrase:口头禅&lt;br&gt;
derive from:由...起源,取自&lt;br&gt;
laminated:由薄片叠成的,分层的&lt;br&gt;
symbolize:象征,用符号表现&lt;br&gt;
sophisticated:复杂的,精致的&lt;br&gt;
take for granted:认为...理所当然&lt;br&gt;
mask the fact:掩盖事实&lt;br&gt;
modest:适度的,适中的,端庄的&lt;br&gt;
desirable:令人满意的,可取的&lt;br&gt;
inevitable:不可避免的,必然发生的&lt;br&gt;
forthright:直率的,明确的&lt;br&gt;
disintegration:瓦解,崩溃&lt;br&gt;
stuck:动不了,被卡主的,被难住的&lt;br&gt;
dominant:占优势的,统治的,支配的,首要的&lt;br&gt;
harmonisation:和谐,协调,相称&lt;br&gt;
quasi-automatic:半自动的,准自动的&lt;br&gt;
mega:巨大的,极佳的&lt;br&gt;
suspension:悬挂,暂停&lt;br&gt;
rigour:严苛,严酷&lt;br&gt;
backed by:依靠,在...支持下&lt;br&gt;
intervene:介于..之间,干预,介入:~ in介入,干预&lt;br&gt;
murmur:咕哝,发牢骚,私下抱怨&lt;br&gt;
curb:制止,束缚,限制,抑制&lt;br&gt;
remarkably:引人注目地,明显地&lt;br&gt;
liberal:开明的,自由的&lt;br&gt;
blunt:使迟钝&lt;br&gt;
write off:认定...不重要/无用/无可救药&lt;br&gt;
weigh in:参加,加入(争论等)&lt;br&gt;
spiral:盘旋上升(或下降),(物价等)不断急剧上升(或下降)&lt;br&gt;
excessive:过度的,极度的,非常的&lt;br&gt;
inconceivable:不能想象的,不可思议的,难以置信的&lt;br&gt;
in respect of:关于,涉及&lt;br&gt;
inducement:诱导,诱惑,诱因&lt;br&gt;
lure:吸引,引诱&lt;br&gt;
up front:预先,在前面&lt;br&gt;
takeaway:外卖食品,外卖店&lt;br&gt;
centerpiece:最重要的项目(或物品)&lt;br&gt;
set out:陈述,列述&lt;br&gt;
deploy:展开,施展,部署&lt;br&gt;
abbreviation:缩写词,缩写形式&lt;br&gt;
article:文章,(成套的)五篇,物件,条款&lt;br&gt;
mindless:无头脑的,盲目的,无谓的&lt;br&gt;
tear away from ...:依依不舍离开..&lt;br&gt;
foxhole:散兵坑&lt;br&gt;
stick it/sth out:坚持到底,忍受下去&lt;br&gt;
up against:必须面对某人/某事&lt;br&gt;
hand out:分发&lt;br&gt;
turn over:移交,交托&lt;br&gt;
pass down:遗传,继承&lt;br&gt;
cover:报道的意思一定记住啊,经常用&lt;br&gt;
portray:扮演某角色&lt;br&gt;
civilization:文明,文明社会:注意和urbanization(城市化)区别开,总记错&lt;br&gt;
colony:殖民地,群体&lt;br&gt;
parallel:除了有平行,还有&lt;strong&gt;相似的意思啊注意注意&lt;/strong&gt;&lt;br&gt;
counteracted:抵消,中和&lt;br&gt;
duplicate:重复,复制&lt;br&gt;
duplex:双工&lt;br&gt;
disguised:伪装的,掩饰的&lt;br&gt;
disturbed:坎坷的,不幸的&lt;br&gt;
disputed:争论的,有争议的&lt;br&gt;
distinguished:卓越的,杰出的&lt;br&gt;
from the outset:从开始时&lt;br&gt;
revise:修正,改变&lt;br&gt;
ritual:惯例,老规矩,例行公事&lt;br&gt;
mandate:命令指示&lt;br&gt;
interpretation:n.理解;解释;说明;演绎;演奏方式;表演方式&lt;br&gt;
pastel:(色彩)淡的,柔和的&lt;br&gt;
dominant:adj.首要的;占支配地位的;占优势的;显著的;(基因)显性的，优势的n.[生]显性性状;显性基因;优势物种;[乐]全阶第五音;主因;要素&lt;br&gt;
come into its own:显示出用处&lt;br&gt;
across-the-board:一刀切的&lt;br&gt;
thorny:棘手的&lt;br&gt;
look into:调查&lt;br&gt;
put on hold:搁置,暂缓&lt;br&gt;
dictate:控制,支配,口述,...听写的动词&lt;br&gt;
consel:建议&lt;br&gt;
stepping stone:垫脚石,踏板&lt;br&gt;
pervasive:普遍的,无处不在的&lt;br&gt;
intrinsically:ad.从本质上(讲)&lt;br&gt;
singular:如初的,非凡的&lt;br&gt;
fuse .. to ..:把..和..熔合在一起&lt;br&gt;
be obsessed with:痴迷于&lt;br&gt;
domestic:adj.本国的;国内的;家用的;家庭的;家务的;喜爱家庭生活的;享受家庭乐趣的;乐于操持家务的n.家佣;佣人;家庭纠纷;家庭矛盾&lt;br&gt;
violently:激烈地,强烈地&lt;br&gt;
agitated:紧张不安的,焦虑的&lt;br&gt;
preliminary:初步的,预备的&lt;br&gt;
federal judge:联邦法官&lt;br&gt;
shake...to its core:彻底震惊&lt;br&gt;
suppress:压制,镇压,制止&lt;br&gt;
make arguments against:提出反对...的理由&lt;br&gt;
innovation:创新&lt;br&gt;
violate:侵犯,干扰&lt;br&gt;
session:(一系列会议中的一次)会议&lt;br&gt;
landscape:景色,形势&lt;br&gt;
packed:挤满人的,非常拥挤的&lt;br&gt;
alike:adv.同样都(用于强调刚刚提及的两者)&lt;br&gt;
over turn:使倾覆,打翻&lt;br&gt;
national polls:国内民意调查&lt;br&gt;
social fabric:社会结构&lt;br&gt;
discern:识别,看清,领悟&lt;br&gt;
resentment:怨气,怨恨,不满&lt;br&gt;
shrink:(使)缩小/收缩&lt;br&gt;
reinforce:加强,强化....&lt;strong&gt;不要老是记成限制(restrain)啊&lt;/strong&gt;&lt;br&gt;
lengthy:长时间的,过长的&lt;br&gt;
mean-spirited:心胸狭隘的&lt;br&gt;
inclusive:包容的&lt;br&gt;
sentiment:观点感想意见&lt;br&gt;
far off:遥远&lt;br&gt;
reckless:鲁莽轻率不顾后果的&lt;br&gt;
exemplary:模范的&lt;br&gt;
lining:n.衬层;内衬;衬里;(身体器官内壁的)膜v.(用…)做衬里;(在某物的内部)形成一层;沿…形成行(或列、排)&lt;br&gt;
rambling:讲话或文章杂乱无章的&lt;br&gt;
champion:除了冠军,还有捍卫维护的意思&lt;br&gt;
cunning:n.狡猾狡诈&lt;br&gt;
ruthlessness:无情冷酷&lt;br&gt;
furnish:v.提供,供应&lt;br&gt;
resolute:坚决的,坚定的&lt;br&gt;
steadfast:忠诚的,坚贞不渝的&lt;br&gt;
integrity:n.诚实正直;完整;完好&lt;br&gt;
beacon:引路人,指路明灯&lt;br&gt;
bourgeois:过分追求名利的,注意物质享受的;市侩的,庸俗的&lt;br&gt;
epochal:具有时代意义的&lt;br&gt;
bombast:空洞华丽的(言论)&lt;br&gt;
hitherto:ad.迄今,至今&lt;br&gt;
nurture:v.培养培育&lt;br&gt;
unpick:v.拆去针脚,撬开,引申为分析研究&lt;br&gt;
multiplicity:多样性&lt;br&gt;
downstairs:底层(阶级)&lt;br&gt;
upstairs:上层(阶级)&lt;br&gt;
fruition:n.(计划、过程或活动的)完成，实现，取得成果:come to fruition:完成实现&lt;br&gt;
revolutionize:v.彻底改革,彻底变革&lt;br&gt;
steady:稳定的,持续的&lt;br&gt;
telecommunication:电磁通信,远距离通信&lt;br&gt;
receipt:收据收条&lt;br&gt;
unauthorized:未被授权的,未经认可的&lt;br&gt;
fraud:欺诈,欺骗&lt;br&gt;
chunk:厚块,大块&lt;br&gt;
trail:踪迹,痕迹&lt;br&gt;
stubbornly:顽固地,倔强地&lt;br&gt;
make the point:表明观点&lt;br&gt;
automate:自动化&lt;br&gt;
relate:除了关联之外还有讲述叙述的意思&lt;br&gt;
look to do sh:寻找机会做某事&lt;br&gt;
for good:永久地,永远地,一劳永逸地&lt;br&gt;
birds of passage:候鸟,漂泊的人&lt;br&gt;
affectionate:深情的,充满深情的&lt;br&gt;
rigid:严格的,僵硬的死板的&lt;br&gt;
brand:打烙印于,印商标于&lt;br&gt;
paralysis:n.麻痹,无力,停顿(活动工作能力)完全丧失,瘫痪&lt;br&gt;
look beyond:超越...看问题&lt;br&gt;
in the making:在酝酿中,在形成中&lt;br&gt;
kick out:踢出&lt;br&gt;
hail ..as...:将..誉为...&lt;br&gt;
mightily:很,非常ad&lt;br&gt;
straddle:跨立于,跨越&lt;br&gt;
jurisdiction:管辖范围&lt;br&gt;
commit oneself to sth/doing sth:承诺&lt;br&gt;
in motion:在运动中的&lt;br&gt;
prone:有..倾向的,易于倾向于&lt;br&gt;
snap:仓促的,匆忙的,注意与nap(小憩)的区别&lt;br&gt;
hard-wired:(计算机系统中)硬件控制的,硬连线的,固有的,天生的(innate):be hard-wired to do sth:天生会做某事&lt;br&gt;
mechanism:机制&lt;br&gt;
assess:评估(哎,千万别忘了啊)&lt;br&gt;
preferably:ad.较好,更适宜&lt;br&gt;
sociable:好交际的,合群的,友好的&lt;br&gt;
stimuli:n.刺激(stimulus的复数)&lt;br&gt;
exclusive:独有的,独占的,专有的:be exclusive to:专为...独享&lt;br&gt;
prime:v.使准备好:prime sb to do sth:使某人准备好应付某种情况&lt;br&gt;
interpersonal:人际关系的,&lt;br&gt;
reverse:颠倒,逆转&lt;br&gt;
ground:v.使接触地面.打基础&lt;br&gt;
retreat:僻静处,隐居处,休息寓所&lt;br&gt;
mute:减弱...的声音,使...柔和(可以引申为控制,抑制)&lt;br&gt;
contemplate:沉思,深思熟虑,冥思苦想&lt;br&gt;
revitalize:使得到复兴&lt;br&gt;
weave:使组合,使交织&lt;br&gt;
paraphrase:意译,改述&lt;br&gt;
by virtue of:由于,因为&lt;br&gt;
disperse:使分散&lt;br&gt;
intervene:干预&lt;br&gt;
alternative:n.(两者或以上)择一&lt;br&gt;
deploy:利用&lt;br&gt;
profile:n.面部的侧影;侧面轮廓;概述;简介;传略;印象;形象v.扼要介绍;概述;写简介&lt;br&gt;
high-profile:高调的,备受瞩目的&lt;br&gt;
convert:除了动词转换转变还有名词:皈依者,改变信念的人&lt;br&gt;
indulgence:n.放纵溺爱&lt;br&gt;
momentum:势头声势&lt;br&gt;
coalition:联合联盟&lt;br&gt;
shave off:减少,剃掉&lt;br&gt;
skate by:轻松通过&lt;br&gt;
testimonial:推荐信,证明书&lt;br&gt;
curricular:课程的,extracurricular:课外的&lt;br&gt;
level:还有动词使平等的意思&lt;br&gt;
level the playing field:创造公平的竞争环境&lt;br&gt;
unveil:公布,为...揭幕&lt;br&gt;
speculative:猜测性的,投机的&lt;br&gt;
rigor:严格&lt;br&gt;
resistence:阻力,抵抗力&lt;br&gt;
demonstrate:[ˈdemənstreɪt] v.证明;证实;论证;说明;表达;表露;表现;显露;示范;演示&lt;br&gt;
compelling:英 [kəmˈpelɪŋ] 美 [kəmˈpelɪŋ]adj.引人入胜的;扣人心弦的;非常强烈的;不可抗拒的;令人信服的v.强迫;迫使;使必须;引起(反应)&lt;br&gt;
the best bits of:最好的部分&lt;br&gt;
come into force:生效,开始实施&lt;br&gt;
flaw:缺点,瑕疵&lt;br&gt;
premise:n.前提,假定&lt;br&gt;
levy:n.征收&lt;br&gt;
fine:罚款&lt;br&gt;
regulate:监管.self-regulatory:自我监管的&lt;br&gt;
spray around:分散,喷洒&lt;br&gt;
leak:泄露渗漏&lt;br&gt;
harmonise:使和谐&lt;br&gt;
embroil::v使卷入,使混乱&lt;br&gt;
template:模板样板&lt;br&gt;
overarching:包罗万象的&lt;br&gt;
dominoes[&#39;dominouz]n.多米诺骨牌（PlL1）&lt;br&gt;
slap on the wrist 象征性惩罚（P1L1）&lt;br&gt;
show the door 开除，扫地出门（P1L2）&lt;br&gt;
insensitive[in&#39;senstiv]a.缺乏同情心的,不敏感的（P1L3）&lt;br&gt;
misconduct[imis&#39;kondakt]n.不端行为（PlL4）&lt;br&gt;
integrity[un&#39;tegrtu]n.正直；诚实（P2L1）&lt;br&gt;
pragmatic[preg&#39;maetik]a.实用主义的（P21L3）&lt;br&gt;
course of action做法，行动步骤（P2L3）&lt;br&gt;
overlook A for the sake of B:为B忽略A（P3L2）&lt;br&gt;
ethical lapse 道德败坏，道德堕落（P3L3）&lt;br&gt;
accountable[a&#39;kauntobl]a.有责任的，负责的（P315）&lt;br&gt;
fallout[folaut]n.（尤指预料不到的）影响，结果&lt;br&gt;
harshly[ha:fu]ad.严厉地；严酷的（P5L1）&lt;br&gt;
toxic[&#39;toksik]a.有毒的；中毒的（P5L2）&lt;br&gt;
one-off[iwan&#39;of]n.一次性事物（P6L2）&lt;br&gt;
paper over 隐瞒（有争议或使人不愉快之事）&lt;br&gt;
bigwig[&#39;brgwrg]n.有重大影响的人（P1L3）&lt;br&gt;
gung-ho[&#39;gag&#39;hou]a.非常急切的（P7L1）&lt;br&gt;
errant:犯错误的;行为不当的;出格的;对配偶不忠的&lt;br&gt;
accountable:负责的&lt;br&gt;
inclusive:adj.包含全部费用;包括所提到的费用在内;包括提到的所有的天数(或月、数目等)在内;包容广阔的;范围广泛的&lt;br&gt;
fallout:后果,余波&lt;br&gt;
wicked:adj.邪恶的;缺德的;淘气的;调皮的;恶作剧的;危险的;有害的;强大的n恶人;邪恶的人&lt;br&gt;
revolutionise[.revallufanalz]v.彻底改变，使彻底变革&lt;br&gt;
star-up[&#39;statAp]n.初创公司&lt;br&gt;
gig worker零工，临时工（P2L1）&lt;br&gt;
reimagine[ria&#39;maedsin]v.重新构想&lt;br&gt;
benefit[&#39;benift]n.福利，补贴&lt;br&gt;
weather[&#39;we0].经受住，平安度过&lt;br&gt;
ensuing[in&#39;sjug]a.随后的&lt;br&gt;
select[silekt]a.精选的，挑选出的&lt;br&gt;
emerging[I&#39;msxd31g]a.新兴的，新出现的&lt;br&gt;
compromise[&#39;kompromalz]v.妥协，让步&lt;br&gt;
step in介入，干预（P3L1）&lt;br&gt;
on one&#39;s own terms按照某人自己的意愿&lt;br&gt;
climate[&#39;klatmt]n.氛围，形势&lt;br&gt;
opening[&#39;oupanig]n.机遇，良机&lt;br&gt;
tailor:定做，根据需要制作&lt;br&gt;
aggregate[egrg]a.总计的，合计的&lt;br&gt;
intermittent[inta&#39;mutant]a.断断续续的，间歇的&lt;br&gt;
trigger:n.(枪的)扳机;(尤指引发不良反应或发展的)起因，诱因;触发器;引爆器v.发动;引起;触发;开动;起动&lt;br&gt;
dignity:n.庄重;庄严;尊严;尊贵;高贵;高尚;自豪;自尊;自重&lt;br&gt;
rational[&#39;refnol]a.理性的；合理的（P3L1）&lt;br&gt;
fosil[&#39;fosl]n.化石（P513）&lt;br&gt;
auction[&#39;o.kJn]n.竞卖，拍卖（P3L4）&lt;br&gt;
shake off摆脱（P6L5）&lt;br&gt;
scheme[skim]n.（造福他人的）计划，方案（P3L4）&lt;br&gt;
onshore[&#39;on/]n.陆上的，朝岸的（P4L3）&lt;br&gt;
muster[&#39;masta]v.鼓起（勇气），积聚（信心），争取支持&lt;br&gt;
curb[katb]v.控制，抑制，束缚&lt;br&gt;
ideological[iaidia&#39;lodglkl]a.思想上的，意识形态&lt;br&gt;
shuter[Uata]u.便停止运行，关闭；装百页窗&lt;br&gt;
press ahead推进，加紧进行&lt;br&gt;
fury[&#39;fjuori]n.狂怒，暴怒&lt;br&gt;
infrastructure[nfrstraktfar]n.基础设施，基础&lt;br&gt;
arbitrary::任意的,专断的&lt;br&gt;
opaque:不透明的&lt;/p&gt;
&lt;h2 id=&#34;几个带tem容易混淆的单词&#34;&gt;几个带tem容易混淆的单词&lt;/h2&gt;
&lt;p&gt;contempt:轻视蔑视&lt;br&gt;
contemplate:周密考虑,深思熟虑,冥思苦想&lt;br&gt;
tempt:诱惑,引诱,temptation&lt;br&gt;
template:模板样板&lt;/p&gt;
&lt;h2 id=&#34;阅读思路&#34;&gt;阅读思路&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;注意程度
&lt;ul&gt;
&lt;li&gt;类似的,不提倡,不支持,不建议**&amp;lt;--不等于--&amp;gt;**禁止&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;选项错误的原因
&lt;ul&gt;
&lt;li&gt;偷换主语&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;给文章取标题的题目
&lt;ul&gt;
&lt;li&gt;考查概括主旨,体现文章探讨的主要对象&lt;/li&gt;
&lt;li&gt;干扰项长为文章中的细枝末节,不能涵盖全文内容&lt;/li&gt;
&lt;li&gt;仅在&lt;strong&gt;某一段&lt;/strong&gt;出现一次或多次的关键词不是,而分别在&lt;strong&gt;不同段&lt;/strong&gt;出现大于一次的关键词可能是的,末尾段一般作为总结,看看开头的句子是否有出现在别的段落的关键词&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;偷换概念
&lt;ul&gt;
&lt;li&gt;XX举措有利于sth变得怎么这么样-&amp;gt;有利于已经怎么怎么样的sth:
&lt;ul&gt;
&lt;li&gt;例题:张剑阅读模拟题T2中:有利于学校提升排名-&amp;gt;这有利于高排名的学校&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;It can be inferred from XXX_____:之类的一定是作者的观点,不要想当然的自己去推断
&lt;ul&gt;
&lt;li&gt;开头说某些人认为xxx怎样怎样,但作者要是有一丝提到不怎样怎样就不好,说明作者是反对之前这些人的观点的,选项可能还包含其他干扰项,多是论证开头这个怎样怎样的,要是选项涉及这个怎样怎样且和作者观点相同,多半是选这个(例如张剑模拟题T3/13)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;动词的意思中类似使xx解释&#34;&gt;动词的意思中类似**(使)XX**解释&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;原因就在这里,以air为例：&lt;br&gt;
air vt. 使通风;vi. 通风&lt;br&gt;
air 同时是vt和vi。当它是vt时，就要把括号中的使字译出。当它是vi是，就不用把使译出。为了方便，所以很多字典都把使用括号括起来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以correlate为例:(使)相互关联&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;及物&lt;br&gt;
The figures do not seem to correlate.&lt;br&gt;
这些数字似乎毫不相干。&lt;/li&gt;
&lt;li&gt;不及物&lt;br&gt;
A high-fat diet correlates with a greater risk of heart disease.&lt;br&gt;
高脂肪饮食与增加心脏病发作的风险密切相关。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;imply和implicate&lt;br&gt;
hint 是给个“bai提示”，比如老师du留作业的时候顺便给你个hint，或者有话不直zhi说但是拐弯给你个hint让你自dao己去领悟。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;imply带有推理的性质，比如两眼距离过大往往implies这个人是白痴，一个现象推理出另一个结论，用imply。&lt;/p&gt;
&lt;p&gt;implicate跟imply有点联系，都有推理的性质，但是这个词好象不推出什么好事情，比如被牵连进去就是implicate in...&lt;br&gt;
4. issue&lt;br&gt;
英 [ˈɪʃuː] 美 [ˈɪʃuː]&lt;br&gt;
n.&lt;br&gt;
重要议题;争论的问题;(有关某事的)问题，担忧;一期;期号&lt;br&gt;
v.&lt;br&gt;
宣布;公布;发出;(正式)发给，供给;(尤指通过正式文件)将…诉诸法律&lt;/p&gt;
">背单词时遇到到意思相近的词</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-yi-zhang-xing-lie-shi/"" data-c="
          &lt;h2 id=&#34;自己的理解&#34;&gt;自己的理解&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;n阶行列式:就是一行挑一个出来,不能在同一列,这n个数相乘,前面的正负号按列序号的排列的逆序数来决定,逆序数是偶就取1,逆序数是奇就取-1,最后再累加(也就是代数和)&lt;/li&gt;
&lt;li&gt;逆序数:
&lt;ul&gt;
&lt;li&gt;由1,2,3....n组成的有序数组成为一个n阶排列,通常用j&lt;sub&gt;1&lt;/sub&gt;,j&lt;sub&gt;2&lt;/sub&gt;,...j&lt;sub&gt;n&lt;/sub&gt;来表示n阶排列(j就是列嘛)&lt;/li&gt;
&lt;li&gt;在一次的排列中,如果大的数排在了小的前面,就称这俩数构成了一个__逆序__,一个排列的逆序的总数称为这个排列的__逆序数__&lt;/li&gt;
&lt;li&gt;偶排列:逆序数是偶数,奇排列就是奇数了&lt;/li&gt;
&lt;li&gt;例25134: 21,51,53,54,逆序数就是4了&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;计算的技巧&#34;&gt;计算的技巧&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;看0的情况:
&lt;ul&gt;
&lt;li&gt;0多的情况下,先按0多的那一行(列)展开&lt;/li&gt;
&lt;li&gt;0排列比较规则的情况下,可考虑拉普拉斯展开式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">第一章 行列式</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/di-yi-zhang-xu-lun/"" data-c="
          &lt;p&gt;&lt;ul class=&#34;markdownIt-TOC&#34;&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#11-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD&#34;&gt;1.1 数据结构的基本概念和术语&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#111-%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9C%AF%E8%AF%AD&#34;&gt;1.1.1 概念和术语&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#112-%E4%B8%8A%E8%BF%B0%E6%9C%AF%E8%AF%AD%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB&#34;&gt;1.1.2 上述术语的联系与区别&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#113-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%89%E8%A6%81%E7%B4%A0%E7%9A%84%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A&#34;&gt;1.1.3 数据结构三要素的详细解释&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#12-%E8%87%AA%E5%B7%B1%E7%9A%84%E9%83%A8%E5%88%86%E7%90%86%E8%A7%A3%E5%92%8C%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF&#34;&gt;1.2 自己的部分理解和解题思路&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#121-%E6%A6%82%E5%BF%B5&#34;&gt;1.2.1 概念&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#13-%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7&#34;&gt;1.3 算法和算法评价&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#131-%E7%AE%97%E6%B3%95%E7%9A%84%E5%8F%8A%E8%AE%BE%E8%AE%A1%E8%A6%81%E6%B1%82&#34;&gt;1.3.1 算法的及设计要求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#132-%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%A6%E9%87%8F&#34;&gt;1.3.2 算法效率的度量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#133-%E8%AE%A1%E7%AE%97&#34;&gt;1.3.3 计算&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
(目录)&lt;br&gt;
&lt;strong&gt;考点:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据结构相关的概念和术语&lt;/li&gt;
&lt;li&gt;数据结构的三要素:逻辑结构,物理结构和数据运算&lt;/li&gt;
&lt;li&gt;算法时间复杂度和空间复杂度的分析与计算(重点)
&lt;ul&gt;
&lt;li&gt;算法设计题通常都要求分析时间,空间复杂度&lt;/li&gt;
&lt;li&gt;考查时间复杂度的选择题&lt;br&gt;
&lt;strong&gt;知识框架&lt;/strong&gt;&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/songdlut/Picbed_PicGo/master/img/1.1.png&#34; alt=&#34;1.1&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;11-数据结构的基本概念和术语&#34;&gt;1.1 数据结构的基本概念和术语&lt;/h2&gt;
&lt;h3 id=&#34;111-概念和术语&#34;&gt;1.1.1 概念和术语&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;比较好理解的例子:&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/songdlut/Picbed_PicGo/master/img/DS1.2.png&#34; alt=&#34;1.2&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;定义&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;数据:数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。数据是计算机程序加工的原料。&lt;/li&gt;
&lt;li&gt;数据元素:
&lt;ul&gt;
&lt;li&gt;数据元素是数据的__基本单位__，通常作为一个整体进行考虑和处理。一个数据元素可由__若干数据项(&amp;gt;=1)__组成，&lt;strong&gt;数据项是构成数据元素的不可分割的最小单位&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;在不同的条件下，数据元素又可称为元素、结点、顶点、记录等。数据元素是用一组属性描述定义、标识、表示和允许值的一个数据单元。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据对象:
&lt;ul&gt;
&lt;li&gt;数据对象是具有__相同性质的数据元素的集合__，是数据的一个子集。例如，整数数据对象是集合N={0，土1，土2，…}&lt;/li&gt;
&lt;li&gt;只是一个集合,元素间的关系除了是同一个集合(虽然同为集合,但是和逻辑结构中的非线性结构的集合不要混淆,它不能代表一种数据结构),别无其他&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;缺少关系不可以用来定义一个完整的数据结构&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据类型&lt;br&gt;
数据类型是一个值的集合和定义在此集合上的一组操作的总称。
&lt;ul&gt;
&lt;li&gt;原子类型:其值不可再分的数据类型&lt;/li&gt;
&lt;li&gt;结构类型:其值可以再分解为若干成分(分量)的数据类型
&lt;ul&gt;
&lt;li&gt;固定聚合类型:值由确定数目的成分按某种结构组成.如:复数是由两个实数依确定的次序关系构成的&lt;/li&gt;
&lt;li&gt;可变聚合类型:&amp;quot;值&amp;quot;的成分的数目不确定.如:定义一个&amp;quot;有序整数序列&amp;quot;的抽象数据类型,其中序列的长度是可变的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;抽象数据类型:是指一个数学模型以及定义在该模型上的一组操作。(抽象数据组织及与之相关的操作)&lt;/li&gt;
&lt;li&gt;数据结构:是相互之间存在一种或多种特定关系的数据元素的集合,在任何问题中，数据元素都不是孤立存在的，它们之间存在某种关系，这种数据元素相互之间的关系称为结构（Structure）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;112-上述术语的联系与区别&#34;&gt;1.1.2 上述术语的联系与区别&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;数据结构和数据类型是所属关系&lt;a href=&#34;https://www.zhihu.com/question/21165020/answer/118852959&#34;&gt;知乎&lt;/a&gt;&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/songdlut/Picbed_PicGo/master/img/DS1.3.jpg&#34; alt=&#34;1.3&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
一种数据结构+定义在此种数据结构上的一组操作=结构类型&lt;br&gt;
一种值的集合+定义在此种值的集合上的一组操作=原子类型&lt;br&gt;
结构类型+原子类型=数据类型&lt;br&gt;
一句话总结，数据结构是一种值的集合，这种值集＋值集上的操作就是结构类型，而结构类型是数据类型中的一种，所以数据结构属于数据类型。&lt;/li&gt;
&lt;li&gt;数据类型和抽象数据类型的关系&lt;br&gt;
它们的异同其实就在字面上了抽象。&lt;br&gt;
&lt;strong&gt;抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关&lt;/strong&gt;，即无论其内部结构如何变化，只要它的数学特性不变，都不影响其外部的使用。”抽象“的意义在于数据类型的数学抽象特性。&lt;/li&gt;
&lt;li&gt;知乎上的理解:“数据类型”是计算机发展出来的一种重要思想，它将程序设计一分为二：实现基本数据类型和使用抽象数据类型。实现基本数据类型是指在物理层面实现数据类型的逻辑特性；使用抽象数据类型是指仅仅关注数据类型的逻辑特性，而不关注硬件实现。这样两边的人都可以更集中注意力于自己的工作范围，进行更深的钻研。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;113-数据结构三要素的详细解释&#34;&gt;1.1.3 数据结构三要素的详细解释&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;逻辑结构&lt;br&gt;
逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。
&lt;ul&gt;
&lt;li&gt;与数据的存储无关,是独立于计算机的.
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数据的逻辑结构独立于存储结构&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;__数据的存储结构是逻辑结构在计算机上的映射,不能独立于逻辑结构而存在&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分为线性结构和非线性结构,线性表是典型的线性结构；集合、树和图是典型的非线性结构。&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/songdlut/Picbed_PicGo/master/img/DS1.4.png&#34; alt=&#34;1.4&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;集合。结构中的数据元素之间除“同属一个集合”外，别无其他关系。&lt;/li&gt;
&lt;li&gt;线性结构。结构中的数据元素之间只存在__一对一__的关系。&lt;/li&gt;
&lt;li&gt;树形结构。结构中的数据元素之间存在__一对多__的关系。&lt;/li&gt;
&lt;li&gt;图状结构或网状结构。结构中的数据元素之间存在__多对多__的关系。&lt;br&gt;
&lt;img src=&#34;https://raw.githubusercontent.com/songdlut/Picbed_PicGo/master/img/DS1.5.png&#34; alt=&#34;1.5&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;存储结构&lt;br&gt;
存储结构是指数据结构在__计算机中的表示（又称映像），也称物理结构__。它包括__数据元素的表示和关系的表示__。数据的存储结构是用计算机语言实现的逻辑结构，&lt;strong&gt;它依赖于计算机语言&lt;/strong&gt;。数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储。
&lt;ul&gt;
&lt;li&gt;1）顺序存储。把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。其优点是可以实现随机存取，每个元素占用最少的存储空间；缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片。&lt;/li&gt;
&lt;li&gt;2）链式存储。不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系。其优点是不会出现碎片现象，能充分利用所有存储单元；缺点是每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取。&lt;/li&gt;
&lt;li&gt;3）索引存储。在存储元素信息的同时，还建立附加的索引表。索引表中的每项称为索引项，索引项的一般形式是（关键字，地址）。其优点是检索速度快；缺点是附加的索引表额外占用存储空间。另外，增加和删除数据时也要修改索引表，因而会花费较多的时间。&lt;/li&gt;
&lt;li&gt;4）散列存储。根据元素的关键字直接计算出该元素的存储地址，又称__哈希（Hash）存储__。&lt;br&gt;
其优点是检索、增加和删除结点的操作都很快；缺点是若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销。&lt;br&gt;
&lt;strong&gt;注意&lt;/strong&gt;:XX表中,XX带有顺序,链,哈希之类的都代表了物理(存储)结构,XX抽象一点如有序之类的是逻辑结构&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;数据的运算&lt;br&gt;
施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤。&lt;/li&gt;
&lt;li&gt;总结&lt;br&gt;
数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的__设计__取决于所选定的__逻辑结构__，而算法的__实现__依赖于所采用的__存储结构__。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;12-自己的部分理解和解题思路&#34;&gt;1.2 自己的部分理解和解题思路&lt;/h2&gt;
&lt;h3 id=&#34;121-概念&#34;&gt;1.2.1 概念&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据结构三要素的任意一种不同,就不是同一种数据结构
&lt;ul&gt;
&lt;li&gt;因而提问&amp;quot;逻辑或物理,逻辑或运算,……不同时,是不是同一种数据结构&amp;quot;的题,就可以回答这两种相同,但是另一个不一样的情况下也不是同一种数据结构.例如(王道p5)二又树和二又排序树，二叉排序树可以采用二叉树的逻辑表示和存储方式，前者通常用于表示层次关系，而后者通常用于排序和查找。虽然它们的运算都有建立树、插入结点、删除结点和查找结点等功能，但对于二叉树和二叉排序树，这些运算的定义是不同的，以查找结点为例，二叉树的时间复杂度为O(n)，而二叉排序树的时间复杂度为O(log&lt;sub&gt;2&lt;/sub&gt;n)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可以用__抽象数据类型__来定义一个完整的数据结构
&lt;ul&gt;
&lt;li&gt;解析:抽象数据类型描述了数据的逻辑结构和抽象运算，通常用（数据对象、数据关系、基本操作集）这样的三元组来表示，从而构成一个完整的数据结构定义。&lt;/li&gt;
&lt;li&gt;个人理解,是可以用更细节的来定义较抽象的(小定大)
&lt;ul&gt;
&lt;li&gt;1.数据结构可以用（数据元素的有限集、数据元素的关系）二元组定义。&lt;/li&gt;
&lt;li&gt;2.抽象数据类型是用三元组（数据对象、数据关系、基本操作集）&lt;/li&gt;
&lt;li&gt;3.数据对象是性质相同的数据元素的集合。所以数据结构主要是比抽象数据类型少了一个操作集，所以可以用抽象数据类型定义一个完整的数据结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;13-算法和算法评价&#34;&gt;1.3 算法和算法评价&lt;/h2&gt;
&lt;h3 id=&#34;131-算法的及设计要求&#34;&gt;1.3.1 算法的及设计要求&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;算法（Algorithm）是对特定问题求解步骤的一种描述，它是指令的有限序列，其中的每条指令表示一个或多个操作。此外，一个算法还具有下列5个重要特性：&lt;br&gt;
1）有穷性。一个算法必须总在执行有穷步之后结束，且每一步都可在有穷时间内完成。&lt;br&gt;
2）确定性。算法中每条指令必须有确切的含义，对于相同的输入只能得出相同的输出。&lt;br&gt;
3）可行性。算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。&lt;br&gt;
4）输入。一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合。&lt;br&gt;
5）输出。一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量。&lt;/li&gt;
&lt;li&gt;通常，设计一个“好”的算法应考虑达到以下目标：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;正确性。算法应能够正确地解决求解问题。
&lt;ul&gt;
&lt;li&gt;a.程序不含语法错误；&lt;/li&gt;
&lt;li&gt;b.程序对于几组输入数据能够得出满足规格说明要求的结果；&lt;/li&gt;
&lt;li&gt;c.程序对于精心选择的典型、苛刻而带有刁难性的几组输入数据能够得出满足规格说明要求的结果&lt;/li&gt;
&lt;li&gt;d.程序对于一切合法的输入数据都能产生满足规格说明要求的结果。&lt;/li&gt;
&lt;li&gt;显然，达到第d层意义下的正确是极为困难的，所有不同输入数据的数量大得惊人，逐一验证的方法是不现实的。对于大型软件需要进行专业测试，而一般情况下，通常以第c层意义的正确性作为衡量一个程序是否合格的标准&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;可读性。算法应具有良好的可读性，以帮助人们理解。&lt;/li&gt;
&lt;li&gt;健壮性。输入非法数据时，算法能适当地做出反应或进行处理，而不会产生莫名其妙的输出结果。&lt;/li&gt;
&lt;li&gt;效率与低存储量需求。&lt;strong&gt;效率是指算法执行的时间&lt;/strong&gt;，&lt;strong&gt;存储量需求是指算法执行过程中所需要的最大存储空间&lt;/strong&gt;，这两者都与问题的规模有关。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;132-算法效率的度量&#34;&gt;1.3.2 算法效率的度量&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;时间复杂度
&lt;ul&gt;
&lt;li&gt;一个算法是由__控制结构（顺序、分支和循环3种）和原操作（指固有数据类型的操作）__构成的，则算法时间取决于两者的综合效果。&lt;/li&gt;
&lt;li&gt;语句的频度:该语句重复执行的次数&lt;/li&gt;
&lt;li&gt;T(n)
&lt;ul&gt;
&lt;li&gt;王道上以及查到的一些资料称:算法中所有语句的频度之和记为T(n)&lt;/li&gt;
&lt;li&gt;书上:执行时间/时间量度&lt;/li&gt;
&lt;li&gt;对于这两种不用太抠字眼,就是对时间复杂度的描述或者说符号,毕竟__分析时间复杂度的时候都是分析T(n)的数量级__(但是还是王道上的好理解一些)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;算法中基本运算（最深层循环内的语句）的频度与T(n)同数量级(就挑一个基本操作)，因此通常采用算法中基本运算的频度f(n)来分析算法的时间复杂度。因此，算法的时间复杂度记为 &lt;center&gt;T(n)=O(f(n))&lt;/center&gt;式中，O的含义是T(n)的数量级，其严格的数学定义是：若T(n)和f(n)是定义在正整数集合上的两个函数，则存在正常数C和n&lt;sub&gt;0&lt;/sub&gt;，使得当n≥n&lt;sub&gt;0&lt;/sub&gt;时，都满足0≤T(n)小于等于C(n)。&lt;/li&gt;
&lt;li&gt;渐进时间复杂度:简称是时间复杂度&lt;/li&gt;
&lt;li&gt;一般总是考虑最坏情况下的时间复杂度(除特殊指明)
&lt;ul&gt;
&lt;li&gt;算法的时间复杂度不仅依赖于问题的规模n，也取决于待输入数据的性质（如输入数据元素的初始状态）。例如，在数组A[0..n-1]中，查找给定值k的算法大致如下：&lt;br&gt;
（1）i=n-1；&lt;br&gt;
（2）while（i&amp;gt;=0&amp;amp;&amp;amp;（A[i]！=k））&lt;br&gt;
（3）i--；&lt;br&gt;
（4）return i；该算法中语句3（基本运算）的频度不仅与问题规模n有关，而且与输入实例中A的各元素的取值及k的取值有关：&lt;br&gt;
①若A中没有与k相等的元素，则语句3的频度f（n）=n。&lt;br&gt;
②若A的最后一个元素等于k，则语句3的频度f（n）是常数0。&lt;br&gt;
最坏时间复杂度是指在最坏情况下，算法的时间复杂度。&lt;br&gt;
平均时间复杂度是指所有可能输入实例在等概率出现的情况下，算法的期望运行时间。&lt;br&gt;
最好时间复杂度是指在最好情况下，算法的时间复杂度。&lt;br&gt;
一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比它更长。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在分析一个程序的时间复杂性时，有以下两条规则：
&lt;ul&gt;
&lt;li&gt;a)加法规则&lt;br&gt;
T(n)=T1(n)+T2(n)=O(f(n))+O(g(n))=O(maxf(n)，g(n)))&lt;/li&gt;
&lt;li&gt;b)乘法规则&lt;br&gt;
T(n)=T1(n)×T2(n)=O(f(n))×O(g(n))=O(n)xg(n)&lt;/li&gt;
&lt;li&gt;常见的渐近时间复杂度为&lt;br&gt;
O(1)&amp;lt;Olog2n)&amp;lt;O(n)&amp;lt;O(nlogan)&amp;lt;O(n2)&amp;lt;O(n3)&amp;lt;O(2)&amp;lt;O(n!)&amp;lt;O(n&lt;sup&gt;n&lt;/sup&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;空间复杂度&lt;br&gt;
类似于算法的时间复杂度，本书中以空间复杂度(space complexity)作为算法所需存储空间的量度，记作&lt;center&gt;S(n)=O(f(n))&lt;/center&gt;其中n为问题的规模(或大小)。一个上机执行的程序除了需要存储空间来寄存本身所用指令、常数、变量和输入数据外，也需要一些对数据进行操作的工作单元和存储一些为实现计算所需信息的辅助空间。若输入数据所占空间只取决于问题本身，和算法无关，则只需要分析除输入和程序之外的额外空间，否则应同时考虑输入本身所需空间(和输入数据的表示形式有关)。若额外空间相对于输入数据量来说是常数，则称此算法为原地工作，第10章讨论的有些排序算法就属于这类。又如果所占空间量依赖于特定的输入，则除特别指明外，均按最坏情况来分析。&lt;br&gt;
&lt;strong&gt;算法原地工作是指算法所需要的辅助空间为常量&lt;/strong&gt;,并非是不需要任何额外的辅助空间.&lt;br&gt;
&lt;strong&gt;同一个算法,实现的语言的级别越高,执行效率越低&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;133-计算&#34;&gt;1.3.3 计算&lt;/h3&gt;
&lt;p&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/50479555&#34;&gt;知乎转载&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;时间复杂度&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;常数阶O(1)&lt;br&gt;
无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性阶O(n)&lt;br&gt;
这个在最开始的代码示例中就讲解过了，如：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;for(i=1; i&amp;lt;=n; ++i)
{
   j = i;
   j++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对数阶O(logN)&lt;br&gt;
还是先来看代码：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int i = 1;
while(i&amp;lt;n)
{
    i = i * 2;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n&lt;br&gt;
也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线性对数阶O(nlogN)&lt;br&gt;
线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。&lt;br&gt;
就拿上面的代码加一点修改来举例：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;for(m=1; m&amp;lt;n; m++)
{
    i = 1;
    while(i&amp;lt;n)
    {
        i = i * 2;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;平方阶O(n²)&lt;br&gt;
平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。&lt;br&gt;
举例：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;for(x=1; i&amp;lt;=n; x++)
{
   for(i=1; i&amp;lt;=n; i++)
    {
       j = i;
       j++;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²)&lt;br&gt;
如果将其中一层循环的n改成m，即：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for(x=1; i&amp;lt;=m; x++)
{
   for(i=1; i&amp;lt;=n; i++)
    {
       j = i;
       j++;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那它的时间复杂度就变成了 O(m*n)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;立方阶O(n³)、K次方阶O(n^k)&lt;br&gt;
参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似。&lt;/li&gt;
&lt;li&gt;除此之外，其实还有 平均时间复杂度、均摊时间复杂度、最坏时间复杂度、最好时间复杂度 的分析方法，有点复杂，这里就不展开了。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;空间复杂度&lt;br&gt;
既然时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的。&lt;br&gt;
空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。&lt;br&gt;
空间复杂度比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;空间复杂度 O(1)&lt;br&gt;
如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1),举例：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空间复杂度 O(n)&lt;br&gt;
我们先看一个代码：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;int[] m = new int[n]
for(i=1; i&amp;lt;=n; ++i)
{
   j = i;
   j++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)&lt;br&gt;
以上，就是对算法的时间复杂度与空间复杂度基础的分析，欢迎大家一起交流。&lt;br&gt;
3. 递归算法和非递归算法在分析时间复杂度上是不同的&lt;br&gt;
在算法分析中，当一个算法中包含递归调用时，其时间复杂度的分析会转化为一个递归方程求解。实际上，这个问题是数学上求解渐近阶的问题，而递归方程的形式多种多样，其求解方法也是不一而足，比较常用的有以下四种方法：&lt;br&gt;
(1)代入法(Substitution Method)&lt;/p&gt;
&lt;p&gt;代入法的基本步骤是先推测递归方程的显式解，然后用数学归纳法来验证该解是否合理。&lt;/p&gt;
&lt;p&gt;(2)迭代法(Iteration Method)&lt;/p&gt;
&lt;p&gt;迭代法的基本步骤是迭代地展开递归方程的右端，使之成为一个非递归的和式，然后通过对和式的估计来达到对方程左端即方程的解的估计。&lt;/p&gt;
&lt;p&gt;(3)套用公式法(Master Method)&lt;/p&gt;
&lt;p&gt;这个方法针对形如“T(n) = aT(n/b) + f(n)”的递归方程。这种递归方程是分治法的时间复杂性所满足的递归关系，即一个规模为n的问题被分成规模均为n/b的a个子问题，递归地求解这a个子问题，然后通过对这a个子间题的解的综合，得到原问题的解。&lt;/p&gt;
&lt;p&gt;(4)差分方程法(Difference Formula Method)&lt;br&gt;
可以将某些递归方程看成差分方程，通过解差分方程的方法来解递归方程，然后对解作出渐近阶估计。&lt;/p&gt;
&lt;p&gt;下面就以上方法给出一些例子说明。&lt;/p&gt;
&lt;p&gt;一、代入法&lt;br&gt;
大整数乘法计算时间的递归方程为：T(n) = 4T(n/2) + O(n)，其中T(1) = O(1)，我们猜测一个解T(n) = O(n2 )，根据符号O的定义，对n&amp;gt;n0，有T(n) &amp;lt; cn2 - eO(2n)（注意，这里减去O(2n)，因其是低阶项，不会影响到n足够大时的渐近性），把这个解代入递归方程，得到：&lt;/p&gt;
&lt;p&gt;T(n) = 4T(n/2) + O(n)&lt;br&gt;
≤ 4c(n/2)2 - eO(2n/2)) + O(n)&lt;br&gt;
= cn2 - eO(n) + O(n)&lt;br&gt;
≤ cn2&lt;/p&gt;
&lt;p&gt;其中，c为正常数，e取1，上式符合 T(n)≤cn2 的定义，则可认为O(n2 )是T(n)的一个解，再用数学归纳法加以证明。&lt;/p&gt;
&lt;p&gt;二、迭代法&lt;br&gt;
某算法的计算时间为：T(n) = 3T(n/4) + O(n)，其中T(1) = O(1)，迭代两次可将右端展开为：&lt;/p&gt;
&lt;p&gt;T(n) = 3T(n/4) + O(n)&lt;br&gt;
= O(n) + 3( O(n/4) + 3T(n/42 ) )&lt;br&gt;
= O(n) + 3( O(n/4) + 3( O(n/42 ) + 3T(n/43 ) ) )&lt;/p&gt;
&lt;p&gt;从上式可以看出，这是一个递归方程，我们可以写出迭代i次后的方程：&lt;/p&gt;
&lt;p&gt;T(n) = O(n) + 3( O(n/4) + 3( O(n/42 ) + ... + 3( n/4i + 3T(n/4i+1 ) ) ) )&lt;/p&gt;
&lt;p&gt;当n/4i+1 =1时，T(n/4i+1 )=1，则&lt;/p&gt;
&lt;p&gt;T(n) = n + (3/4) + (32 /42 )n + ... + (3i /4i )n + (3i+1 )T(1)&lt;br&gt;
&amp;lt; 4n + 3i+1&lt;/p&gt;
&lt;p&gt;而由n/4i+1 =1可知，i&amp;lt;log4 n，从而&lt;/p&gt;
&lt;p&gt;3i+1 ≤ 3log4 n+1 = 3log3 n*log4 3 +1 = 3nlog4 3&lt;/p&gt;
&lt;p&gt;代入得：&lt;/p&gt;
&lt;p&gt;T(n) &amp;lt; 4n + 3nlog4 3，即T(n) = O(n)。&lt;/p&gt;
&lt;p&gt;三、套用公式法&lt;/p&gt;
&lt;p&gt;这个方法为估计形如：&lt;br&gt;
T(n) = aT(n/b) + f(n)&lt;br&gt;
其中，a≥1和b≥1，均为常数，f(n)是一个确定的正函数。在f(n)的三类情况下，我们有T(n)的渐近估计式：&lt;br&gt;
1.若对于某常数ε&amp;gt;0，有f(n) = O(nlogb a-ε )，则T(n) = O(nlogb a )&lt;/p&gt;
&lt;p&gt;2.若f(n) = O(nlogb a )，则T(n) = O(nlogb a *logn)&lt;/p&gt;
&lt;p&gt;3.若f(n) = O(nlogb a+ε )，且对于某常数c&amp;gt;1和所有充分大的正整数n，有af(n/b)≤cf(n)，则T(n)=O(f(n))。&lt;/p&gt;
&lt;p&gt;设T(n) = 4T(n/2) + n，则a = 4，b = 2，f(n) = n，计算得出nlogb a = nlog2 4 = n2 ，而f(n) = n = O(n2-ε )，此时ε= 1，根据第1种情况，我们得到T(n) = O(n2 )。&lt;/p&gt;
&lt;p&gt;这里涉及的三类情况，都是拿f(n)与nlogb a 作比较，而递归方程解的渐近阶由这两个函数中的较大者决定。在第一类情况下，函数nlogb a 较大，则T(n)=O(nlogb a )；在第三类情况下，函数f(n)较大，则T(n)=O(f (n))；在第二类情况下，两个函数一样大，则T(n)=O(nlogb a *logn)，即以n的对数作为因子乘上f(n)与T(n)的同阶。&lt;/p&gt;
&lt;p&gt;但上述三类情况并没有覆盖所有可能的f(n)。在第一类情况和第二类情况之间有一个间隙：f(n)小于但不是多项式地小于nlogb a ，第二类与第三类之间也存在这种情况，此时公式法不适用。&lt;/p&gt;
">第一章 绪论</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;p&gt;考研复习笔记&lt;/p&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;p&gt;以后会很NB的&lt;/p&gt;
&lt;h2 id=&#34;兴趣爱好&#34;&gt;⛹ 兴趣爱好&lt;/h2&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
&lt;p&gt;QQ:1031404638&lt;br&gt;
电话:18742023723&lt;/p&gt;
">关于</a>
      </div>
      
      <div class="item">
        <a class="result-title" style="opacity: 0;" href="https://songdlut.github.io/post/hello-gridea/"" data-c="
          &lt;p&gt;👏  欢迎使用 &lt;strong&gt;Gridea&lt;/strong&gt; ！&lt;br&gt;
✍️  &lt;strong&gt;Gridea&lt;/strong&gt; 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/getgridea/gridea&#34;&gt;Github&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://gridea.dev/&#34;&gt;Gridea 主页&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;http://fehey.com/&#34;&gt;示例网站&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;特性&#34;&gt;特性👇&lt;/h2&gt;
&lt;p&gt;📝  你可以使用最酷的 &lt;strong&gt;Markdown&lt;/strong&gt; 语法，进行快速创作&lt;/p&gt;
&lt;p&gt;🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片&lt;/p&gt;
&lt;p&gt;🏷️  你可以对文章进行标签分组&lt;/p&gt;
&lt;p&gt;📋  你可以自定义菜单，甚至可以创建外部链接菜单&lt;/p&gt;
&lt;p&gt;💻  你可以在 &lt;strong&gt;Windows&lt;/strong&gt;，&lt;strong&gt;MacOS&lt;/strong&gt; 或 &lt;strong&gt;Linux&lt;/strong&gt; 设备上使用此客户端&lt;/p&gt;
&lt;p&gt;🌎  你可以使用 &lt;strong&gt;𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌&lt;/strong&gt; 或 &lt;strong&gt;Coding Pages&lt;/strong&gt; 向世界展示，未来将支持更多平台&lt;/p&gt;
&lt;p&gt;💬  你可以进行简单的配置，接入 &lt;a href=&#34;https://github.com/gitalk/gitalk&#34;&gt;Gitalk&lt;/a&gt; 或 &lt;a href=&#34;https://github.com/SukkaW/DisqusJS&#34;&gt;DisqusJS&lt;/a&gt; 评论系统&lt;/p&gt;
&lt;p&gt;🇬🇧  你可以使用&lt;strong&gt;中文简体&lt;/strong&gt;或&lt;strong&gt;英语&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力&lt;/p&gt;
&lt;p&gt;🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步&lt;/p&gt;
&lt;p&gt;🌱 当然 &lt;strong&gt;Gridea&lt;/strong&gt; 还很年轻，有很多不足，但请相信，它会不停向前 🏃&lt;/p&gt;
&lt;p&gt;未来，它一定会成为你离不开的伙伴&lt;/p&gt;
&lt;p&gt;尽情发挥你的才华吧！&lt;/p&gt;
&lt;p&gt;😘 Enjoy~&lt;/p&gt;
">Hello Gridea</a>
      </div>
      
    </div>
    <div class="page">
      <div id="page_ul"></div>
    </div>
  </div>
</div>
<script>
  !function () {
    let searchMask = document.querySelector('#search_mask');
    let result = document.querySelector('#result');
    let items = document.querySelectorAll('.item');
    let searchBox = document.querySelector('#search');
    let statCount = document.querySelector('#stat_count');
    let statTimes = document.querySelector('#stat_times');
    let pageUl = document.querySelector('#page_ul');
    let close = document.querySelector('#close');
    
    close.addEventListener('click', function() {
      searchMask.style = 'display: none;'
    })

    let finds = [];
    let contents = [];
    let pageSize = 10;
    items.forEach(item => {
      let a = item.querySelector('a');
      contents.push({
        title: a.innerText,
        details: a.dataset.c,
        link: a.href
      })
      item.remove();
    })

    function insertStr(soure, start, count) {
      let newStr = soure.substr(start, count);
      return soure.slice(0, start) + '<em>' + newStr + '</em>' + soure.slice(start + count);
    }

    pageUl.addEventListener('click', function(event) {
      let target = event.target;
      if (target.__proto__ === HTMLSpanElement.prototype) {
        appendResults(parseInt(target.dataset.i));
      }
    })

    function appendResults(index) {
      let htmlResult = '';
      let start = index || 0;
      let end = Math.min(start + pageSize, finds.length);
      for (let i = start; i < end; i++) {
        const current = finds[i];
        let html = current.title;
        let sum = 0;
        let positions = current.positions;
        positions.forEach(position => {
          html = insertStr(html, position.start + sum, position.count);
          sum += 9;
        })
        htmlResult += `<div class="item"><a class="result-title" href="${current.link}">${html}</a></div>`;
      }
      result.innerHTML = htmlResult;
      pageUl.innerHTML = '';
      let count = finds.length / pageSize;
      let lis = '';
      if (start !== 0) {
        lis += `<span class="fa fa-angle-left" data-i='${start - 1}'></span>`;
      }
      for (let i = 0; i < count; i++) {
        lis += `<span class='${i === start?'current':''}' data-i='${i}'>${i+1}</span>`;     
      }
      if (start+1 < count) {
        lis += `<span class="fa fa-angle-right" data-i='${start+1}'></span>`;  
      }
      pageUl.innerHTML = lis;
    }

    function search(delay) {
      let timer = null
      return function () {
        clearTimeout(timer)
        timer = setTimeout(() => {
          let start = Date.now();
          let segments = searchBox.value.split(' ').filter(c => c != '');
          if (segments.length <= 0) {
            return;
          }
          finds = [];
          let htmlResult = '';
          contents.forEach(content => {
            let title = content.title;
            let positions = [];
            let find = false;
            segments.forEach((segment) => {
              if (content.title.includes(segment)) {
                find = true;
                positions.push({
                  start: content.title.indexOf(segment),
                  count: segment.length
                })
              } else if (content.details.includes(segment)) {
                find = true;
              }
            });
            if (find) {
              finds.push({
                title: content.title,
                link: content.link,
                positions
              });
            }
          })
          appendResults(0);
          statCount.textContent = finds.length;
          statTimes.textContent = Date.now() - start;
        }, delay)
      }
    }
    searchBox.addEventListener('input', search(200));
  }()
</script>

<input hidden id="copy" />
<script>
  let language = '';
  if (language !== '') {
    let map = new Map();
    if (language === 'en') {
      map.set('search', 'Search');
      map.set('category', 'Categories');
      map.set('article', 'Articles');
      map.set('tag', 'Tags');
      map.set('top', 'Top');
      map.set('publish', 'published');
      map.set('minute', ' minutes');
      map.set('read-more', 'Read More');
      map.set('view', 'View');
      map.set('words', ' words');
      map.set('category-in', 'category in');
      map.set('preview', 'Meta');
      map.set('index', 'Toc');
      map.set('no-archives', "You haven't created yet");
      map.set('archives', " articles in total");
      map.set('cloud-tags', " tags in total");
      map.set('copyright', "Copyright: ");
      map.set('author', "Author: ");
      map.set('link', "Link: ");
      map.set('leave-message', "Leave a message");
      map.set('format', "Links Format");
      map.set('site-name', "Name: ");
      map.set('site-link', "Link: ");
      map.set('site-desc', "Desc: ");
      map.set('stat', " related results, taking ");
      map.set('stat-time', " ms");
      map.set('site-img', "Image: ");
    }

    if (map.size > 0) {
      let lanElems = document.querySelectorAll('.language');
      lanElems.forEach(elem => {
        let lan = elem.dataset.lan, text = map.get(lan);
        if (elem.__proto__ === HTMLInputElement.prototype) {
          elem.placeholder = text
        } else {
          if (elem.dataset.count) {
            text = elem.dataset.count + text;
          }
          elem.textContent = text;
        }
      })
    }
  }
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })

</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 200
  });
</script>



<script src="/media/js/cool.js"></script>

</html>